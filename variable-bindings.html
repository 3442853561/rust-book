<!DOCTYPE HTML>
<html lang="zh-Hant">
    <head>
        <meta charset="UTF-8">
        <title>Rust 程式語言 正體中文版</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The Rust Programming Language">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

		<style>
            @import url(http://fonts.googleapis.com/earlyaccess/cwtexhei.css);
        </style>
        <link rel="stylesheet" href="book.css">
        <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body>
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="README.html"><strong>1.</strong> 簡介</a></li><li><a href="getting-started.html"><strong>2.</strong> 準備</a></li><li><a href="guessing-game.html"><strong>3.</strong> 教學: 猜數字遊戲</a></li><li><a href="syntax-and-semantics.html"><strong>4.</strong> 語法及語意</a></li><li><ul class="section"><li><a href="variable-bindings.html" class="active"><strong>4.1.</strong> 變數綁定</a></li><li><a href="functions.html"><strong>4.2.</strong> 函式</a></li><li><a href="primitive-types.html"><strong>4.3.</strong> 基本型別</a></li><li><a href="comments.html"><strong>4.4.</strong> 註解</a></li><li><a href="if.html"><strong>4.5.</strong> if</a></li><li><a href="loops.html"><strong>4.6.</strong> 迴圈</a></li><li><a href="ownership.html"><strong>4.7.</strong> 所有權</a></li><li><a href="references-and-borrowing.html"><strong>4.8.</strong> 參照與借用</a></li><li><a href="lifetimes.html"><strong>4.9.</strong> 生命週期</a></li><li><a href="mutability.html"><strong>4.10.</strong> 可變性</a></li><li><a href="structs.html"><strong>4.11.</strong> 結構體</a></li><li><a href="enums.html"><strong>4.12.</strong> 枚舉</a></li><li><a href="match.html"><strong>4.13.</strong> Match</a></li><li><a href="patterns.html"><strong>4.14.</strong> Patterns</a></li><li><a href="method-syntax.html"><strong>4.15.</strong> Method Syntax</a></li><li><a href="vectors.html"><strong>4.16.</strong> Vectors</a></li><li><a href="strings.html"><strong>4.17.</strong> Strings</a></li><li><a href="generics.html"><strong>4.18.</strong> Generics</a></li><li><a href="traits.html"><strong>4.19.</strong> Traits</a></li><li><a href="drop.html"><strong>4.20.</strong> Drop</a></li><li><a href="if-let.html"><strong>4.21.</strong> if let</a></li><li><a href="trait-objects.html"><strong>4.22.</strong> Trait Objects</a></li><li><a href="closures.html"><strong>4.23.</strong> Closures</a></li><li><a href="ufcs.html"><strong>4.24.</strong> Universal Function Call Syntax</a></li><li><a href="crates-and-modules.html"><strong>4.25.</strong> Crates and Modules</a></li><li><a href="const-and-static.html"><strong>4.26.</strong> <code>const</code> and <code>static</code></a></li><li><a href="attributes.html"><strong>4.27.</strong> Attributes</a></li><li><a href="type-aliases.html"><strong>4.28.</strong> <code>type</code> aliases</a></li><li><a href="casting-between-types.html"><strong>4.29.</strong> Casting between types</a></li><li><a href="associated-types.html"><strong>4.30.</strong> Associated Types</a></li><li><a href="unsized-types.html"><strong>4.31.</strong> Unsized Types</a></li><li><a href="operators-and-overloading.html"><strong>4.32.</strong> Operators and Overloading</a></li><li><a href="deref-coercions.html"><strong>4.33.</strong> Deref coercions</a></li><li><a href="macros.html"><strong>4.34.</strong> Macros</a></li><li><a href="raw-pointers.html"><strong>4.35.</strong> Raw Pointers</a></li><li><a href="unsafe.html"><strong>4.36.</strong> <code>unsafe</code></a></li></ul></li><li><a href="effective-rust.html"><strong>5.</strong> Effective Rust</a></li><li><ul class="section"><li><a href="the-stack-and-the-heap.html"><strong>5.1.</strong> The Stack and the Heap</a></li><li><a href="testing.html"><strong>5.2.</strong> Testing</a></li><li><a href="conditional-compilation.html"><strong>5.3.</strong> Conditional Compilation</a></li><li><a href="documentation.html"><strong>5.4.</strong> Documentation</a></li><li><a href="iterators.html"><strong>5.5.</strong> Iterators</a></li><li><a href="concurrency.html"><strong>5.6.</strong> Concurrency</a></li><li><a href="error-handling.html"><strong>5.7.</strong> Error Handling</a></li><li><a href="choosing-your-guarantees.html"><strong>5.8.</strong> Choosing your Guarantees</a></li><li><a href="ffi.html"><strong>5.9.</strong> FFI</a></li><li><a href="borrow-and-asref.html"><strong>5.10.</strong> Borrow and AsRef</a></li><li><a href="release-channels.html"><strong>5.11.</strong> Release Channels</a></li><li><a href="using-rust-without-the-standard-library.html"><strong>5.12.</strong> Using Rust without the standard library</a></li></ul></li><li><a href="nightly-rust.html"><strong>6.</strong> Nightly Rust</a></li><li><ul class="section"><li><a href="compiler-plugins.html"><strong>6.1.</strong> Compiler Plugins</a></li><li><a href="inline-assembly.html"><strong>6.2.</strong> Inline Assembly</a></li><li><a href="no-stdlib.html"><strong>6.3.</strong> No stdlib</a></li><li><a href="intrinsics.html"><strong>6.4.</strong> Intrinsics</a></li><li><a href="lang-items.html"><strong>6.5.</strong> Lang items</a></li><li><a href="advanced-linking.html"><strong>6.6.</strong> Advanced linking</a></li><li><a href="benchmark-tests.html"><strong>6.7.</strong> Benchmark Tests</a></li><li><a href="box-syntax-and-patterns.html"><strong>6.8.</strong> Box Syntax and Patterns</a></li><li><a href="slice-patterns.html"><strong>6.9.</strong> Slice Patterns</a></li><li><a href="associated-constants.html"><strong>6.10.</strong> Associated Constants</a></li><li><a href="custom-allocators.html"><strong>6.11.</strong> Custom Allocators</a></li></ul></li><li><a href="glossary.html"><strong>7.</strong> 詞彙表</a></li><li><a href="syntax-index.html"><strong>8.</strong> 語法索引</a></li><li><a href="bibliography.html"><strong>9.</strong> 參考文獻</a></li><li><a href="MappingTable.html"><strong>10.</strong> 中英文字彙對照表</a></li><li><a href="CONTRIBUTORS.html"><strong>11.</strong> 翻譯貢獻名單</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">Rust 程式語言 正體中文版</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <h1>變數綁定</h1>
<p>事實上所有非 &quot;Hello World&quot; 的 Rust 程式都會用到 <em>變數綁定</em>。
他們將數值綁定到一個名字上，以便在之後使用它。
<code>let</code> 用來聲明一個綁定，就像：</p>
<pre><code class="language-rust">fn main() {
    let x = 5;
}
</code></pre>
<p>在所有範例中放入 <code>fn main() {</code> 有點冗餘，所以我們在後面都會省略它。
如果你一路看下去，請記得寫上 <code>main()</code> 函式，不要忘記了。
否則你會得到錯誤訊息。</p>
<h2>模式 (Patterns)</h2>
<p>在很多語言，變數綁定被叫做 <em>變數</em> (variable)，但是 Rust 的變數綁定藏有秘招。
例如 <code>let</code> 表達式左邊是一個<a href="patterns.html">模式</a>，而不是變數名稱。
這代表我們可以做一些如下的事：</p>
<pre><code class="language-rust">let (x, y) = (1, 2);
</code></pre>
<p>在這個表達式計算後，<code>x</code> 會是 1，而 <code>y</code> 會是 2。
模式非常強大，而且在本書中有<a href="patterns.html">自己的章節</a>。
現在我們還不需要這些功能，所以我們只要記住有這個東西，然後繼續就可以了。</p>
<h2>型別註釋 (Type annotations)</h2>
<p>Rust 是靜態型別語言，這代表我們要先具體指定我們所需的型別，然後它們會在編譯期被檢查。
那為什麼第一個例子可以編譯過呢？
恩，因為 Rust 有一個 &quot;型別推斷&quot; (type inference) 的功能。
如果它能判斷某個東西的型別，你就不需要確切地指出來。</p>
<p>如果我們想要，也可以加上型別。
型別寫在冒號 (<code>:</code>) 後面：</p>
<pre><code class="language-rust">let x: i32 = 5;
</code></pre>
<p>如果我要求你大聲唸給班上同學聽，你應該唸成『<code>x</code> 被綁定為 <code>i32</code> 型別，而且數值是 <code>5</code>。』</p>
<p>這個例子中我們宣稱 <code>x</code> 為一個 32 位元的帶號整數 (signed integer)。
Rust 有許多不同的基本整數型別。
以 <code>i</code> 開頭的是帶號整數 (signed integers)，而以 <code>u</code> 開頭的是非帶號整數 (unsigned integers)。
整數可能的大小有 8、16、32、及 64 位元。</p>
<p>之後的範例，我們會把型別註釋在註解中。
範例會像這樣：</p>
<pre><code class="language-rust">fn main() {
    let x = 5; // x: i32
}
</code></pre>
<p>注意，註釋和 <code>let</code> 語法很類似。
Rust 習慣上不會有這些註解，但是我們偶爾會加上它們來幫助你理解 Rust 推斷的是什麼型別。</p>
<h2>可變性 (Mutability)</h2>
<p>綁定的預設是 <em>不可變的</em> (immutable)。
下面的原始碼無法編譯：</p>
<pre><code class="language-rust,ignore">let x = 5;
x = 10;
</code></pre>
<p>他會給你以下錯誤訊息：</p>
<pre><code class="language-text">error: re-assignment of immutable variable `x`
     x = 10;
     ^~~~~~~
</code></pre>
<p>如果你要綁定成為可變的 (mutable)，你可以用 <code>mut</code>：</p>
<pre><code class="language-rust">let mut x = 5; // mut x: i32
x = 10;
</code></pre>
<p>有不只一個理由要讓綁定的預設是不可變的，但是我們可以藉由一個 Rust 的一個主要目標來想想看：安全。
如果你忘記宣告 <code>mut</code>，編譯器會抓到它，然後讓你知道你可能改了某些並非真的想要改的東西。
如果綁定預設是可變的，編譯器就無法告訴你了。
如果你 <em>真的</em> 打算要改變，解決方式很簡單：加上 <code>mut</code>。</p>
<p>盡可能的避免改變狀態有其他好的理由，但是他們不在本指南的範圍內。
一般來說，你會避免直接了當的使用可變數 (mutation)，這也是 Rust 希望的。
雖然如此，有時候，你還是需要可變數，所以他沒有被禁止使用。</p>
<h2>初始化綁定 (Initializing bindings)</h2>
<p>Rust 的變數綁定有跟其他語言不同的一個方面：綁定需要再使用之前初始化一個數值。</p>
<p>讓我們試試看。
把你的 <code>src/main.rs</code> 改成以下這樣：</p>
<pre><code class="language-rust">fn main() {
    let x: i32;

    println!(&quot;Hello world!&quot;);
}
</code></pre>
<p>你可以輸入 <code>cargo build</code> 去建構它。
你將會得到警告訊息，但是它仍會印出 &quot;Hello, world!&quot;：</p>
<pre><code class="language-text">   Compiling hello_world v0.0.1 (file:///home/you/projects/hello_world)
src/main.rs:2:9: 2:10 warning: unused variable: `x`, #[warn(unused_variable)]
   on by default
src/main.rs:2     let x: i32;
                      ^
</code></pre>
<p>Rust 警告我們沒有使用這個變數綁定，但是的確我們沒有使用它，沒關係。
但如果我們真的使用 <code>x</code>，事情就不同了。
讓我們試試看。
把你的程式改成這樣：</p>
<pre><code class="language-rust,ignore">fn main() {
    let x: i32;

    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre>
<p>然後試著建構它。
你會得到錯誤訊息：</p>
<pre><code class="language-bash">$ cargo build
   Compiling hello_world v0.0.1 (file:///home/you/projects/hello_world)
src/main.rs:4:39: 4:40 error: use of possibly uninitialized variable: `x`
src/main.rs:4     println!(&quot;The value of x is: {}&quot;, x);
                                                    ^
note: in expansion of format_args!
&lt;std macros&gt;:2:23: 2:77 note: expansion site
&lt;std macros&gt;:1:1: 3:2 note: in expansion of println!
src/main.rs:4:5: 4:42 note: expansion site
error: aborting due to previous error
Could not compile `hello_world`.
</code></pre>
<p>Rust 不讓我們使用沒有被初始化的數值。
接著，讓我們討論我們加在 <code>println!</code> 的東西。</p>
<p>如果你在要印出的字串中加入大括號（<code>{}</code> 有些人稱作 moustaches ...），Rust 會理解為這是一個插入數值的要求。
<em>字串插值</em> (string interpolation) 是個電腦科學術語，代表 &quot;插入到字串中&quot;。
我們加上一個逗號和 <code>x</code>，來表示我們想要用 <code>x</code> 當成插入的值。
逗號是當我們傳遞多個參數時，用來分隔我們傳遞給函式和巨集的參數用的。</p>
<p>當你使用大括號時，Rust 會試著檢查型別，用有意義的方式顯示數值。
如果你想用更詳細的方式去指定格式，這邊有<a href="../std/fmt/index.html">很多方式可供選擇</a>。
現在，我們使用預設方式插入：印出整數並不難。</p>
<h2>有效範圍及遮蔽 (Scope and shadowing)</h2>
<p>讓我們回到綁定。
變數綁定有有效範圍 - 它們被限制在它們被定義的區塊中存在。
一個區塊 (block) 是一個被用 <code>{</code> 和 <code>}</code> 包起來的陳述式的集合。
函式的定義也是一個區塊！
在以下範例我們定義兩個變數綁定，<code>x</code> 和 <code>y</code>，他們存在於不同區塊中。
<code>x</code> 可以在 <code>fn main() {}</code> 內存取，而 <code>y</code> 只能在內部區塊 (inner block) 存取。</p>
<pre><code class="language-rust,ignore">fn main() {
    let x: i32 = 17;
    {
        let y: i32 = 3;
        println!(&quot;The value of x is {} and value of y is {}&quot;, x, y);
    }
    println!(&quot;The value of x is {} and value of y is {}&quot;, x, y); // This won't work
}
</code></pre>
<p>第一個 <code>println!</code> 會印出 &quot;The value of x is 17 and the value of y is 3&quot;，但是本範例無法成功編譯，因為第二個 <code>println!</code> 不能存取 <code>y</code> 的值，因為它已經不在有效範圍內了。
我們會得到以下錯誤訊息：</p>
<pre><code class="language-bash">$ cargo build
   Compiling hello v0.1.0 (file:///home/you/projects/hello_world)
main.rs:7:62: 7:63 error: unresolved name `y`. Did you mean `x`? [E0425]
main.rs:7     println!(&quot;The value of x is {} and value of y is {}&quot;, x, y); // This won't work
                                                                       ^
note: in expansion of format_args!
&lt;std macros&gt;:2:25: 2:56 note: expansion site
&lt;std macros&gt;:1:1: 2:62 note: in expansion of print!
&lt;std macros&gt;:3:1: 3:54 note: expansion site
&lt;std macros&gt;:1:1: 3:58 note: in expansion of println!
main.rs:7:5: 7:65 note: expansion site
main.rs:7:62: 7:63 help: run `rustc --explain E0425` to see a detailed explanation
error: aborting due to previous error
Could not compile `hello`.

To learn more, run the command again with --verbose.
</code></pre>
<p>另外，變數綁定可以被遮蔽 (shadowed)。
這代表與其他變數綁定有同樣名稱的後一個變數綁定，在有效範圍內，將會覆蓋前一個綁定。</p>
<pre><code class="language-rust">let x: i32 = 8;
{
    println!(&quot;{}&quot;, x); // Prints &quot;8&quot;
    let x = 12;
    println!(&quot;{}&quot;, x); // Prints &quot;12&quot;
}
println!(&quot;{}&quot;, x); // Prints &quot;8&quot;
let x =  42;
println!(&quot;{}&quot;, x); // Prints &quot;42&quot;
</code></pre>
<p>遮蔽 (shadowing) 和可變綁定 (mutable bindings) 也許像同一枚硬幣的兩面一樣，但他們是兩個不同的概念，所以不一定總是可以直接替換。
作為其中之一，遮蔽可以讓我們重新綁定名稱到不同型別的變數。
它也可以改變綁定的可變性。</p>
<pre><code class="language-rust">let mut x: i32 = 1;
x = 7;
let x = x; // x is now immutable and is bound to 7

let y = 4;
let y = &quot;I can also be bound to text!&quot;; // y is now of a different type
</code></pre>
<blockquote>
<p><em>commit 6ba9520</em></p>
</blockquote>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="syntax-and-semantics.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="functions.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="syntax-and-semantics.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="functions.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
