<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Rust 程式語言 正體中文版</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The Rust Programming Language">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body>
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="README.html"><strong>1.</strong> 簡介</a></li><li><a href="getting-started.html"><strong>2.</strong> 準備</a></li><li><a href="guessing-game.html"><strong>3.</strong> 教學: 猜謎遊戲</a></li><li><a href="syntax-and-semantics.html"><strong>4.</strong> 語法及語意</a></li><li><ul class="section"><li><a href="variable-bindings.html"><strong>4.1.</strong> 變數綁定</a></li><li><a href="functions.html"><strong>4.2.</strong> 函式</a></li><li><a href="primitive-types.html"><strong>4.3.</strong> 基本型別</a></li><li><a href="comments.html"><strong>4.4.</strong> Comments</a></li><li><a href="if.html"><strong>4.5.</strong> if</a></li><li><a href="loops.html"><strong>4.6.</strong> Loops</a></li><li><a href="ownership.html"><strong>4.7.</strong> Ownership</a></li><li><a href="references-and-borrowing.html"><strong>4.8.</strong> References and Borrowing</a></li><li><a href="lifetimes.html"><strong>4.9.</strong> Lifetimes</a></li><li><a href="mutability.html"><strong>4.10.</strong> Mutability</a></li><li><a href="structs.html"><strong>4.11.</strong> Structs</a></li><li><a href="enums.html"><strong>4.12.</strong> Enums</a></li><li><a href="match.html"><strong>4.13.</strong> Match</a></li><li><a href="patterns.html"><strong>4.14.</strong> Patterns</a></li><li><a href="method-syntax.html"><strong>4.15.</strong> Method Syntax</a></li><li><a href="vectors.html"><strong>4.16.</strong> Vectors</a></li><li><a href="strings.html"><strong>4.17.</strong> Strings</a></li><li><a href="generics.html"><strong>4.18.</strong> Generics</a></li><li><a href="traits.html"><strong>4.19.</strong> Traits</a></li><li><a href="drop.html"><strong>4.20.</strong> Drop</a></li><li><a href="if-let.html"><strong>4.21.</strong> if let</a></li><li><a href="trait-objects.html"><strong>4.22.</strong> Trait Objects</a></li><li><a href="closures.html"><strong>4.23.</strong> Closures</a></li><li><a href="ufcs.html"><strong>4.24.</strong> Universal Function Call Syntax</a></li><li><a href="crates-and-modules.html"><strong>4.25.</strong> Crates and Modules</a></li><li><a href="const-and-static.html"><strong>4.26.</strong> <code>const</code> and <code>static</code></a></li><li><a href="attributes.html"><strong>4.27.</strong> Attributes</a></li><li><a href="type-aliases.html"><strong>4.28.</strong> <code>type</code> aliases</a></li><li><a href="casting-between-types.html"><strong>4.29.</strong> Casting between types</a></li><li><a href="associated-types.html"><strong>4.30.</strong> Associated Types</a></li><li><a href="unsized-types.html"><strong>4.31.</strong> Unsized Types</a></li><li><a href="operators-and-overloading.html"><strong>4.32.</strong> Operators and Overloading</a></li><li><a href="deref-coercions.html"><strong>4.33.</strong> Deref coercions</a></li><li><a href="macros.html"><strong>4.34.</strong> Macros</a></li><li><a href="raw-pointers.html"><strong>4.35.</strong> Raw Pointers</a></li><li><a href="unsafe.html"><strong>4.36.</strong> <code>unsafe</code></a></li></ul></li><li><a href="effective-rust.html"><strong>5.</strong> Effective Rust</a></li><li><ul class="section"><li><a href="the-stack-and-the-heap.html"><strong>5.1.</strong> The Stack and the Heap</a></li><li><a href="testing.html"><strong>5.2.</strong> Testing</a></li><li><a href="conditional-compilation.html"><strong>5.3.</strong> Conditional Compilation</a></li><li><a href="documentation.html"><strong>5.4.</strong> Documentation</a></li><li><a href="iterators.html"><strong>5.5.</strong> Iterators</a></li><li><a href="concurrency.html"><strong>5.6.</strong> Concurrency</a></li><li><a href="error-handling.html"><strong>5.7.</strong> Error Handling</a></li><li><a href="choosing-your-guarantees.html"><strong>5.8.</strong> Choosing your Guarantees</a></li><li><a href="ffi.html"><strong>5.9.</strong> FFI</a></li><li><a href="borrow-and-asref.html"><strong>5.10.</strong> Borrow and AsRef</a></li><li><a href="release-channels.html"><strong>5.11.</strong> Release Channels</a></li><li><a href="using-rust-without-the-standard-library.html"><strong>5.12.</strong> Using Rust without the standard library</a></li></ul></li><li><a href="nightly-rust.html"><strong>6.</strong> Nightly Rust</a></li><li><ul class="section"><li><a href="compiler-plugins.html"><strong>6.1.</strong> Compiler Plugins</a></li><li><a href="inline-assembly.html"><strong>6.2.</strong> Inline Assembly</a></li><li><a href="no-stdlib.html"><strong>6.3.</strong> No stdlib</a></li><li><a href="intrinsics.html"><strong>6.4.</strong> Intrinsics</a></li><li><a href="lang-items.html"><strong>6.5.</strong> Lang items</a></li><li><a href="advanced-linking.html"><strong>6.6.</strong> Advanced linking</a></li><li><a href="benchmark-tests.html"><strong>6.7.</strong> Benchmark Tests</a></li><li><a href="box-syntax-and-patterns.html"><strong>6.8.</strong> Box Syntax and Patterns</a></li><li><a href="slice-patterns.html"><strong>6.9.</strong> Slice Patterns</a></li><li><a href="associated-constants.html"><strong>6.10.</strong> Associated Constants</a></li><li><a href="custom-allocators.html"><strong>6.11.</strong> Custom Allocators</a></li></ul></li><li><a href="glossary.html"><strong>7.</strong> 詞彙表</a></li><li><a href="syntax-index.html" class="active"><strong>8.</strong> 語法索引</a></li><li><a href="bibliography.html"><strong>9.</strong> 參考文獻</a></li><li><a href="CONTRIBUTORS.html"><strong>10.</strong> 翻譯貢獻名單</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">Rust 程式語言 正體中文版</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <p>% Syntax Index</p>
<h2>Keywords</h2>
<ul>
<li><code>as</code>: primitive casting, or disambiguating the specific trait containing an item.  See [Casting Between Types (<code>as</code>)], [Universal Function Call Syntax (Angle-bracket Form)], [Associated Types].</li>
<li><code>break</code>: break out of loop.  See [Loops (Ending Iteration Early)].</li>
<li><code>const</code>: constant items and constant raw pointers.  See [<code>const</code> and <code>static</code>], [Raw Pointers].</li>
<li><code>continue</code>: continue to next loop iteration.  See [Loops (Ending Iteration Early)].</li>
<li><code>crate</code>: external crate linkage.  See [Crates and Modules (Importing External Crates)].</li>
<li><code>else</code>: fallback for <code>if</code> and <code>if let</code> constructs.  See [<code>if</code>], [<code>if let</code>].</li>
<li><code>enum</code>: defining enumeration.  See [Enums].</li>
<li><code>extern</code>: external crate, function, and variable linkage.  See [Crates and Modules (Importing External Crates)], [Foreign Function Interface].</li>
<li><code>false</code>: boolean false literal.  See [Primitive Types (Booleans)].</li>
<li><code>fn</code>: function definition and function pointer types.  See [Functions].</li>
<li><code>for</code>: iterator loop, part of trait <code>impl</code> syntax, and higher-ranked lifetime syntax.  See [Loops (<code>for</code>)], [Method Syntax].</li>
<li><code>if</code>: conditional branching.  See [<code>if</code>], [<code>if let</code>].</li>
<li><code>impl</code>: inherent and trait implementation blocks.  See [Method Syntax].</li>
<li><code>in</code>: part of <code>for</code> loop syntax.  See [Loops (<code>for</code>)].</li>
<li><code>let</code>: variable binding.  See [Variable Bindings].</li>
<li><code>loop</code>: unconditional, infinite loop.  See [Loops (<code>loop</code>)].</li>
<li><code>match</code>: pattern matching.  See [Match].</li>
<li><code>mod</code>: module declaration.  See [Crates and Modules (Defining Modules)].</li>
<li><code>move</code>: part of closure syntax.  See [Closures (<code>move</code> closures)].</li>
<li><code>mut</code>: denotes mutability in pointer types and pattern bindings.  See [Mutability].</li>
<li><code>pub</code>: denotes public visibility in <code>struct</code> fields, <code>impl</code> blocks, and modules.  See [Crates and Modules (Exporting a Public Interface)].</li>
<li><code>ref</code>: by-reference binding.  See [Patterns (<code>ref</code> and <code>ref mut</code>)].</li>
<li><code>return</code>: return from function.  See [Functions (Early Returns)].</li>
<li><code>Self</code>: implementor type alias.  See [Traits].</li>
<li><code>self</code>: method subject.  See [Method Syntax (Method Calls)].</li>
<li><code>static</code>: global variable.  See <a href="const-and-static.html#static"><code>const</code> and <code>static</code> (<code>static</code>)</a>.</li>
<li><code>struct</code>: structure definition.  See [Structs].</li>
<li><code>trait</code>: trait definition.  See [Traits].</li>
<li><code>true</code>: boolean true literal.  See [Primitive Types (Booleans)].</li>
<li><code>type</code>: type alias, and associated type definition.  See [<code>type</code> Aliases], [Associated Types].</li>
<li><code>unsafe</code>: denotes unsafe code, functions, traits, and implementations.  See [Unsafe].</li>
<li><code>use</code>: import symbols into scope.  See [Crates and Modules (Importing Modules with <code>use</code>)].</li>
<li><code>where</code>: type constraint clauses.  See [Traits (<code>where</code> clause)].</li>
<li><code>while</code>: conditional loop.  See [Loops (<code>while</code>)].</li>
</ul>
<h2>Operators and Symbols</h2>
<ul>
<li><code>!</code> (<code>ident!(…)</code>, <code>ident!{…}</code>, <code>ident![…]</code>): denotes macro expansion.  See [Macros].</li>
<li><code>!</code> (<code>!expr</code>): bitwise or logical complement.  Overloadable (<code>Not</code>).</li>
<li><code>!=</code> (<code>var != expr</code>): nonequality comparison.  Overloadable (<code>PartialEq</code>).</li>
<li><code>%</code> (<code>expr % expr</code>): arithmetic remainder.  Overloadable (<code>Rem</code>).</li>
<li><code>%=</code> (<code>var %= expr</code>): arithmetic remainder &amp; assignment.</li>
<li><code>&amp;</code> (<code>expr &amp; expr</code>): bitwise and.  Overloadable (<code>BitAnd</code>).</li>
<li><code>&amp;</code> (<code>&amp;expr</code>): borrow.  See [References and Borrowing].</li>
<li><code>&amp;</code> (<code>&amp;type</code>, <code>&amp;mut type</code>, <code>&amp;'a type</code>, <code>&amp;'a mut type</code>): borrowed pointer type.  See [References and Borrowing].</li>
<li><code>&amp;=</code> (<code>var &amp;= expr</code>): bitwise and &amp; assignment.</li>
<li><code>&amp;&amp;</code> (<code>expr &amp;&amp; expr</code>): logical and.</li>
<li><code>*</code> (<code>expr * expr</code>): arithmetic multiplication.  Overloadable (<code>Mul</code>).</li>
<li><code>*</code> (<code>*expr</code>): dereference.</li>
<li><code>*</code> (<code>*const type</code>, <code>*mut type</code>): raw pointer.  See [Raw Pointers].</li>
<li><code>*=</code> (<code>var *= expr</code>): arithmetic multiplication &amp; assignment.</li>
<li><code>+</code> (<code>expr + expr</code>): arithmetic addition.  Overloadable (<code>Add</code>).</li>
<li><code>+</code> (<code>trait + trait</code>, <code>'a + trait</code>): compound type constraint.  See [Traits (Multiple Trait Bounds)].</li>
<li><code>+=</code> (<code>var += expr</code>): arithmetic addition &amp; assignment.</li>
<li><code>,</code>: argument and element separator.  See [Attributes], [Functions], [Structs], [Generics], [Match], [Closures], [Crates and Modules (Importing Modules with <code>use</code>)].</li>
<li><code>-</code> (<code>expr - expr</code>): arithmetic subtraction.  Overloadable (<code>Sub</code>).</li>
<li><code>-</code> (<code>- expr</code>): arithmetic negation.  Overloadable (<code>Neg</code>).</li>
<li><code>-=</code> (<code>var -= expr</code>): arithmetic subtraction &amp; assignment.</li>
<li><code>-&gt;</code> (<code>fn(…) -&gt; type</code>, <code>|…| -&gt; type</code>): function and closure return type.  See [Functions], [Closures].</li>
<li><code>-&gt; !</code> (<code>fn(…) -&gt; !</code>, <code>|…| -&gt; !</code>): diverging function or closure. See [Diverging Functions].</li>
<li><code>.</code> (<code>expr.ident</code>): member access.  See [Structs], [Method Syntax].</li>
<li><code>..</code> (<code>..</code>, <code>expr..</code>, <code>..expr</code>, <code>expr..expr</code>): right-exclusive range literal.</li>
<li><code>..</code> (<code>..expr</code>): struct literal update syntax.  See [Structs (Update syntax)].</li>
<li><code>..</code> (<code>variant(x, ..)</code>, <code>struct_type { x, .. }</code>): &quot;and the rest&quot; pattern binding.  See [Patterns (Ignoring bindings)].</li>
<li><code>...</code> (<code>expr ... expr</code>): inclusive range pattern.  See [Patterns (Ranges)].</li>
<li><code>/</code> (<code>expr / expr</code>): arithmetic division.  Overloadable (<code>Div</code>).</li>
<li><code>/=</code> (<code>var /= expr</code>): arithmetic division &amp; assignment.</li>
<li><code>:</code> (<code>pat: type</code>, <code>ident: type</code>): constraints.  See [Variable Bindings], [Functions], [Structs], [Traits].</li>
<li><code>:</code> (<code>ident: expr</code>): struct field initializer.  See [Structs].</li>
<li><code>:</code> (<code>'a: loop {…}</code>): loop label.  See [Loops (Loops Labels)].</li>
<li><code>;</code>: statement and item terminator.</li>
<li><code>;</code> (<code>[…; len]</code>): part of fixed-size array syntax.  See [Primitive Types (Arrays)].</li>
<li><code>&lt;&lt;</code> (<code>expr &lt;&lt; expr</code>): left-shift.  Overloadable (<code>Shl</code>).</li>
<li><code>&lt;&lt;=</code> (<code>var &lt;&lt;= expr</code>): left-shift &amp; assignment.</li>
<li><code>&lt;</code> (<code>expr &lt; expr</code>): less-than comparison.  Overloadable (<code>PartialOrd</code>).</li>
<li><code>&lt;=</code> (<code>var &lt;= expr</code>): less-than or equal-to comparison.  Overloadable (<code>PartialOrd</code>).</li>
<li><code>=</code> (<code>var = expr</code>, <code>ident = type</code>): assignment/equivalence.  See [Variable Bindings], [<code>type</code> Aliases], generic parameter defaults.</li>
<li><code>==</code> (<code>var == expr</code>): equality comparison.  Overloadable (<code>PartialEq</code>).</li>
<li><code>=&gt;</code> (<code>pat =&gt; expr</code>): part of match arm syntax.  See [Match].</li>
<li><code>&gt;</code> (<code>expr &gt; expr</code>): greater-than comparison.  Overloadable (<code>PartialOrd</code>).</li>
<li><code>&gt;=</code> (<code>var &gt;= expr</code>): greater-than or equal-to comparison.  Overloadable (<code>PartialOrd</code>).</li>
<li><code>&gt;&gt;</code> (<code>expr &gt;&gt; expr</code>): right-shift.  Overloadable (<code>Shr</code>).</li>
<li><code>&gt;&gt;=</code> (<code>var &gt;&gt;= expr</code>): right-shift &amp; assignment.</li>
<li><code>@</code> (<code>ident @ pat</code>): pattern binding.  See [Patterns (Bindings)].</li>
<li><code>^</code> (<code>expr ^ expr</code>): bitwise exclusive or.  Overloadable (<code>BitXor</code>).</li>
<li><code>^=</code> (<code>var ^= expr</code>): bitwise exclusive or &amp; assignment.</li>
<li><code>|</code> (<code>expr | expr</code>): bitwise or.  Overloadable (<code>BitOr</code>).</li>
<li><code>|</code> (<code>pat | pat</code>): pattern alternatives.  See [Patterns (Multiple patterns)].</li>
<li><code>|</code> (<code>|…| expr</code>): closures.  See [Closures].</li>
<li><code>|=</code> (<code>var |= expr</code>): bitwise or &amp; assignment.</li>
<li><code>||</code> (<code>expr || expr</code>): logical or.</li>
<li><code>_</code>: &quot;ignored&quot; pattern binding.  See [Patterns (Ignoring bindings)].</li>
</ul>
<h2>Other Syntax</h2>
<!-- Various bits of standalone stuff. -->
<ul>
<li><code>'ident</code>: named lifetime or loop label.  See [Lifetimes], [Loops (Loops Labels)].</li>
<li><code>…u8</code>, <code>…i32</code>, <code>…f64</code>, <code>…usize</code>, …: numeric literal of specific type.</li>
<li><code>&quot;…&quot;</code>: string literal.  See [Strings].</li>
<li><code>r&quot;…&quot;</code>, <code>r#&quot;…&quot;#</code>, <code>r##&quot;…&quot;##</code>, …: raw string literal, escape characters are not processed. See [Reference (Raw String Literals)].</li>
<li><code>b&quot;…&quot;</code>: byte string literal, constructs a <code>[u8]</code> instead of a string. See [Reference (Byte String Literals)].</li>
<li><code>br&quot;…&quot;</code>, <code>br#&quot;…&quot;#</code>, <code>br##&quot;…&quot;##</code>, …: raw byte string literal, combination of raw and byte string literal. See [Reference (Raw Byte String Literals)].</li>
<li><code>'…'</code>: character literal.  See [Primitive Types (<code>char</code>)].</li>
<li><code>b'…'</code>: ASCII byte literal.</li>
<li><code>|…| expr</code>: closure.  See [Closures].</li>
</ul>
<!-- Path-related syntax -->
<ul>
<li><code>ident::ident</code>: path.  See [Crates and Modules (Defining Modules)].</li>
<li><code>::path</code>: path relative to the crate root (<em>i.e.</em> an explicitly absolute path).  See [Crates and Modules (Re-exporting with <code>pub use</code>)].</li>
<li><code>self::path</code>: path relative to the current module (<em>i.e.</em> an explicitly relative path).  See [Crates and Modules (Re-exporting with <code>pub use</code>)].</li>
<li><code>super::path</code>: path relative to the parent of the current module.  See [Crates and Modules (Re-exporting with <code>pub use</code>)].</li>
<li><code>type::ident</code>, <code>&lt;type as trait&gt;::ident</code>: associated constants, functions, and types.  See [Associated Types].</li>
<li><code>&lt;type&gt;::…</code>: associated item for a type which cannot be directly named (<em>e.g.</em> <code>&lt;&amp;T&gt;::…</code>, <code>&lt;[T]&gt;::…</code>, <em>etc.</em>).  See [Associated Types].</li>
<li><code>trait::method(…)</code>: disambiguating a method call by naming the trait which defines it. See [Universal Function Call Syntax].</li>
<li><code>type::method(…)</code>: disambiguating a method call by naming the type for which it's defined. See [Universal Function Call Syntax].</li>
<li><code>&lt;type as trait&gt;::method(…)</code>: disambiguating a method call by naming the trait <em>and</em> type. See [Universal Function Call Syntax (Angle-bracket Form)].</li>
</ul>
<!-- Generics -->
<ul>
<li><code>path&lt;…&gt;</code> (<em>e.g.</em> <code>Vec&lt;u8&gt;</code>): specifies parameters to generic type <em>in a type</em>.  See [Generics].</li>
<li><code>path::&lt;…&gt;</code>, <code>method::&lt;…&gt;</code> (<em>e.g.</em> <code>&quot;42&quot;.parse::&lt;i32&gt;()</code>): specifies parameters to generic type, function, or method <em>in an expression</em>.</li>
<li><code>fn ident&lt;…&gt; …</code>: define generic function.  See [Generics].</li>
<li><code>struct ident&lt;…&gt; …</code>: define generic structure.  See [Generics].</li>
<li><code>enum ident&lt;…&gt; …</code>: define generic enumeration.  See [Generics].</li>
<li><code>impl&lt;…&gt; …</code>: define generic implementation.</li>
<li><code>for&lt;…&gt; type</code>: higher-ranked lifetime bounds.</li>
<li><code>type&lt;ident=type&gt;</code> (<em>e.g.</em> <code>Iterator&lt;Item=T&gt;</code>): a generic type where one or more associated types have specific assignments.  See [Associated Types].</li>
</ul>
<!-- Constraints -->
<ul>
<li><code>T: U</code>: generic parameter <code>T</code> constrained to types that implement <code>U</code>.  See [Traits].</li>
<li><code>T: 'a</code>: generic type <code>T</code> must outlive lifetime <code>'a</code>. When we say that a type 'outlives' the lifetime, we mean that it cannot transitively contain any references with lifetimes shorter than <code>'a</code>.</li>
<li><code>T : 'static</code>: The generic type <code>T</code> contains no borrowed references other than <code>'static</code> ones.</li>
<li><code>'b: 'a</code>: generic lifetime <code>'b</code> must outlive lifetime <code>'a</code>.</li>
<li><code>T: ?Sized</code>: allow generic type parameter to be a dynamically-sized type.  See [Unsized Types (<code>?Sized</code>)].</li>
<li><code>'a + trait</code>, <code>trait + trait</code>: compound type constraint.  See [Traits (Multiple Trait Bounds)].</li>
</ul>
<!-- Macros and attributes -->
<ul>
<li><code>#[meta]</code>: outer attribute.  See [Attributes].</li>
<li><code>#![meta]</code>: inner attribute.  See [Attributes].</li>
<li><code>$ident</code>: macro substitution.  See [Macros].</li>
<li><code>$ident:kind</code>: macro capture.  See [Macros].</li>
<li><code>$(…)…</code>: macro repetition.  See [Macros].</li>
</ul>
<!-- Comments -->
<ul>
<li><code>//</code>: line comment.  See [Comments].</li>
<li><code>//!</code>: inner line doc comment.  See [Comments].</li>
<li><code>///</code>: outer line doc comment.  See [Comments].</li>
<li><code>/*…*/</code>: block comment.  See [Comments].</li>
<li><code>/*!…*/</code>: inner block doc comment.  See [Comments].</li>
<li><code>/**…*/</code>: outer block doc comment.  See [Comments].</li>
</ul>
<!-- Various things involving parens and tuples -->
<ul>
<li><code>()</code>: empty tuple (<em>a.k.a.</em> unit), both literal and type.</li>
<li><code>(expr)</code>: parenthesized expression.</li>
<li><code>(expr,)</code>: single-element tuple expression.  See [Primitive Types (Tuples)].</li>
<li><code>(type,)</code>: single-element tuple type.  See [Primitive Types (Tuples)].</li>
<li><code>(expr, …)</code>: tuple expression.  See [Primitive Types (Tuples)].</li>
<li><code>(type, …)</code>: tuple type.  See [Primitive Types (Tuples)].</li>
<li><code>expr(expr, …)</code>: function call expression.  Also used to initialize tuple <code>struct</code>s and tuple <code>enum</code> variants.  See [Functions].</li>
<li><code>ident!(…)</code>, <code>ident!{…}</code>, <code>ident![…]</code>: macro invocation.  See [Macros].</li>
<li><code>expr.0</code>, <code>expr.1</code>, …: tuple indexing.  See [Primitive Types (Tuple Indexing)].</li>
</ul>
<!-- Bracey things -->
<ul>
<li><code>{…}</code>: block expression.</li>
<li><code>Type {…}</code>: <code>struct</code> literal.  See [Structs].</li>
</ul>
<!-- Brackety things -->
<ul>
<li><code>[…]</code>: array literal.  See [Primitive Types (Arrays)].</li>
<li><code>[expr; len]</code>: array literal containing <code>len</code> copies of <code>expr</code>.  See [Primitive Types (Arrays)].</li>
<li><code>[type; len]</code>: array type containing <code>len</code> instances of <code>type</code>.  See [Primitive Types (Arrays)].</li>
<li><code>expr[expr]</code>: collection indexing.  Overloadable (<code>Index</code>, <code>IndexMut</code>).</li>
<li><code>expr[..]</code>, <code>expr[a..]</code>, <code>expr[..b]</code>, <code>expr[a..b]</code>: collection indexing pretending to be collection slicing, using <code>Range</code>, <code>RangeFrom</code>, <code>RangeTo</code>, <code>RangeFull</code> as the &quot;index&quot;.</li>
</ul>
<p>[<code>const</code> and <code>static</code>]: const-and-static.html
[<code>if let</code>]: if-let.html
[<code>if</code>]: if.html
[<code>type</code> Aliases]: type-aliases.html
[Associated Types]: associated-types.html
[Attributes]: attributes.html
[Casting Between Types (<code>as</code>)]: casting-between-types.html#as
[Closures (<code>move</code> closures)]: closures.html#move-closures
[Closures]: closures.html
[Comments]: comments.html
[Crates and Modules (Defining Modules)]: crates-and-modules.html#defining-modules
[Crates and Modules (Exporting a Public Interface)]: crates-and-modules.html#exporting-a-public-interface
[Crates and Modules (Importing External Crates)]: crates-and-modules.html#importing-external-crates
[Crates and Modules (Importing Modules with <code>use</code>)]: crates-and-modules.html#importing-modules-with-use
[Crates and Modules (Re-exporting with <code>pub use</code>)]: crates-and-modules.html#re-exporting-with-pub-use
[Diverging Functions]: functions.html#diverging-functions
[Enums]: enums.html
[Foreign Function Interface]: ffi.html
[Functions (Early Returns)]: functions.html#early-returns
[Functions]: functions.html
[Generics]: generics.html
[Lifetimes]: lifetimes.html
[Loops (<code>for</code>)]: loops.html#for
[Loops (<code>loop</code>)]: loops.html#loop
[Loops (<code>while</code>)]: loops.html#while
[Loops (Ending Iteration Early)]: loops.html#ending-iteration-early
[Loops (Loops Labels)]: loops.html#loop-labels
[Macros]: macros.html
[Match]: match.html
[Method Syntax (Method Calls)]: method-syntax.html#method-calls
[Method Syntax]: method-syntax.html
[Mutability]: mutability.html
[Operators and Overloading]: operators-and-overloading.html
[Patterns (<code>ref</code> and <code>ref mut</code>)]: patterns.html#ref-and-ref-mut
[Patterns (Bindings)]: patterns.html#bindings
[Patterns (Ignoring bindings)]: patterns.html#ignoring-bindings
[Patterns (Multiple patterns)]: patterns.html#multiple-patterns
[Patterns (Ranges)]: patterns.html#ranges
[Primitive Types (<code>char</code>)]: primitive-types.html#char
[Primitive Types (Arrays)]: primitive-types.html#arrays
[Primitive Types (Booleans)]: primitive-types.html#booleans
[Primitive Types (Tuple Indexing)]: primitive-types.html#tuple-indexing
[Primitive Types (Tuples)]: primitive-types.html#tuples
[Raw Pointers]: raw-pointers.html
[Reference (Byte String Literals)]: ../reference.html#byte-string-literals
[Reference (Raw Byte String Literals)]: ../reference.html#raw-byte-string-literals
[Reference (Raw String Literals)]: ../reference.html#raw-string-literals
[References and Borrowing]: references-and-borrowing.html
[Strings]: strings.html
[Structs (Update syntax)]: structs.html#update-syntax
[Structs]: structs.html
[Traits (<code>where</code> clause)]: traits.html#where-clause
[Traits (Multiple Trait Bounds)]: traits.html#multiple-trait-bounds
[Traits]: traits.html
[Universal Function Call Syntax]: ufcs.html
[Universal Function Call Syntax (Angle-bracket Form)]: ufcs.html#angle-bracket-form
[Unsafe]: unsafe.html
[Unsized Types (<code>?Sized</code>)]: unsized-types.html#sized
[Variable Bindings]: variable-bindings.html</p>
<blockquote>
<p><em>commit d7c57e1</em></p>
</blockquote>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="glossary.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="bibliography.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="glossary.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="bibliography.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
