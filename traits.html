<!DOCTYPE HTML>
<html lang="zh-Hant">
    <head>
        <meta charset="UTF-8">
        <title>Rust 程式語言 正體中文版</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The Rust Programming Language">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

		<style>
            @import url(http://fonts.googleapis.com/earlyaccess/cwtexhei.css);
        </style>
        <link rel="stylesheet" href="book.css">
        <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body>
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="README.html"><strong>1.</strong> 簡介</a></li><li><a href="getting-started.html"><strong>2.</strong> 準備</a></li><li><a href="guessing-game.html"><strong>3.</strong> 教學: 猜數字遊戲</a></li><li><a href="syntax-and-semantics.html"><strong>4.</strong> 語法及語意</a></li><li><ul class="section"><li><a href="variable-bindings.html"><strong>4.1.</strong> 變數綁定</a></li><li><a href="functions.html"><strong>4.2.</strong> 函式</a></li><li><a href="primitive-types.html"><strong>4.3.</strong> 基本型別</a></li><li><a href="comments.html"><strong>4.4.</strong> 註解</a></li><li><a href="if.html"><strong>4.5.</strong> if</a></li><li><a href="loops.html"><strong>4.6.</strong> 迴圈</a></li><li><a href="ownership.html"><strong>4.7.</strong> 所有權</a></li><li><a href="references-and-borrowing.html"><strong>4.8.</strong> 參照與借用</a></li><li><a href="lifetimes.html"><strong>4.9.</strong> 生命週期</a></li><li><a href="mutability.html"><strong>4.10.</strong> 可變性</a></li><li><a href="structs.html"><strong>4.11.</strong> 結構體</a></li><li><a href="enums.html"><strong>4.12.</strong> 枚舉</a></li><li><a href="match.html"><strong>4.13.</strong> Match</a></li><li><a href="patterns.html"><strong>4.14.</strong> 模式</a></li><li><a href="method-syntax.html"><strong>4.15.</strong> 方法語法</a></li><li><a href="vectors.html"><strong>4.16.</strong> 向量</a></li><li><a href="strings.html"><strong>4.17.</strong> 字串</a></li><li><a href="generics.html"><strong>4.18.</strong> 泛型</a></li><li><a href="traits.html" class="active"><strong>4.19.</strong> Traits</a></li><li><a href="drop.html"><strong>4.20.</strong> Drop</a></li><li><a href="if-let.html"><strong>4.21.</strong> if let</a></li><li><a href="trait-objects.html"><strong>4.22.</strong> Trait Objects</a></li><li><a href="closures.html"><strong>4.23.</strong> Closures</a></li><li><a href="ufcs.html"><strong>4.24.</strong> Universal Function Call Syntax</a></li><li><a href="crates-and-modules.html"><strong>4.25.</strong> Crates and Modules</a></li><li><a href="const-and-static.html"><strong>4.26.</strong> <code>const</code> and <code>static</code></a></li><li><a href="attributes.html"><strong>4.27.</strong> Attributes</a></li><li><a href="type-aliases.html"><strong>4.28.</strong> <code>type</code> aliases</a></li><li><a href="casting-between-types.html"><strong>4.29.</strong> Casting between types</a></li><li><a href="associated-types.html"><strong>4.30.</strong> Associated Types</a></li><li><a href="unsized-types.html"><strong>4.31.</strong> Unsized Types</a></li><li><a href="operators-and-overloading.html"><strong>4.32.</strong> Operators and Overloading</a></li><li><a href="deref-coercions.html"><strong>4.33.</strong> Deref coercions</a></li><li><a href="macros.html"><strong>4.34.</strong> Macros</a></li><li><a href="raw-pointers.html"><strong>4.35.</strong> Raw Pointers</a></li><li><a href="unsafe.html"><strong>4.36.</strong> <code>unsafe</code></a></li></ul></li><li><a href="effective-rust.html"><strong>5.</strong> Effective Rust</a></li><li><ul class="section"><li><a href="the-stack-and-the-heap.html"><strong>5.1.</strong> The Stack and the Heap</a></li><li><a href="testing.html"><strong>5.2.</strong> Testing</a></li><li><a href="conditional-compilation.html"><strong>5.3.</strong> Conditional Compilation</a></li><li><a href="documentation.html"><strong>5.4.</strong> Documentation</a></li><li><a href="iterators.html"><strong>5.5.</strong> Iterators</a></li><li><a href="concurrency.html"><strong>5.6.</strong> Concurrency</a></li><li><a href="error-handling.html"><strong>5.7.</strong> Error Handling</a></li><li><a href="choosing-your-guarantees.html"><strong>5.8.</strong> Choosing your Guarantees</a></li><li><a href="ffi.html"><strong>5.9.</strong> FFI</a></li><li><a href="borrow-and-asref.html"><strong>5.10.</strong> Borrow and AsRef</a></li><li><a href="release-channels.html"><strong>5.11.</strong> Release Channels</a></li><li><a href="using-rust-without-the-standard-library.html"><strong>5.12.</strong> Using Rust without the standard library</a></li></ul></li><li><a href="nightly-rust.html"><strong>6.</strong> Nightly Rust</a></li><li><ul class="section"><li><a href="compiler-plugins.html"><strong>6.1.</strong> Compiler Plugins</a></li><li><a href="inline-assembly.html"><strong>6.2.</strong> Inline Assembly</a></li><li><a href="no-stdlib.html"><strong>6.3.</strong> No stdlib</a></li><li><a href="intrinsics.html"><strong>6.4.</strong> Intrinsics</a></li><li><a href="lang-items.html"><strong>6.5.</strong> Lang items</a></li><li><a href="advanced-linking.html"><strong>6.6.</strong> Advanced linking</a></li><li><a href="benchmark-tests.html"><strong>6.7.</strong> Benchmark Tests</a></li><li><a href="box-syntax-and-patterns.html"><strong>6.8.</strong> Box Syntax and Patterns</a></li><li><a href="slice-patterns.html"><strong>6.9.</strong> Slice Patterns</a></li><li><a href="associated-constants.html"><strong>6.10.</strong> Associated Constants</a></li><li><a href="custom-allocators.html"><strong>6.11.</strong> Custom Allocators</a></li></ul></li><li><a href="glossary.html"><strong>7.</strong> 詞彙表</a></li><li><a href="syntax-index.html"><strong>8.</strong> 語法索引</a></li><li><a href="bibliography.html"><strong>9.</strong> 參考文獻</a></li><li><a href="MappingTable.html"><strong>10.</strong> 中英文字彙對照表</a></li><li><a href="CONTRIBUTORS.html"><strong>11.</strong> 翻譯貢獻名單</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">Rust 程式語言 正體中文版</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <h1>Traits</h1>
<p>trait 為 Rust 語言特徵，告知 Rust compiler 一個型別必須滿足的功能性。</p>
<p>記得提過的 <code>impl</code> 關鍵字，用在使用 <a href="method-syntax.html">method syntax</a>
呼叫函數：</p>
<pre><code class="language-rust">struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    fn area(&amp;self) -&gt; f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}
</code></pre>
<p>Traits 很相似，除了我們首先先定義包含一個函式特徵的 trait ，接著為型別實作該 trait
在本例中，我們為型別 <code>Circle</code> 實作 trait <code>HasArea</code> ：</p>
<pre><code class="language-rust">struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

trait HasArea {
    fn area(&amp;self) -&gt; f64;
}

impl HasArea for Circle {
    fn area(&amp;self) -&gt; f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}
</code></pre>
<p>可以看到，<code>trait</code> 區塊和 <code>impl</code> 區塊看起來十分相似，但只需定義型別特徵，不需要定義方法本體
當我們 <code>impl</code> 一個 trait 時，使用 <code>impl Trait for Item</code> 而非 <code>impl Item</code>。</p>
<h2>泛型函式的 Trait 限制</h2>
<p>Traits 保證一個型別應有的行為，因此非常有用，泛型函式能利用 trait 作為 <a href="glossary.html#bounds">限制</a>（bound）
用以限制他們接受的型別。
下面的函式無法成功編譯：</p>
<pre><code class="language-rust,ignore">fn print_area&lt;T&gt;(shape: T) {
    println!(&quot;This shape has an area of {}&quot;, shape.area());
}
</code></pre>
<p>Rust 會警告：</p>
<pre><code class="language-text">error: no method named `area` found for type `T` in the current scope
</code></pre>
<p>因為型別 <code>T</code> 可以為任何型態，我們無法保證它一定實作了 <code>area</code> 方法，但我們可以對泛型 <code>T</code>
加上 trait 限制，確保它實作該方法：</p>
<pre><code class="language-rust"># trait HasArea {
#     fn area(&amp;self) -&gt; f64;
# }
fn print_area&lt;T: HasArea&gt;(shape: T) {
    println!(&quot;This shape has an area of {}&quot;, shape.area());
}
</code></pre>
<p><code>&lt;T: HasArea&gt;</code> 語法意味：「任何實作了 <code>HasArea</code> trait 的型別」
因為 trait 定義了函式特徵，我們可以確認任何實作了 <code>HasArea</code> trait 的型別
一定有 <code>.area()</code> 方法。</p>
<p>以下是修改後，說明 trait bound 如何運作的例子：</p>
<pre><code class="language-rust">trait HasArea {
    fn area(&amp;self) -&gt; f64;
}

struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl HasArea for Circle {
    fn area(&amp;self) -&gt; f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}

struct Square {
    x: f64,
    y: f64,
    side: f64,
}

impl HasArea for Square {
    fn area(&amp;self) -&gt; f64 {
        self.side * self.side
    }
}

fn print_area&lt;T: HasArea&gt;(shape: T) {
    println!(&quot;This shape has an area of {}&quot;, shape.area());
}

fn main() {
    let c = Circle {
        x: 0.0f64,
        y: 0.0f64,
        radius: 1.0f64,
    };

    let s = Square {
        x: 0.0f64,
        y: 0.0f64,
        side: 1.0f64,
    };

    print_area(c);
    print_area(s);
}
</code></pre>
<p>程式輸出：</p>
<pre><code class="language-text">This shape has an area of 3.141593
This shape has an area of 1
</code></pre>
<p>如你所見， <code>print_area</code> 是泛型同時我確保我們傳入正確的型別
如果我們傳入不正確的型別：</p>
<pre><code class="language-rust,ignore">print_area(5);
</code></pre>
<p>會造成編譯時期錯誤：</p>
<pre><code class="language-text">error: the trait `HasArea` is not implemented for the type `_` [E0277]
</code></pre>
<h2>泛型結構體的 Trait 限制</h2>
<p>泛型結構體同樣能夠利用 trait 限制，需要做的只是在宣告型別參數時添加限制
這裡有個新的型別 <code>Rectangle&lt;T&gt;</code> 和它的操作 <code>is_square()</code>：</p>
<pre><code class="language-rust">struct Rectangle&lt;T&gt; {
    x: T,
    y: T,
    width: T,
    height: T,
}

impl&lt;T: PartialEq&gt; Rectangle&lt;T&gt; {
    fn is_square(&amp;self) -&gt; bool {
        self.width == self.height
    }
}

fn main() {
    let mut r = Rectangle {
        x: 0,
        y: 0,
        width: 47,
        height: 47,
    };

    assert!(r.is_square());

    r.height = 42;
    assert!(!r.is_square());
}
</code></pre>
<p><code>is_square()</code> 需要確認邊是否相等，因此邊的型別一定要實作 trait
[<code>core::cmp::PartialEq</code>]<a href="../core/cmp/trait.PartialEq.html">PartialEq</a>：</p>
<pre><code class="language-ignore">impl&lt;T: PartialEq&gt; Rectangle&lt;T&gt; { ... }
</code></pre>
<p>現在，一個 rectangle 可用任何可以比較是否相等的型別來定義</p>
<p>我們定義一個新的結構體 <code>Rectangle</code>，能夠接受任意精確度的數字-幾乎可算是任意型別-
只要能夠比較是否相等，我們是否能對其他結構體 <code>HasArea</code>、<code>Square</code>、<code>Circle</code>
做相同的事？可以，但他們需要實作乘法，要實作它可以參考 <a href="operators-and-overloading.html">operator traits</a>。</p>
<h1>實作 traits 的規則</h1>
<p>到目前為止，我們只對結構體加上 trait 實作，但我們可以對任何型別實作 trait，
技術上來說，我們「可以」對 <code>i32</code> 實作 <code>HasArea</code>：</p>
<pre><code class="language-rust">trait HasArea {
    fn area(&amp;self) -&gt; f64;
}

impl HasArea for i32 {
    fn area(&amp;self) -&gt; f64 {
        println!(&quot;this is silly&quot;);

        *self as f64
    }
}

5.area();
</code></pre>
<p>儘管可以這麼做，對這類基本型別實作方法並不算是好的風格</p>
<p>這看起來有點像毫無規則的「瘋狂西部大拓荒」，但實際上實作 trait 時有兩條規則</p>
<p>第一：實作的trait 必須在你定義的有效範圍，否則無法實作。
這裡有個例子：標準函式庫提供了　[<code>Write</code>]<a href="../std/io/trait.Write.html">write</a> trait　，對 <code>File</code>s 新增 I/O 用的功能
<code>File</code> 在預設並沒有這些方法：</p>
<pre><code class="language-rust,ignore">let mut f = std::fs::File::open(&quot;foo.txt&quot;).expect(&quot;Couldn’t open foo.txt&quot;);
let buf = b&quot;whatever&quot;; // byte string literal. buf: &amp;[u8; 8]
let result = f.write(buf);
# result.unwrap(); // ignore the error
</code></pre>
<p>以下為編譯錯誤：</p>
<pre><code class="language-text">error: type `std::fs::File` does not implement any method in scope named `write`
let result = f.write(buf);
               ^~~~~~~~~~
</code></pre>
<p>我們需要先 <code>use</code> <code>Write</code> trait：</p>
<pre><code class="language-rust,ignore">use std::io::Write;

let mut f = std::fs::File::open(&quot;foo.txt&quot;).expect(&quot;Couldn’t open foo.txt&quot;);
let buf = b&quot;whatever&quot;;
let result = f.write(buf);
# result.unwrap(); // ignore the error
</code></pre>
<p>即可成功編譯。</p>
<p>這表示即便有人做了對 <code>i32</code> 新增一個方法的蠢事，它也不會影響到你，除非你引入該 trait</p>
<p>另外一個限制為：你實作的trait 和 type，其中一個必須是你定義的，更精確的說
其中一個一定要和寫 <code>impl</code> 同個crate 中定義，關於 Rust 模組和套件系統的資訊，請見
<a href="crates-and-modules.html">crates and modules</a>。</p>
<p>我們可以對 <code>i32</code> 實作 <code>HasArea</code>，因為我們定義自己了 <code>HasArea</code>，但我們無法
對 <code>i32</code> 實作Rust 提供的 <code>ToString</code>，因為無論 trait 或型別都不是我們這個crate 定義的</p>
<p>最後一件關於 traits 的事：包含trait限制的泛型函式使用'單型'（monomorphization：「Mono」為單，「morph」指型態）
因些他們是靜態分派，要知道更多細節請參考 <a href="trait-objects.html">trait objects</a></p>
<h1>多重 trait 限制</h1>
<p>上文已經我們可以使用 trait 限制泛型參數：</p>
<pre><code class="language-rust">fn foo&lt;T: Clone&gt;(x: T) {
    x.clone();
}
</code></pre>
<p>若需要超過一個限制，可以使用 <code>+</code> :</p>
<pre><code class="language-rust">use std::fmt::Debug;

fn foo&lt;T: Clone + Debug&gt;(x: T) {
    x.clone();
    println!(&quot;{:?}&quot;, x);
}
</code></pre>
<p>現在型別 <code>T</code> 需要 <code>Clone</code> 和 <code>Debug</code> traits</p>
<h1>Where 子句</h1>
<p>撰寫少量泛型和 trait 限制的函式不算大問題，但當數量增加時，語法即變得不簡潔：</p>
<pre><code class="language-rust">use std::fmt::Debug;

fn foo&lt;T: Clone, K: Clone + Debug&gt;(x: T, y: K) {
    x.clone();
    y.clone();
    println!(&quot;{:?}&quot;, y);
}
</code></pre>
<p>限制語法卡在中間，分隔了最左的函式名稱與最右的參數列：</p>
<p>Rust 的解法為「<code>where</code> 子句」：</p>
<pre><code class="language-rust">use std::fmt::Debug;

fn foo&lt;T: Clone, K: Clone + Debug&gt;(x: T, y: K) {
    x.clone();
    y.clone();
    println!(&quot;{:?}&quot;, y);
}

fn bar&lt;T, K&gt;(x: T, y: K) where T: Clone, K: Clone + Debug {
    x.clone();
    y.clone();
    println!(&quot;{:?}&quot;, y);
}

fn main() {
    foo(&quot;Hello&quot;, &quot;world&quot;);
    bar(&quot;Hello&quot;, &quot;world&quot;);
}
</code></pre>
<p><code>foo()</code> 用了先前的語法 <code>bar()</code> 則使用 <code>where</code> 子句，
需要做的僅是在參數列後加入 <code>where</code> ，並將限制從型別參數中移出，
對更長的限制列可以上空白：</p>
<pre><code class="language-rust">use std::fmt::Debug;

fn bar&lt;T, K&gt;(x: T, y: K)
    where T: Clone,
          K: Clone + Debug {

    x.clone();
    y.clone();
    println!(&quot;{:?}&quot;, y);
}
</code></pre>
<p>這個彈性能讓複雜的語法更加清楚。</p>
<p><code>where</code> 並不僅是更簡單的語法，例如：</p>
<pre><code class="language-rust">trait ConvertTo&lt;Output&gt; {
    fn convert(&amp;self) -&gt; Output;
}

impl ConvertTo&lt;i64&gt; for i32 {
    fn convert(&amp;self) -&gt; i64 { *self as i64 }
}

// can be called with T == i32
fn normal&lt;T: ConvertTo&lt;i64&gt;&gt;(x: &amp;T) -&gt; i64 {
    x.convert()
}

// can be called with T == i64
fn inverse&lt;T&gt;() -&gt; T
        // this is using ConvertTo as if it were &quot;ConvertTo&lt;i64&gt;&quot;
        where i32: ConvertTo&lt;T&gt; {
    42.convert()
}
</code></pre>
<p>這展示 <code>where</code> 額外的特性，它們除了型別參數 <code>T</code>，亦可限制型別（範例中的 <code>i32</code>)
在範例中，<code>i32</code> 必須實作 <code>ConvertTo&lt;T&gt;</code>，這裡的 <code>where</code> 限制 <code>T</code>而不是定義 <code>i32</code>是什麼
This shows off the additional feature of <code>where</code> clauses: they allow bounds
on the left-hand side not only of type parameters <code>T</code>, but also of types
(<code>i32</code> in this case). In this example, <code>i32</code> must implement
<code>ConvertTo&lt;T&gt;</code>. Rather than defining what <code>i32</code> is (since that's obvious), the
<code>where</code> clause here constrains <code>T</code>.</p>
<h1>預設方法</h1>
<p>如果已知一般的實作是如何，可在 trait 中加入預設方法，例如
<code>is_invalid()</code> 和　<code>is_valid()</code> 是相反的：</p>
<pre><code class="language-rust">trait Foo {
    fn is_valid(&amp;self) -&gt; bool;

    fn is_invalid(&amp;self) -&gt; bool { !self.is_valid() }
}
</code></pre>
<p>因為加上預設方法，實作 <code>Foo</code> 的人必須實作 <code>is_valid()</code> 但不需要實作 <code>is_invalid()</code>
這樣的方法仍可被覆寫：</p>
<pre><code class="language-rust"># trait Foo {
#     fn is_valid(&amp;self) -&gt; bool;
#
#     fn is_invalid(&amp;self) -&gt; bool { !self.is_valid() }
# }
struct UseDefault;

impl Foo for UseDefault {
    fn is_valid(&amp;self) -&gt; bool {
        println!(&quot;Called UseDefault.is_valid.&quot;);
        true
    }
}

struct OverrideDefault;

impl Foo for OverrideDefault {
    fn is_valid(&amp;self) -&gt; bool {
        println!(&quot;Called OverrideDefault.is_valid.&quot;);
        true
    }

    fn is_invalid(&amp;self) -&gt; bool {
        println!(&quot;Called OverrideDefault.is_invalid!&quot;);
        true // overrides the expected value of is_invalid()
    }
}

let default = UseDefault;
assert!(!default.is_invalid()); // prints &quot;Called UseDefault.is_valid.&quot;

let over = OverrideDefault;
assert!(over.is_invalid()); // prints &quot;Called OverrideDefault.is_invalid!&quot;
</code></pre>
<h1>繼承</h1>
<p>有時，實作一個trait 要求實作另一個：</p>
<pre><code class="language-rust">trait Foo {
    fn foo(&amp;self);
}

trait FooBar : Foo {
    fn foobar(&amp;self);
}
</code></pre>
<p>實作 <code>FooBar</code> 必須同時實作 <code>Foo</code> ，像這樣：</p>
<pre><code class="language-rust"># trait Foo {
#     fn foo(&amp;self);
# }
# trait FooBar : Foo {
#     fn foobar(&amp;self);
# }
struct Baz;

impl Foo for Baz {
    fn foo(&amp;self) { println!(&quot;foo&quot;); }
}

impl FooBar for Baz {
    fn foobar(&amp;self) { println!(&quot;foobar&quot;); }
}
</code></pre>
<p>如果我們忘了實作 <code>Foo</code>，Rust 會告訴我們：</p>
<pre><code class="language-text">error: the trait `main::Foo` is not implemented for the type `main::Baz` [E0277]
</code></pre>
<h1>推導</h1>
<p>重複實作例如 <code>Debug</code> 和<code>Default</code> 相當無聊，因此Rust 提供了 <a href="attributes.html">屬性</a>
讓Rust 自動為你實作這些 traits：</p>
<pre><code class="language-rust">#[derive(Debug)]
struct Foo;

fn main() {
    println!(&quot;{:?}&quot;, Foo);
}
</code></pre>
<p>不過，推導只適用在一些 traits 上：</p>
<ul>
<li>[<code>Clone</code>](../core/clone/trait.Clone.html)</li>
<li>[<code>Copy</code>](../core/marker/trait.Copy.html)</li>
<li>[<code>Debug</code>](../core/fmt/trait.Debug.html)</li>
<li>[<code>Default</code>](../core/default/trait.Default.html)</li>
<li>[<code>Eq</code>](../core/cmp/trait.Eq.html)</li>
<li>[<code>Hash</code>](../core/hash/trait.Hash.html)</li>
<li>[<code>Ord</code>](../core/cmp/trait.Ord.html)</li>
<li>[<code>PartialEq</code>](../core/cmp/trait.PartialEq.html)</li>
<li>[<code>PartialOrd</code>](../core/cmp/trait.PartialOrd.html)</li>
</ul>
<blockquote>
<p><em>commit a559577</em></p>
</blockquote>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="generics.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="drop.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="generics.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="drop.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
