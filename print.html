<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Rust 程式語言 正體中文版</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The Rust Programming Language">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body>
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="README.html"><strong>1.</strong> 簡介</a></li><li><a href="getting-started.html"><strong>2.</strong> 準備</a></li><li><a href="guessing-game.html"><strong>3.</strong> 教學: 猜謎遊戲</a></li><li><a href="syntax-and-semantics.html"><strong>4.</strong> 語法及語意</a></li><li><ul class="section"><li><a href="variable-bindings.html"><strong>4.1.</strong> 變數綁定</a></li><li><a href="functions.html"><strong>4.2.</strong> 函式</a></li><li><a href="primitive-types.html"><strong>4.3.</strong> 基本型別</a></li><li><a href="comments.html"><strong>4.4.</strong> 註解</a></li><li><a href="if.html"><strong>4.5.</strong> if</a></li><li><a href="loops.html"><strong>4.6.</strong> 迴圈</a></li><li><a href="ownership.html"><strong>4.7.</strong> 所有權</a></li><li><a href="references-and-borrowing.html"><strong>4.8.</strong> 參照與借用</a></li><li><a href="lifetimes.html"><strong>4.9.</strong> 生命週期</a></li><li><a href="mutability.html"><strong>4.10.</strong> Mutability</a></li><li><a href="structs.html"><strong>4.11.</strong> Structs</a></li><li><a href="enums.html"><strong>4.12.</strong> Enums</a></li><li><a href="match.html"><strong>4.13.</strong> Match</a></li><li><a href="patterns.html"><strong>4.14.</strong> Patterns</a></li><li><a href="method-syntax.html"><strong>4.15.</strong> Method Syntax</a></li><li><a href="vectors.html"><strong>4.16.</strong> Vectors</a></li><li><a href="strings.html"><strong>4.17.</strong> Strings</a></li><li><a href="generics.html"><strong>4.18.</strong> Generics</a></li><li><a href="traits.html"><strong>4.19.</strong> Traits</a></li><li><a href="drop.html"><strong>4.20.</strong> Drop</a></li><li><a href="if-let.html"><strong>4.21.</strong> if let</a></li><li><a href="trait-objects.html"><strong>4.22.</strong> Trait Objects</a></li><li><a href="closures.html"><strong>4.23.</strong> Closures</a></li><li><a href="ufcs.html"><strong>4.24.</strong> Universal Function Call Syntax</a></li><li><a href="crates-and-modules.html"><strong>4.25.</strong> Crates and Modules</a></li><li><a href="const-and-static.html"><strong>4.26.</strong> <code>const</code> and <code>static</code></a></li><li><a href="attributes.html"><strong>4.27.</strong> Attributes</a></li><li><a href="type-aliases.html"><strong>4.28.</strong> <code>type</code> aliases</a></li><li><a href="casting-between-types.html"><strong>4.29.</strong> Casting between types</a></li><li><a href="associated-types.html"><strong>4.30.</strong> Associated Types</a></li><li><a href="unsized-types.html"><strong>4.31.</strong> Unsized Types</a></li><li><a href="operators-and-overloading.html"><strong>4.32.</strong> Operators and Overloading</a></li><li><a href="deref-coercions.html"><strong>4.33.</strong> Deref coercions</a></li><li><a href="macros.html"><strong>4.34.</strong> Macros</a></li><li><a href="raw-pointers.html"><strong>4.35.</strong> Raw Pointers</a></li><li><a href="unsafe.html"><strong>4.36.</strong> <code>unsafe</code></a></li></ul></li><li><a href="effective-rust.html"><strong>5.</strong> Effective Rust</a></li><li><ul class="section"><li><a href="the-stack-and-the-heap.html"><strong>5.1.</strong> The Stack and the Heap</a></li><li><a href="testing.html"><strong>5.2.</strong> Testing</a></li><li><a href="conditional-compilation.html"><strong>5.3.</strong> Conditional Compilation</a></li><li><a href="documentation.html"><strong>5.4.</strong> Documentation</a></li><li><a href="iterators.html"><strong>5.5.</strong> Iterators</a></li><li><a href="concurrency.html"><strong>5.6.</strong> Concurrency</a></li><li><a href="error-handling.html"><strong>5.7.</strong> Error Handling</a></li><li><a href="choosing-your-guarantees.html"><strong>5.8.</strong> Choosing your Guarantees</a></li><li><a href="ffi.html"><strong>5.9.</strong> FFI</a></li><li><a href="borrow-and-asref.html"><strong>5.10.</strong> Borrow and AsRef</a></li><li><a href="release-channels.html"><strong>5.11.</strong> Release Channels</a></li><li><a href="using-rust-without-the-standard-library.html"><strong>5.12.</strong> Using Rust without the standard library</a></li></ul></li><li><a href="nightly-rust.html"><strong>6.</strong> Nightly Rust</a></li><li><ul class="section"><li><a href="compiler-plugins.html"><strong>6.1.</strong> Compiler Plugins</a></li><li><a href="inline-assembly.html"><strong>6.2.</strong> Inline Assembly</a></li><li><a href="no-stdlib.html"><strong>6.3.</strong> No stdlib</a></li><li><a href="intrinsics.html"><strong>6.4.</strong> Intrinsics</a></li><li><a href="lang-items.html"><strong>6.5.</strong> Lang items</a></li><li><a href="advanced-linking.html"><strong>6.6.</strong> Advanced linking</a></li><li><a href="benchmark-tests.html"><strong>6.7.</strong> Benchmark Tests</a></li><li><a href="box-syntax-and-patterns.html"><strong>6.8.</strong> Box Syntax and Patterns</a></li><li><a href="slice-patterns.html"><strong>6.9.</strong> Slice Patterns</a></li><li><a href="associated-constants.html"><strong>6.10.</strong> Associated Constants</a></li><li><a href="custom-allocators.html"><strong>6.11.</strong> Custom Allocators</a></li></ul></li><li><a href="glossary.html"><strong>7.</strong> 詞彙表</a></li><li><a href="syntax-index.html"><strong>8.</strong> 語法索引</a></li><li><a href="bibliography.html"><strong>9.</strong> 參考文獻</a></li><li><a href="MappingTable.html"><strong>10.</strong> 中英文字彙對照表</a></li><li><a href="CONTRIBUTORS.html"><strong>11.</strong> 翻譯貢獻名單</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">Rust 程式語言 正體中文版</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <h1>Rust 程式語言</h1>
<p>歡迎光臨！本書將會讓你學會 <a href="https://www.rust-lang.org">Rust 程式語言</a>。
Rust 是個專注在三項目標的系統程式語言：安全、速度、及並行 (concurrency)。
它無需透過垃圾回收機制去達成以上目標，這使得它成為能在其他語言不擅長的方面大展身手的程式語言：嵌入到其他語言中、在特定空間及時間的限制下撰寫程式、撰寫硬體驅動程式和作業系統之類的底層程式碼。
它透過若干不在執行期產生額外負擔的編譯期安全檢查，去增進現有語言的目標，並去除所有的資料競爭 (data races)。
Rust 同時也旨在實現“無成本抽象化” (zero-cost abstractions) ，雖然，有些抽象化讓他看起來像是高階語言。
即使如此，Rust 仍允許像低階語言一樣進行精確控制。</p>
<p>《Rust 程式語言》被分為數個章節。
本簡介只是個開始。
後續還有：</p>
<ul>
<li><a href="getting-started.html">準備</a> - 替你的電腦設定 Rust 開發環境。</li>
<li><a href="guessing-game.html">教學: 猜謎遊戲</a> - 透過一個小專案學習 Rust。</li>
<li><a href="syntax-and-semantics.html">語法及語意</a> - 將 Rust 細分為各個小部分。</li>
<li><a href="effective-rust.html">Effective Rust</a> - 撰寫優良的 Rust 程式碼的高階概念。</li>
<li><a href="nightly-rust.html">Nightly Rust</a> - 在穩定版中還沒有的最新功能。</li>
<li><a href="glossary.html">詞彙表</a> - 本書中所使用到的術語。</li>
<li><a href="bibliography.html">參考文獻</a> - 關於 Rust 的文獻及論文。</li>
</ul>
<h2>貢獻</h2>
<p>用以產生本書的原始檔可以在 <a href="https://github.com/rust-lang/rust/tree/master/src/doc/book">GitHub</a> 找到。</p>
<blockquote>
<p><em>commit 3a6dbb3</em></p>
</blockquote>
<h1>準備</h1>
<p>本書第一章，將會引領我們使用 Rust 及它的工具。
首先，我們會安裝 Rust。
接著，撰寫經典的 &quot;Hello World&quot; 程式。
最後，我們將談到 Cargo，Rust 的建置系統跟套件管理器。</p>
<h2>安裝 Rust</h2>
<p>使用 Rust 的第一步就是安裝。
一般來說，在本節你需要網路連線去執行指令，因為我們將需要從網路上下載 Rust。</p>
<p>我們將會提供給你許多終端機的指令，而且這些指令每行都會以 <code>$</code> 開頭。
我們並不用輸入這些 <code>$</code> 符號，它們只是用來標示各行指令。
在網路上的教學及範例中常使用以下慣例：以一般使用者身分執行的指令使用 <code>$</code> 標示，而以系統管理員身分執行的指令則使用 <code>#</code> 標示。</p>
<h3>平台支援</h3>
<p>Rust 編譯器能編譯並執行在大多數的平台上，但不是所有的平台都有相同的支援性。
Rust 的支援程度被分為三級。每一級都有不同的保證。</p>
<p>平台將以 &quot;target triple&quot; 的方式標識，這個字串是用來告知編譯器最終該產出怎樣的輸出。
而各列代表對應的元件在特定平台的支援性。</p>
<blockquote>
<p>譯註：<code>target triple</code> 通常會依 <code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code> 的規則表示。
可以參考 Clang 的<a href="http://clang.llvm.org/docs/CrossCompilation.html#target-triple">說明文件</a>。</p>
</blockquote>
<h4>Tier 1 一級</h4>
<p>一級平台可被認為是&quot;被保證可建置且運行&quot;的。
具體來說，它們都滿足以下要求：</p>
<ul>
<li>此平台的已建有自動化測試。</li>
<li>可否把將修改進到 <code>rust-lang/rust</code> repository 的 master 分支的門檻，是通過測試。</li>
<li>此平台提供官方發行版。</li>
<li>已經有如何使用及建置此平台的文件。</li>
</ul>
<table><thead><tr><td>  Target                       </td><td> std </td><td>rustc</td><td>cargo</td><td> notes                      </td></tr></thead>
<tr><td> <code>i686-pc-windows-msvc</code>        </td><td>  ✓  </td><td>  ✓  </td><td>  ✓  </td><td> 32-bit MSVC (Windows 7+)   </td></tr>
<tr><td> <code>x86_64-pc-windows-msvc</code>      </td><td>  ✓  </td><td>  ✓  </td><td>  ✓  </td><td> 64-bit MSVC (Windows 7+)   </td></tr>
<tr><td> <code>i686-pc-windows-gnu</code>         </td><td>  ✓  </td><td>  ✓  </td><td>  ✓  </td><td> 32-bit MinGW (Windows 7+)  </td></tr>
<tr><td> <code>x86_64-pc-windows-gnu</code>       </td><td>  ✓  </td><td>  ✓  </td><td>  ✓  </td><td> 64-bit MinGW (Windows 7+)  </td></tr>
<tr><td> <code>i686-apple-darwin</code>           </td><td>  ✓  </td><td>  ✓  </td><td>  ✓  </td><td> 32-bit OSX (10.7+, Lion+)  </td></tr>
<tr><td> <code>x86_64-apple-darwin</code>         </td><td>  ✓  </td><td>  ✓  </td><td>  ✓  </td><td> 64-bit OSX (10.7+, Lion+)  </td></tr>
<tr><td> <code>i686-unknown-linux-gnu</code>      </td><td>  ✓  </td><td>  ✓  </td><td>  ✓  </td><td> 32-bit Linux (2.6.18+)     </td></tr>
<tr><td> <code>x86_64-unknown-linux-gnu</code>    </td><td>  ✓  </td><td>  ✓  </td><td>  ✓  </td><td> 64-bit Linux (2.6.18+)     </td></tr>
</table>
<h4>Tier 2 二級</h4>
<p>二級平台可被認為是&quot;被保證可以建置&quot;的。
因為沒有執行自動化測試，所以不保證能產生可以運行的 build，但此平台通常運行良好，且永遠歡迎上 patches！
具體來說，這些平台被要求要符合以下各項：</p>
<ul>
<li>建有自動建置，但可能沒有執行測試。</li>
<li>可否把將修改進到 <code>rust-lang/rust</code> repository 的 master 分支的門檻，是能建置成功。
請注意，這代表在某些平台上只需要標準函式庫被編譯成功，但其他平台將要執行整個 bootstrap。</li>
<li>此平台提供官方發行版。</li>
</ul>
<table><thead><tr><td>  Target                       </td><td> std </td><td>rustc</td><td>cargo</td><td> notes                      </td></tr></thead>
<tr><td> <code>x86_64-unknown-linux-musl</code>   </td><td>  ✓  </td><td>     </td><td>     </td><td> 64-bit Linux with MUSL     </td></tr>
<tr><td> <code>arm-linux-androideabi</code>       </td><td>  ✓  </td><td>     </td><td>     </td><td> ARM Android                </td></tr>
<tr><td> <code>arm-unknown-linux-gnueabi</code>   </td><td>  ✓  </td><td>  ✓  </td><td>     </td><td> ARM Linux (2.6.18+)        </td></tr>
<tr><td> <code>arm-unknown-linux-gnueabihf</code> </td><td>  ✓  </td><td>  ✓  </td><td>     </td><td> ARM Linux (2.6.18+)        </td></tr>
<tr><td> <code>aarch64-unknown-linux-gnu</code>   </td><td>  ✓  </td><td>     </td><td>     </td><td> ARM64 Linux (2.6.18+)      </td></tr>
<tr><td> <code>mips-unknown-linux-gnu</code>      </td><td>  ✓  </td><td>     </td><td>     </td><td> MIPS Linux (2.6.18+)       </td></tr>
<tr><td> <code>mipsel-unknown-linux-gnu</code>    </td><td>  ✓  </td><td>     </td><td>     </td><td> MIPS (LE) Linux (2.6.18+)  </td></tr>
</table>
<h4>Tier 3 三級</h4>
<p>三級平台是那些 Rust 支援，但提交修改並不被可否成功建置或通過測試所阻擋的平台。
這些平台可運行的 builds 可能會有小問題，因為它們的可靠度通常由社群貢獻所決定。
此外，不提供發行版及安裝檔，但可能有在非官方的地方提供社群產生的版本。</p>
<table><thead><tr><td>  Target                       </td><td> std </td><td>rustc</td><td>cargo</td><td> notes                      </td></tr></thead>
<tr><td> <code>i686-linux-android</code>          </td><td>  ✓  </td><td>     </td><td>     </td><td> 32-bit x86 Android         </td></tr>
<tr><td> <code>aarch64-linux-android</code>       </td><td>  ✓  </td><td>     </td><td>     </td><td> ARM64 Android              </td></tr>
<tr><td> <code>powerpc-unknown-linux-gnu</code>   </td><td>  ✓  </td><td>     </td><td>     </td><td> PowerPC Linux (2.6.18+)    </td></tr>
<tr><td> <code>powerpc64-unknown-linux-gnu</code> </td><td>  ✓  </td><td>     </td><td>     </td><td> PPC64 Linux (2.6.18+)      </td></tr>
<tr><td><code>powerpc64le-unknown-linux-gnu</code></td><td>  ✓  </td><td>     </td><td>     </td><td> PPC64LE Linux (2.6.18+)    </td></tr>
<tr><td><code>armv7-unknown-linux-gnueabihf</code></td><td>  ✓  </td><td>     </td><td>     </td><td> ARMv7 Linux (2.6.18+)      </td></tr>
<tr><td> <code>i386-apple-ios</code>              </td><td>  ✓  </td><td>     </td><td>     </td><td> 32-bit x86 iOS             </td></tr>
<tr><td> <code>x86_64-apple-ios</code>            </td><td>  ✓  </td><td>     </td><td>     </td><td> 64-bit x86 iOS             </td></tr>
<tr><td> <code>armv7-apple-ios</code>             </td><td>  ✓  </td><td>     </td><td>     </td><td> ARM iOS                    </td></tr>
<tr><td> <code>armv7s-apple-ios</code>            </td><td>  ✓  </td><td>     </td><td>     </td><td> ARM iOS                    </td></tr>
<tr><td> <code>aarch64-apple-ios</code>           </td><td>  ✓  </td><td>     </td><td>     </td><td> ARM64 iOS                  </td></tr>
<tr><td> <code>i686-unknown-freebsd</code>        </td><td>  ✓  </td><td>  ✓  </td><td>     </td><td> 32-bit FreeBSD             </td></tr>
<tr><td> <code>x86_64-unknown-freebsd</code>      </td><td>  ✓  </td><td>  ✓  </td><td>     </td><td> 64-bit FreeBSD             </td></tr>
<tr><td> <code>x86_64-unknown-openbsd</code>      </td><td>  ✓  </td><td>  ✓  </td><td>     </td><td> 64-bit OpenBSD             </td></tr>
<tr><td> <code>x86_64-unknown-netbsd</code>       </td><td>  ✓  </td><td>  ✓  </td><td>     </td><td> 64-bit NetBSD              </td></tr>
<tr><td> <code>x86_64-unknown-bitrig</code>       </td><td>  ✓  </td><td>  ✓  </td><td>     </td><td> 64-bit Bitrig              </td></tr>
<tr><td> <code>x86_64-unknown-dragonfly</code>    </td><td>  ✓  </td><td>  ✓  </td><td>     </td><td> 64-bit DragonFlyBSD        </td></tr>
<tr><td> <code>x86_64-rumprun-netbsd</code>       </td><td>  ✓  </td><td>     </td><td>     </td><td> 64-bit NetBSD Rump Kernel  </td></tr>
<tr><td> <code>x86_64-sun-solaris</code>          </td><td>  ✓  </td><td>  ✓  </td><td>     </td><td> 64-bit Solaris/SunOS       </td></tr>
<tr><td> <code>i686-pc-windows-msvc</code> (XP)   </td><td>  ✓  </td><td>     </td><td>     </td><td> Windows XP support         </td></tr>
<tr><td> <code>x86_64-pc-windows-msvc</code> (XP) </td><td>  ✓  </td><td>     </td><td>     </td><td> Windows XP support         </td></tr>
</table>
<p>請注意，這個表格可能會隨著時間而增長，這永遠不是三級平台最終的列表！</p>
<h3>安裝在 Linux 或 Mac 上</h3>
<p>如果在 Linux 或 Mac 上，我們只需要開啟終端機並輸入：</p>
<pre><code class="language-bash">$ curl -sSf https://static.rust-lang.org/rustup.sh | sh
</code></pre>
<p>這樣就會下載安裝腳本，然後開始安裝。 當全部完成，你將會看到：</p>
<pre><code class="language-text">Welcome to Rust.

This script will download the Rust compiler and its package manager, Cargo, and
install them to /usr/local. You may install elsewhere by running this script
with the --prefix=&lt;path&gt; option.

The installer will run under ‘sudo’ and may ask you for your password. If you do
not want the script to run ‘sudo’ then pass it the --disable-sudo flag.

You may uninstall later by running /usr/local/lib/rustlib/uninstall.sh,
or by running this script again with the --uninstall flag.

Continue? (y/N)
</code></pre>
<p>接著按下 <code>y</code> 表示同意，接著按照提示安裝。</p>
<h3>安裝在 Windows 上</h3>
<p>如果你使用 Windows，請下載合適版本的<a href="https://www.rust-lang.org/install.html">安裝檔</a>。</p>
<h3>移除</h3>
<p>移除 Rust 跟安裝一樣簡單。 在 Linux 或 Mac 上，只需執行移除指令：</p>
<pre><code class="language-bash">$ sudo /usr/local/lib/rustlib/uninstall.sh
</code></pre>
<p>如果你是安裝 Windows 安裝檔，重新執行 <code>.msi</code> 檔，然後他會出現移除的選項。</p>
<h3>故障排除</h3>
<p>當我們裝好 Rust 後，我們可以開啟 shell，然後輸入：</p>
<pre><code class="language-bash">$ rustc --version
</code></pre>
<p>你將會看到版本號碼、commit hash 及 commit 的日期。</p>
<p>如果你成功了，代表 Rust 安裝成功了！恭喜！</p>
<p>如果沒有成功，而你使用 Windows，請確認 Rust 有設定在你的 %PATH% 系統環境變數內。
如果沒有，重新執行安裝檔，在 &quot;Change, repair, or remove installation&quot; 頁面選擇 &quot;Change&quot;，接著確定 &quot;Add to PATH&quot; 有裝到本機硬碟。</p>
<p>Rust 不自己做 linking，所以你會需要安裝一個 linker。
做這件事會依賴於你的特定系統，更多細節請查閱相關文件。</p>
<p>如果仍然沒有成功，有許多地方可以獲得協助。
最簡單的是使用 <a href="http://chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23rust">Mibbit</a> 連上 <a href="irc://irc.mozilla.org/#rust">irc.mozilla.org 的 #rust IRC 頻道</a>。
按下連結，然後就能跟可以幫助我們的 Rustaceans（我們用以自稱的暱稱）聊天。
其他的資源還包括了<a href="https://users.rust-lang.org/">使用者論壇</a>和 <a href="http://stackoverflow.com/questions/tagged/rust">Stack Overflow</a>。</p>
<p>安裝檔同時也安裝了一份文件副本在本機，所以我們可以離線閱讀這份文件。
在 UNIX 系統的位置是 <code>/usr/local/share/doc/rust</code>。
在 Windows，文件放在 Rust 安裝目錄下的 <code>share/doc</code> 目錄。</p>
<h2>Hello, world!</h2>
<p>現在 Rust 已經裝好了，我們將協助你開始寫你的第一個 Rust 程式。
學習一個新的語言的傳統是，撰寫一個小程式，在螢幕上印出 &quot;Hello, world!&quot;。
在本節，我們會遵循這個傳統。</p>
<p>從這樣一個簡單小程式開始的好處，是你能很快地驗證你的編譯器已經安裝完成，而且正常運行。
把資訊印在螢幕上也是個很常做的事情，所以早點練習沒什麼不好。</p>
<blockquote>
<p>註：本書假設你已經有基本的指令熟悉程度。
Rust 對你的編輯器、工具、或程式碼放在何處沒有特別要求，所以如果你喜歡使用 IDE 而非 command line，這也是個選擇。
你也許會想嘗試專為 Rust 建立的 <a href="https://github.com/oakes/SolidOak">SolidOak</a>。
社群也開發了許多擴充功能，而且 Rust 團隊也替<a href="https://github.com/rust-lang/rust/blob/master/src/etc/CONFIGS.md">許多編輯器</a>發佈了外掛。
配置你的編輯器或 IDE 不在本教學的範圍內，所以請依據你的設置查閱文件。</p>
</blockquote>
<h3>建立專案檔</h3>
<p>首先，建立一個檔案來放你的程式碼。
Rust 不在乎你的程式碼放在哪，但在本書中，我建議建立一個 <em>projects</em> 的目錄在你的 home 目錄底下，並且把所有你的專案都放在裡面。
開啟終端機並輸入以下指令來替專案建立目錄：</p>
<pre><code class="language-bash">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</code></pre>
<blockquote>
<p>註：如果你使用 Windows 而且不是使用 PowerShell，則 ~ 可能沒有作用。
更多細節請查閱你使用的 shell 的文件。</p>
</blockquote>
<h3>撰寫並執行 Rust 程式</h3>
<p>接著，建立一個新的原始碼檔案，命名為 <em>main.rs</em>。
Rust 的檔案永遠以 <em>.rs</em> 副檔名為結尾。
如果你的檔案名稱使用超過一個單字，使用底線去區分它們；例如，你應該使用 <em>hello_world.rs</em> 命名，而不是 <em>helloworld.rs</em>。</p>
<p>現在開啟建立好的 <em>main.rs</em> 檔案，然後輸入以下程式碼：</p>
<pre><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre>
<p>存檔，然後回到你的終端機視窗。
在 Linux 或 OSX 下，輸入以下指令：</p>
<pre><code class="language-bash">$ rustc main.rs
$ ./main
Hello, world!
</code></pre>
<p>在 Windows 下，請把 <code>main</code> 換成 <code>main.exe</code>。
不論你的作業系統為何，你應該能看到字串 <code>Hello, world!</code> 印在終端機上。
如果你成功了，那麼恭喜你！
你已正式地寫出了一個 Rust 程式。
這讓你成為了 Rust 程式設計師！歡迎你！</p>
<h3>剖析 Rust 程式</h3>
<p>現在，讓我們來細細檢視你的 &quot;Hello, world!&quot; 程式到底發生了什麼事。
這是第一塊謎團：</p>
<pre><code class="language-rust">fn main() {

}
</code></pre>
<p>這幾行定義了 Rust 中的 <em>函式</em> (function)。
其中 <code>main</code> 函式比較特殊：他是所有 Rust 程式的開始處。
第一行意指 &quot;我要定義一個叫 <code>main</code> 的函式，它沒有參數也沒有回傳值。&quot;
如果函式有參數的話，參數會放在括號（<code>(</code> 及 <code>)</code>）中，且因為我們不回傳值，所以可以省略回傳的型態。</p>
<p>同時留意，函式的內容會被包在大括號（<code>{</code> 及 <code>}</code>）內。
Rust 要求所有函式的內容都要用它包起來。
把第一個大括號放在函式宣告的同一行，在中間留一個空白，被認為是一種好的程式風格。</p>
<p>在 <code>main()</code> 函式中：</p>
<pre><code class="language-rust">    println!(&quot;Hello, world!&quot;);
</code></pre>
<p>這一行做了這個小程式的所有工作：印出文字到螢幕上。
這邊有許多很重要的細節。
第一個是縮排是四個空白，而不是 tabs。</p>
<p>第二個重要的部分是 <code>println!()</code> 這行。
這個在 Rust 叫做 <em><a href="macros.html">巨集</a></em> (macro)，這是 Rust 達成 metaprogramming 的方式。
如果此處改用函式的話，會看起來像是 <code>println()</code>（沒有 ! 符號）。
我們將在之後討論 Rust 巨集的更多細節，但現在你只需知道，當你看到 <code>!</code> 的時候，代表你正在呼叫一個巨集，而不是一般的函式。</p>
<p>接著 <code>&quot;Hello, world!&quot;</code> 是一個 <em>字串</em> (string)。
在系統程式語言中，字串是個複雜到令人驚訝的主題，而這是一個 <em><a href="the-stack-and-the-heap.html">靜態分配</a></em> (statically allocated) 的字串。
我們傳遞這個字串當作參數給 <code>println!</code>，然後它將字串印在螢幕上。
夠簡單吧！</p>
<p>程式中每一行都以分號（<code>;</code>）結尾。
Rust 是個 <em><a href="glossary.html#expression-oriented-language">表達式導向語言</a></em> (expression-oriented language)，這代表大多數的東西都是表達式，而不是陳述式 (statements)。
<code>;</code> 代表著這個表達式已經結束，而且下一個正準備開始。
大多數 Rust 程式碼的行都是以 <code>;</code> 結尾。</p>
<h3>編譯和執行是分開的步驟</h3>
<p>在 &quot;撰寫並執行 Rust 程式&quot; 中，我們告訴你如何執行一個新建的程式。
現在讓我們分解流程，檢查每一步。</p>
<p>執行 Rust 程式之前，你需要編譯它。
你可以使用 Rust 編譯器，輸入 <code>rustc</code> 指令並傳遞原始碼的檔名給它，像這樣</p>
<pre><code class="language-bash">$ rustc main.rs
</code></pre>
<p>如果你有 C 或 C++ 的背景，你會注意到這跟 <code>gcc</code> 或 <code>clang</code> 很類似。
編譯成功之後，Rust 應該會輸出一個二進位執行檔，你可以在 Linux 或 OSX 下的 shell 輸入 <code>ls</code> 指令：</p>
<pre><code class="language-bash">$ ls
main  main.rs
</code></pre>
<p>在 Windows 下，你可以輸入：</p>
<pre><code class="language-bash">$ dir
main.exe  main.rs
</code></pre>
<p>這表示我們有兩個檔案：以 <code>.rs</code> 作為副檔名的原始檔，以及執行檔（在 Windows 是 <code>main.exe</code>，其他則是 <code>main</code>）。
接著我們唯一要做的就只剩下執行 <code>main</code> 或 <code>main.exe</code> 了：</p>
<pre><code class="language-bash">$ ./main  # or main.exe on Windows
</code></pre>
<p>如果 <em>main.rs</em> 就是你的 &quot;Hello, world!&quot; 程式，那它將會印出 <code>Hello, world!</code> 在你的終端機上。</p>
<p>如果你以前是學動態語言，像 Ruby、Python、或 JavaScript，你可能會不習慣把編譯和執行程式分開。
Rust 是個 <em>事先編譯</em> (ahead-of-time compiled) 的語言，你可以編譯程式，把程式給其他人，他們不用安裝 Rust 就能執行程式。
如果你給一個人 <code>.rb</code> 或 <code>.py</code> 或 <code>.js</code> 檔，他必須要裝好 Ruby、Python、或 JavaScript 應用，不過只需一個指令去編譯並執行你的程式。
這都是程式語言的設計中的取捨。</p>
<p>簡單的程式只需要用 <code>rustc</code> 直接編譯就好了，但是隨著你的專案成長，你會希望能夠管理專案的所有選項，並且能簡單的分享你的程式碼給其他人和專案。
下一節，我們將會介紹給你一個叫做 Cargo 的工具，他可以幫你撰寫真實世界的 Rust 程式。</p>
<h2>Hello, Cargo!</h2>
<p>Cargo 是 Rust 的建置系統跟套件管理器，而且 Rustaceans 會使用 Cargo 去管理他們的 Rust 專案。
Cargo 管理三件事：建置你的程式碼、下載你的程式碼所依賴的函式庫 (libraries)、以及建置這些函式庫。
我們把這些你的程式所依賴的函式庫叫做 &quot;dependencies&quot;，因為你的程式碼依賴他們。</p>
<p>最簡單的 Rust 程式不會有任何 dependencies，所以現在你只會用到第一部份的功能。
當你撰寫更複雜的 Rust 程式後，你將會希望加入 dependencies，如果你從 Cargo 開始的話，那就會簡單很多。</p>
<p>許多主要的 Rust 專案都使用 Cargo，我們假設在本書後面的章節你都會使用它。
如果你使用官方安裝檔，Cargo 將會隨著 Rust 一起裝好。
如果你用其他方法安裝 Rust，你可以輸入以下指令檢查是否已經裝好 Cargo：</p>
<pre><code class="language-bash">$ cargo --version
</code></pre>
<p>在終端機內，如果你能看到版本號碼，那就太好了！
如果你看到錯誤訊息像 <code>command not found</code>，則你應該要查閱你所安裝 Rust 的系統的相關文件，確定 Cargo 是否需要另外安裝。</p>
<h3>轉換到 Cargo</h3>
<p>讓我們開始轉換 Hello World 程式到 Cargo。
要將專案 Cargo 化的話，你需要做以下三件事：</p>
<ol>
<li>把你的原始碼檔案放到正確的目錄。</li>
<li>去除舊的執行檔（在 Windows 是 <code>main.exe</code>，其他則是 <code>main</code>）， 並且建立一個新的。</li>
<li>建立 Cargo 配置 (configuration) 檔。</li>
</ol>
<p>讓我們開始吧！</p>
<h4>建立新的執行檔和原始碼目錄</h4>
<p>首先，回到你的終端機，移到你的 <em>hello_world</em> 目錄，輸入以下指令：</p>
<pre><code class="language-bash">$ mkdir src
$ mv main.rs src/main.rs
$ rm main  # or 'del main.exe' on Windows
</code></pre>
<p>Cargo 預期你的原始碼會放在 <em>src</em> 目錄內，所以我們先做這個。
最上層的專案目錄（在此為 <em>hello_world</em>）保留來放置 README 檔、授權資訊、及其他與程式碼無關的東西。
這樣可以讓你保持專案的整潔。
物有所屬，所有東西都有自己的位置。</p>
<p>然後，複製 <em>main.rs</em> 到 <em>src</em> 目錄，然後刪除 <code>rustc</code> 編譯出的檔案。
一如往常地， 在 Windows 下用 <code>main.exe</code> 取代 <code>main</code>。</p>
<p>這個例子中保留 <code>main.rs</code> 作為原始碼檔名，是因為它可以建立執行檔。
如果你想要建立一個函式庫 (library)，你應該把檔案命名為 <code>lib.rs</code>。
Cargo 使用這樣的慣例去編譯你的專案，但是如果你想要的話，你還是可以更改它。</p>
<h4>建立配置檔</h4>
<p>接著，在 <em>hello_world</em> 目錄下建立一個新的檔案，命名為 <code>Cargo.toml</code>。</p>
<p>確保 <code>Cargo.toml</code> 的 <code>C</code> 是大寫，否則 Cargo 會無法處理這樣的配置檔。</p>
<p>這個檔案使用 <em><a href="https://github.com/toml-lang/toml">TOML</a></em> (Tom's Obvious, Minimal Language) 格式。
TOML 跟 INI 很類似，但是有些額外的好東西，而且被用來作為 Cargo 的配置格式。</p>
<p>在檔案內，輸入以下資訊：</p>
<pre><code class="language-toml">[package]

name = &quot;hello_world&quot;
version = &quot;0.0.1&quot;
authors = [ &quot;Your name &lt;you@example.com&gt;&quot; ]
</code></pre>
<p>第一行，<code>[package]</code> 表示以下的陳述是用來配置一個套件 (package)。
當我們要加入更多資訊到這個檔案內，我們會增加其他的小節 (sections)，但是現在，我們只有套件的配置。</p>
<p>其他三行設定了三項 Cargo 編譯程式所需要知道的配置：程式的名字、它的版本、和誰是作者。</p>
<p>在 <em>Cargo.toml</em> 檔案內加入這些資訊後，存檔然後結束。</p>
<h3>建立並執行 Cargo 專案</h3>
<p>當你的 <em>Cargo.toml</em> 檔案被放在專案的根目錄後，你應該就可以建立並執行你的 Hello World 程式了！
輸入以下指令：</p>
<pre><code class="language-bash">$ cargo build
   Compiling hello_world v0.0.1 (file:///home/yourname/projects/hello_world)
$ ./target/debug/hello_world
Hello, world!
</code></pre>
<p>蹦！如果一切順利，<code>Hello, world!</code> 應該再次印在終端機上了。</p>
<p>你可以用 <code>cargo build</code> 建置專案、並透過 <code>./target/debug/hello_world</code> 執行它，但你其實可以直接用 <code>cargo run</code> 一步執行兩者：</p>
<pre><code class="language-bash">$ cargo run
     Running `target/debug/hello_world`
Hello, world!
</code></pre>
<p>請注意，這個範例沒有重新建置專案。
Cargo 判斷檔案沒有更動，所以他直接執行二進位執行檔。
如果你有修改你的原始碼，Cargo 會在執行前重新建置專案，然後你會看到：</p>
<pre><code class="language-bash">$ cargo run
   Compiling hello_world v0.0.1 (file:///home/yourname/projects/hello_world)
     Running `target/debug/hello_world`
Hello, world!
</code></pre>
<p>Cargo 會檢查是否專案內的檔案有被更改，而且只會在專案有更動的時候重新建置。</p>
<p>在簡單的專案中，Cargo 無法比 <code>rustc</code> 帶來更多好處，但是它在未來會越來越有用。
在用到許多 crates 的複雜專案中，使用 Cargo 去協調建置會比較簡單。
你只需要執行 <code>cargo build</code>，然後一切都會正確的運行。</p>
<h4>建立發行版</h4>
<p>當你的專案最終準備好要發行，你應該使用 <code>cargo build --release</code> 來最佳化編譯你的專案。
這些最佳化讓你的 Rust 程式碼執行得更快，但是你的程式編譯起來會需要多花點時間。
這也是為什麼會有兩種不同的 profiles，一個用於開發，一個用於建置最終給使用者的程式。</p>
<h4>什麼是 <code>Cargo.lock</code>？</h4>
<p>執行 <code>cargo build</code> 也會讓 Cargo 建立一個叫做 <em>Cargo.lock</em> 的檔案，看起來像這樣：</p>
<pre><code class="language-toml">[root]
name = &quot;hello_world&quot;
version = &quot;0.0.1&quot;
</code></pre>
<p>Cargo 使用 <em>Cargo.lock</em> 去追蹤你的應用程式的 dependencies。 這是 Hello World 專案的 <em>Cargo.lock</em> 檔。
這個專案沒有任何 dependencies，所以檔案有點稀疏。
實際上，你不需要自己去碰這個檔案；只要讓 Cargo 去處理就好了。</p>
<p>就這樣！如果你一路照著做到現在，你應該已經成功的以 Cargo 建置 <code>hello_world</code> 了。</p>
<p>即使這個專案很簡單，它也使用到許多之後在你 Rust 生涯中會真實用上的工具。
事實上，你可以預期，幾乎所有的 Rust 專案都會透過類似以下的指令開始：</p>
<pre><code class="language-bash">$ git clone someurl.com/foo
$ cd foo
$ cargo build
</code></pre>
<h3>簡單地開始一個 Cargo 專案</h3>
<p>當你想要開始一個新專案的時候，你不需要每次都重新執行一遍前面的流程！
Cargo 可以快速的建立專案目錄的骨架，然後你就可以開始開發。</p>
<p>用 Cargo 開始一個新專案，只要輸入 <code>cargo new</code>：</p>
<pre><code class="language-bash">$ cargo new hello_world --bin
</code></pre>
<p>這個指令傳遞了 <code>--bin</code> 因為他的目的是直接建立一個可執行的應用程式，而不是函式庫。
執行檔也常被稱作 <em>二進位檔</em> (binaries)。</p>
<p>Cargo 產生兩個檔案和一個目錄給我們：<code>Cargo.toml</code> 和內含 <em>main.rs</em> 的 <em>src</em> 目錄。
他們看起來與我們前面手動建立的很像。</p>
<p>這些就是我們全部所需要開始的東西。
首先，打開 <code>Cargo.toml</code>。
它應該看起來像這樣：</p>
<pre><code class="language-toml">[package]

name = &quot;hello_world&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
</code></pre>
<p>Cargo 會根據你給它的參數和你的 <code>git</code> 環境配置產生有合理預設值的 <em>Cargo.toml</em>。
而且你可以注意到 Cargo 同時也把 <code>hello_world</code> 目錄初始化成 <code>git</code> 的 repository。</p>
<p>至於 <code>src/main.rs</code> 內應該會像這樣：</p>
<pre><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre>
<p>Cargo 會幫你產生 &quot;Hello World!&quot;，然後你就可以開始寫程式了！</p>
<blockquote>
<p>註：如果你想要閱覽更多 Cargo 的細節，可以查閱官方的 <a href="http://doc.crates.io/guide.html">Cargo 指南</a>，其中包含有所有的功能。</p>
</blockquote>
<h2>結語</h2>
<p>本章包含了本書後述部分、及未來你的 Rust 時光的基礎。
現在你已經有了工具，我們接著將更多地論及 Rust 本身。</p>
<p>你有兩個選擇：從 &quot;<a href="guessing-game.html">教學: 猜謎遊戲</a>&quot; 深入一個專案，或從 &quot;<a href="syntax-and-semantics.html">語法及語意</a>&quot; 由下而上開始。
有經驗的系統程式設計師可能會傾向從 &quot;教學: 猜謎遊戲&quot; 開始，而動態語言背景的人也許兩者都可以。
不同人有不同的學習方式！
選擇適合自己的方式。</p>
<blockquote>
<p><em>commit c3f6122</em></p>
</blockquote>
<p>% Guessing Game</p>
<p>Let’s learn some Rust! For our first project, we’ll implement a classic
beginner programming problem: the guessing game. Here’s how it works: Our
program will generate a random integer between one and a hundred. It will then
prompt us to enter a guess. Upon entering our guess, it will tell us if we’re
too low or too high. Once we guess correctly, it will congratulate us. Sounds
good?</p>
<p>Along the way, we’ll learn a little bit about Rust. The next chapter, ‘Syntax
and Semantics’, will dive deeper into each part.</p>
<h1>Set up</h1>
<p>Let’s set up a new project. Go to your projects directory. Remember how we had
to create our directory structure and a <code>Cargo.toml</code> for <code>hello_world</code>? Cargo
has a command that does that for us. Let’s give it a shot:</p>
<pre><code class="language-bash">$ cd ~/projects
$ cargo new guessing_game --bin
$ cd guessing_game
</code></pre>
<p>We pass the name of our project to <code>cargo new</code>, and then the <code>--bin</code> flag,
since we’re making a binary, rather than a library.</p>
<p>Check out the generated <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]

name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
</code></pre>
<p>Cargo gets this information from your environment. If it’s not correct, go ahead
and fix that.</p>
<p>Finally, Cargo generated a ‘Hello, world!’ for us. Check out <code>src/main.rs</code>:</p>
<pre><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre>
<p>Let’s try compiling what Cargo gave us:</p>
<pre><code class="language-{bash}">$ cargo build
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
</code></pre>
<p>Excellent! Open up your <code>src/main.rs</code> again. We’ll be writing all of
our code in this file.</p>
<p>Before we move on, let me show you one more Cargo command: <code>run</code>. <code>cargo run</code>
is kind of like <code>cargo build</code>, but it also then runs the produced executable.
Try it out:</p>
<pre><code class="language-bash">$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/debug/guessing_game`
Hello, world!
</code></pre>
<p>Great! The <code>run</code> command comes in handy when you need to rapidly iterate on a
project. Our game is such a project, we need to quickly test each
iteration before moving on to the next one.</p>
<h1>Processing a Guess</h1>
<p>Let’s get to it! The first thing we need to do for our guessing game is
allow our player to input a guess. Put this in your <code>src/main.rs</code>:</p>
<pre><code class="language-rust,no_run">use std::io;

fn main() {
    println!(&quot;Guess the number!&quot;);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    println!(&quot;You guessed: {}&quot;, guess);
}
</code></pre>
<p>There’s a lot here! Let’s go over it, bit by bit.</p>
<pre><code class="language-rust,ignore">use std::io;
</code></pre>
<p>We’ll need to take user input, and then print the result as output. As such, we
need the <code>io</code> library from the standard library. Rust only imports a few things
by default into every program, <a href="../std/prelude/index.html">the ‘prelude’</a>. If it’s not in the
prelude, you’ll have to <code>use</code> it directly. There is also a second ‘prelude’, the
<a href="../std/io/prelude/index.html"><code>io</code> prelude</a>, which serves a similar function: you import it, and it
imports a number of useful, <code>io</code>-related things.</p>
<pre><code class="language-rust,ignore">fn main() {
</code></pre>
<p>As you’ve seen before, the <code>main()</code> function is the entry point into your
program. The <code>fn</code> syntax declares a new function, the <code>()</code>s indicate that
there are no arguments, and <code>{</code> starts the body of the function. Because
we didn’t include a return type, it’s assumed to be <code>()</code>, an empty
<a href="primitive-types.html#tuples">tuple</a>.</p>
<pre><code class="language-rust,ignore">    println!(&quot;Guess the number!&quot;);

    println!(&quot;Please input your guess.&quot;);
</code></pre>
<p>We previously learned that <code>println!()</code> is a <a href="macros.html">macro</a> that
prints a <a href="strings.html">string</a> to the screen.</p>
<pre><code class="language-rust,ignore">    let mut guess = String::new();
</code></pre>
<p>Now we’re getting interesting! There’s a lot going on in this little line.
The first thing to notice is that this is a <a href="variable-bindings.html">let statement</a>, which is
used to create ‘variable bindings’. They take this form:</p>
<pre><code class="language-rust,ignore">let foo = bar;
</code></pre>
<p>This will create a new binding named <code>foo</code>, and bind it to the value <code>bar</code>. In
many languages, this is called a ‘variable’, but Rust’s variable bindings have
a few tricks up their sleeves.</p>
<p>For example, they’re <a href="mutability.html">immutable</a> by default. That’s why our example
uses <code>mut</code>: it makes a binding mutable, rather than immutable. <code>let</code> doesn’t
take a name on the left hand side of the assignment, it actually accepts a
‘<a href="patterns.html">pattern</a>’. We’ll use patterns later. It’s easy enough
to use for now:</p>
<pre><code class="language-rust">let foo = 5; // immutable.
let mut bar = 5; // mutable
</code></pre>
<p>Oh, and <code>//</code> will start a comment, until the end of the line. Rust ignores
everything in <a href="comments.html">comments</a>.</p>
<p>So now we know that <code>let mut guess</code> will introduce a mutable binding named
<code>guess</code>, but we have to look at the other side of the <code>=</code> for what it’s
bound to: <code>String::new()</code>.</p>
<p><code>String</code> is a string type, provided by the standard library. A
[<code>String</code>]<a href="../std/string/struct.String.html">string</a> is a growable, UTF-8 encoded bit of text.</p>
<p>The <code>::new()</code> syntax uses <code>::</code> because this is an ‘associated function’ of
a particular type. That is to say, it’s associated with <code>String</code> itself,
rather than a particular instance of a <code>String</code>. Some languages call this a
‘static method’.</p>
<p>This function is named <code>new()</code>, because it creates a new, empty <code>String</code>.
You’ll find a <code>new()</code> function on many types, as it’s a common name for making
a new value of some kind.</p>
<p>Let’s move forward:</p>
<pre><code class="language-rust,ignore">    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);
</code></pre>
<p>That’s a lot more! Let’s go bit-by-bit. The first line has two parts. Here’s
the first:</p>
<pre><code class="language-rust,ignore">io::stdin()
</code></pre>
<p>Remember how we <code>use</code>d <code>std::io</code> on the first line of the program? We’re now
calling an associated function on it. If we didn’t <code>use std::io</code>, we could
have written this line as <code>std::io::stdin()</code>.</p>
<p>This particular function returns a handle to the standard input for your
terminal. More specifically, a <a href="../std/io/struct.Stdin.html">std::io::Stdin</a>.</p>
<p>The next part will use this handle to get input from the user:</p>
<pre><code class="language-rust,ignore">.read_line(&amp;mut guess)
</code></pre>
<p>Here, we call the [<code>read_line()</code>]<a href="../std/io/struct.Stdin.html#method.read_line">read_line</a> method on our handle.
<a href="method-syntax.html">Methods</a> are like associated functions, but are only available on a
particular instance of a type, rather than the type itself. We’re also passing
one argument to <code>read_line()</code>: <code>&amp;mut guess</code>.</p>
<p>Remember how we bound <code>guess</code> above? We said it was mutable. However,
<code>read_line</code> doesn’t take a <code>String</code> as an argument: it takes a <code>&amp;mut String</code>.
Rust has a feature called ‘<a href="references-and-borrowing.html">references</a>’, which allows you to have
multiple references to one piece of data, which can reduce copying. References
are a complex feature, as one of Rust’s major selling points is how safe and
easy it is to use references. We don’t need to know a lot of those details to
finish our program right now, though. For now, all we need to know is that
like <code>let</code> bindings, references are immutable by default. Hence, we need to
write <code>&amp;mut guess</code>, rather than <code>&amp;guess</code>.</p>
<p>Why does <code>read_line()</code> take a mutable reference to a string? Its job is
to take what the user types into standard input, and place that into a
string. So it takes that string as an argument, and in order to add
the input, it needs to be mutable.</p>
<p>But we’re not quite done with this line of code, though. While it’s
a single line of text, it’s only the first part of the single logical line of
code:</p>
<pre><code class="language-rust,ignore">        .expect(&quot;Failed to read line&quot;);
</code></pre>
<p>When you call a method with the <code>.foo()</code> syntax, you may introduce a newline
and other whitespace. This helps you split up long lines. We <em>could</em> have
done:</p>
<pre><code class="language-rust,ignore">    io::stdin().read_line(&amp;mut guess).expect(&quot;failed to read line&quot;);
</code></pre>
<p>But that gets hard to read. So we’ve split it up, two lines for two method
calls. We already talked about <code>read_line()</code>, but what about <code>expect()</code>? Well,
we already mentioned that <code>read_line()</code> puts what the user types into the <code>&amp;mut String</code> we pass it. But it also returns a value: in this case, an
[<code>io::Result</code>]<a href="../std/io/type.Result.html">ioresult</a>. Rust has a number of types named <code>Result</code> in its
standard library: a generic [<code>Result</code>]<a href="../std/result/enum.Result.html">result</a>, and then specific versions for
sub-libraries, like <code>io::Result</code>.</p>
<p>The purpose of these <code>Result</code> types is to encode error handling information.
Values of the <code>Result</code> type, like any type, have methods defined on them. In
this case, <code>io::Result</code> has an <a href="../std/result/enum.Result.html#method.expect"><code>expect()</code> method</a> that takes a value
it’s called on, and if it isn’t a successful one, [<code>panic!</code>]<a href="error-handling.html">panic</a>s with a
message you passed it. A <code>panic!</code> like this will cause our program to crash,
displaying the message.</p>
<p>If we leave off calling this method, our program will compile, but
we’ll get a warning:</p>
<pre><code class="language-bash">$ cargo build
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
src/main.rs:10:5: 10:39 warning: unused result which must be used,
#[warn(unused_must_use)] on by default
src/main.rs:10     io::stdin().read_line(&amp;mut guess);
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</code></pre>
<p>Rust warns us that we haven’t used the <code>Result</code> value. This warning comes from
a special annotation that <code>io::Result</code> has. Rust is trying to tell you that
you haven’t handled a possible error. The right way to suppress the error is
to actually write error handling. Luckily, if we want to crash if there’s
a problem, we can use these two little methods. If we can recover from the
error somehow, we’d do something else, but we’ll save that for a future
project.</p>
<p>There’s only one line of this first example left:</p>
<pre><code class="language-rust,ignore">    println!(&quot;You guessed: {}&quot;, guess);
}
</code></pre>
<p>This prints out the string we saved our input in. The <code>{}</code>s are a placeholder,
and so we pass it <code>guess</code> as an argument. If we had multiple <code>{}</code>s, we would
pass multiple arguments:</p>
<pre><code class="language-rust">let x = 5;
let y = 10;

println!(&quot;x and y: {} and {}&quot;, x, y);
</code></pre>
<p>Easy.</p>
<p>Anyway, that’s the tour. We can run what we have with <code>cargo run</code>:</p>
<pre><code class="language-bash">$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
</code></pre>
<p>All right! Our first part is done: we can get input from the keyboard,
and then print it back out.</p>
<h1>Generating a secret number</h1>
<p>Next, we need to generate a secret number. Rust does not yet include random
number functionality in its standard library. The Rust team does, however,
provide a <a href="https://crates.io/crates/rand"><code>rand</code> crate</a>. A ‘crate’ is a package of Rust code.
We’ve been building a ‘binary crate’, which is an executable. <code>rand</code> is a
‘library crate’, which contains code that’s intended to be used with other
programs.</p>
<p>Using external crates is where Cargo really shines. Before we can write
the code using <code>rand</code>, we need to modify our <code>Cargo.toml</code>. Open it up, and
add these few lines at the bottom:</p>
<pre><code class="language-toml">[dependencies]

rand=&quot;0.3.0&quot;
</code></pre>
<p>The <code>[dependencies]</code> section of <code>Cargo.toml</code> is like the <code>[package]</code> section:
everything that follows it is part of it, until the next section starts.
Cargo uses the dependencies section to know what dependencies on external
crates you have, and what versions you require. In this case, we’ve specified version <code>0.3.0</code>,
which Cargo understands to be any release that’s compatible with this specific version.
Cargo understands <a href="http://semver.org">Semantic Versioning</a>, which is a standard for writing version
numbers. A bare number like above is actually shorthand for <code>^0.3.0</code>,
meaning &quot;anything compatible with 0.3.0&quot;.
If we wanted to use only <code>0.3.0</code> exactly, we could say <code>rand=&quot;=0.3.0&quot;</code>
(note the two equal signs).
And if we wanted to use the latest version we could use <code>*</code>.
We could also use a range of versions.
<a href="http://doc.crates.io/crates-io.html">Cargo’s documentation</a> contains more details.</p>
<p>Now, without changing any of our code, let’s build our project:</p>
<pre><code class="language-bash">$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading rand v0.3.8
 Downloading libc v0.1.6
   Compiling libc v0.1.6
   Compiling rand v0.3.8
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
</code></pre>
<p>(You may see different versions, of course.)</p>
<p>Lots of new output! Now that we have an external dependency, Cargo fetches the
latest versions of everything from the registry, which is a copy of data from
<a href="https://crates.io">Crates.io</a>. Crates.io is where people in the Rust ecosystem
post their open source Rust projects for others to use.</p>
<p>After updating the registry, Cargo checks our <code>[dependencies]</code> and downloads
any we don’t have yet. In this case, while we only said we wanted to depend on
<code>rand</code>, we’ve also grabbed a copy of <code>libc</code>. This is because <code>rand</code> depends on
<code>libc</code> to work. After downloading them, it compiles them, and then compiles
our project.</p>
<p>If we run <code>cargo build</code> again, we’ll get different output:</p>
<pre><code class="language-bash">$ cargo build
</code></pre>
<p>That’s right, no output! Cargo knows that our project has been built, and that
all of its dependencies are built, and so there’s no reason to do all that
stuff. With nothing to do, it simply exits. If we open up <code>src/main.rs</code> again,
make a trivial change, and then save it again, we’ll only see one line:</p>
<pre><code class="language-bash">$ cargo build
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
</code></pre>
<p>So, we told Cargo we wanted any <code>0.3.x</code> version of <code>rand</code>, and so it fetched the latest
version at the time this was written, <code>v0.3.8</code>. But what happens when next
week, version <code>v0.3.9</code> comes out, with an important bugfix? While getting
bugfixes is important, what if <code>0.3.9</code> contains a regression that breaks our
code?</p>
<p>The answer to this problem is the <code>Cargo.lock</code> file you’ll now find in your
project directory. When you build your project for the first time, Cargo
figures out all of the versions that fit your criteria, and then writes them
to the <code>Cargo.lock</code> file. When you build your project in the future, Cargo
will see that the <code>Cargo.lock</code> file exists, and then use that specific version
rather than do all the work of figuring out versions again. This lets you
have a repeatable build automatically. In other words, we’ll stay at <code>0.3.8</code>
until we explicitly upgrade, and so will anyone who we share our code with,
thanks to the lock file.</p>
<p>What about when we <em>do</em> want to use <code>v0.3.9</code>? Cargo has another command,
<code>update</code>, which says ‘ignore the lock, figure out all the latest versions that
fit what we’ve specified. If that works, write those versions out to the lock
file’. But, by default, Cargo will only look for versions larger than <code>0.3.0</code>
and smaller than <code>0.4.0</code>. If we want to move to <code>0.4.x</code>, we’d have to update
the <code>Cargo.toml</code> directly. When we do, the next time we <code>cargo build</code>, Cargo
will update the index and re-evaluate our <code>rand</code> requirements.</p>
<p>There’s a lot more to say about <a href="http://doc.crates.io">Cargo</a> and <a href="http://doc.crates.io/crates-io.html">its
ecosystem</a>, but for now, that’s all we need to know. Cargo makes
it really easy to re-use libraries, and so Rustaceans tend to write smaller
projects which are assembled out of a number of sub-packages.</p>
<p>Let’s get on to actually <em>using</em> <code>rand</code>. Here’s our next step:</p>
<pre><code class="language-rust,ignore">extern crate rand;

use std::io;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;The secret number is: {}&quot;, secret_number);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;failed to read line&quot;);

    println!(&quot;You guessed: {}&quot;, guess);
}
</code></pre>
<p>The first thing we’ve done is change the first line. It now says
<code>extern crate rand</code>. Because we declared <code>rand</code> in our <code>[dependencies]</code>, we
can use <code>extern crate</code> to let Rust know we’ll be making use of it. This also
does the equivalent of a <code>use rand;</code> as well, so we can make use of anything
in the <code>rand</code> crate by prefixing it with <code>rand::</code>.</p>
<p>Next, we added another <code>use</code> line: <code>use rand::Rng</code>. We’re going to use a
method in a moment, and it requires that <code>Rng</code> be in scope to work. The basic
idea is this: methods are defined on something called ‘traits’, and for the
method to work, it needs the trait to be in scope. For more about the
details, read the <a href="traits.html">traits</a> section.</p>
<p>There are two other lines we added, in the middle:</p>
<pre><code class="language-rust,ignore">    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;The secret number is: {}&quot;, secret_number);
</code></pre>
<p>We use the <code>rand::thread_rng()</code> function to get a copy of the random number
generator, which is local to the particular <a href="concurrency.html">thread</a> of execution
we’re in. Because we <code>use rand::Rng</code>’d above, it has a <code>gen_range()</code> method
available. This method takes two arguments, and generates a number between
them. It’s inclusive on the lower bound, but exclusive on the upper bound,
so we need <code>1</code> and <code>101</code> to get a number ranging from one to a hundred.</p>
<p>The second line prints out the secret number. This is useful while
we’re developing our program, so we can easily test it out. But we’ll be
deleting it for the final version. It’s not much of a game if it prints out
the answer when you start it up!</p>
<p>Try running our new program a few times:</p>
<pre><code class="language-bash">$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4
$ cargo run
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
</code></pre>
<p>Great! Next up: comparing our guess to the secret number.</p>
<h1>Comparing guesses</h1>
<p>Now that we’ve got user input, let’s compare our guess to the secret number.
Here’s our next step, though it doesn’t quite compile yet:</p>
<pre><code class="language-rust,ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;The secret number is: {}&quot;, secret_number);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;failed to read line&quot;);

    println!(&quot;You guessed: {}&quot;, guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less    =&gt; println!(&quot;Too small!&quot;),
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
        Ordering::Equal   =&gt; println!(&quot;You win!&quot;),
    }
}
</code></pre>
<p>A few new bits here. The first is another <code>use</code>. We bring a type called
<code>std::cmp::Ordering</code> into scope. Then, five new lines at the bottom that use
it:</p>
<pre><code class="language-rust,ignore">match guess.cmp(&amp;secret_number) {
    Ordering::Less    =&gt; println!(&quot;Too small!&quot;),
    Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
    Ordering::Equal   =&gt; println!(&quot;You win!&quot;),
}
</code></pre>
<p>The <code>cmp()</code> method can be called on anything that can be compared, and it
takes a reference to the thing you want to compare it to. It returns the
<code>Ordering</code> type we <code>use</code>d earlier. We use a [<code>match</code>]<a href="match.html">match</a> statement to
determine exactly what kind of <code>Ordering</code> it is. <code>Ordering</code> is an
[<code>enum</code>]<a href="enums.html">enum</a>, short for ‘enumeration’, which looks like this:</p>
<pre><code class="language-rust">enum Foo {
    Bar,
    Baz,
}
</code></pre>
<p>With this definition, anything of type <code>Foo</code> can be either a
<code>Foo::Bar</code> or a <code>Foo::Baz</code>. We use the <code>::</code> to indicate the
namespace for a particular <code>enum</code> variant.</p>
<p>The [<code>Ordering</code>]<a href="../std/cmp/enum.Ordering.html">ordering</a> <code>enum</code> has three possible variants: <code>Less</code>, <code>Equal</code>,
and <code>Greater</code>. The <code>match</code> statement takes a value of a type, and lets you
create an ‘arm’ for each possible value. Since we have three types of
<code>Ordering</code>, we have three arms:</p>
<pre><code class="language-rust,ignore">match guess.cmp(&amp;secret_number) {
    Ordering::Less    =&gt; println!(&quot;Too small!&quot;),
    Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
    Ordering::Equal   =&gt; println!(&quot;You win!&quot;),
}
</code></pre>
<p>If it’s <code>Less</code>, we print <code>Too small!</code>, if it’s <code>Greater</code>, <code>Too big!</code>, and if
<code>Equal</code>, <code>You win!</code>. <code>match</code> is really useful, and is used often in Rust.</p>
<p>I did mention that this won’t quite compile yet, though. Let’s try it:</p>
<pre><code class="language-bash">$ cargo build
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
src/main.rs:28:21: 28:35 error: mismatched types:
 expected `&amp;collections::string::String`,
    found `&amp;_`
(expected struct `collections::string::String`,
    found integral variable) [E0308]
src/main.rs:28     match guess.cmp(&amp;secret_number) {
                                   ^~~~~~~~~~~~~~
error: aborting due to previous error
Could not compile `guessing_game`.
</code></pre>
<p>Whew! This is a big error. The core of it is that we have ‘mismatched types’.
Rust has a strong, static type system. However, it also has type inference.
When we wrote <code>let guess = String::new()</code>, Rust was able to infer that <code>guess</code>
should be a <code>String</code>, and so it doesn’t make us write out the type. And with
our <code>secret_number</code>, there are a number of types which can have a value
between one and a hundred: <code>i32</code>, a thirty-two-bit number, or <code>u32</code>, an
unsigned thirty-two-bit number, or <code>i64</code>, a sixty-four-bit number or others.
So far, that hasn’t mattered, and so Rust defaults to an <code>i32</code>. However, here,
Rust doesn’t know how to compare the <code>guess</code> and the <code>secret_number</code>. They
need to be the same type. Ultimately, we want to convert the <code>String</code> we
read as input into a real number type, for comparison. We can do that
with two more lines. Here’s our new program:</p>
<pre><code class="language-rust,ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;The secret number is: {}&quot;, secret_number);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;failed to read line&quot;);

    let guess: u32 = guess.trim().parse()
        .expect(&quot;Please type a number!&quot;);

    println!(&quot;You guessed: {}&quot;, guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less    =&gt; println!(&quot;Too small!&quot;),
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
        Ordering::Equal   =&gt; println!(&quot;You win!&quot;),
    }
}
</code></pre>
<p>The new two lines:</p>
<pre><code class="language-rust,ignore">    let guess: u32 = guess.trim().parse()
        .expect(&quot;Please type a number!&quot;);
</code></pre>
<p>Wait a minute, I thought we already had a <code>guess</code>? We do, but Rust allows us
to ‘shadow’ the previous <code>guess</code> with a new one. This is often used in this
exact situation, where <code>guess</code> starts as a <code>String</code>, but we want to convert it
to an <code>u32</code>. Shadowing lets us re-use the <code>guess</code> name, rather than forcing us
to come up with two unique names like <code>guess_str</code> and <code>guess</code>, or something
else.</p>
<p>We bind <code>guess</code> to an expression that looks like something we wrote earlier:</p>
<pre><code class="language-rust,ignore">guess.trim().parse()
</code></pre>
<p>Here, <code>guess</code> refers to the old <code>guess</code>, the one that was a <code>String</code> with our
input in it. The <code>trim()</code> method on <code>String</code>s will eliminate any white space at
the beginning and end of our string. This is important, as we had to press the
‘return’ key to satisfy <code>read_line()</code>. This means that if we type <code>5</code> and hit
return, <code>guess</code> looks like this: <code>5\n</code>. The <code>\n</code> represents ‘newline’, the
enter key. <code>trim()</code> gets rid of this, leaving our string with only the <code>5</code>. The
<a href="../std/primitive.str.html#method.parse"><code>parse()</code> method on strings</a> parses a string into some kind of number.
Since it can parse a variety of numbers, we need to give Rust a hint as to the
exact type of number we want. Hence, <code>let guess: u32</code>. The colon (<code>:</code>) after
<code>guess</code> tells Rust we’re going to annotate its type. <code>u32</code> is an unsigned,
thirty-two bit integer. Rust has <a href="primitive-types.html#numeric-types">a number of built-in number types</a>,
but we’ve chosen <code>u32</code>. It’s a good default choice for a small positive number.</p>
<p>Just like <code>read_line()</code>, our call to <code>parse()</code> could cause an error. What if
our string contained <code>A👍%</code>? There’d be no way to convert that to a number. As
such, we’ll do the same thing we did with <code>read_line()</code>: use the <code>expect()</code>
method to crash if there’s an error.</p>
<p>Let’s try our program out!</p>
<pre><code class="language-bash">$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
</code></pre>
<p>Nice! You can see I even added spaces before my guess, and it still figured
out that I guessed 76. Run the program a few times, and verify that guessing
the number works, as well as guessing a number too small.</p>
<p>Now we’ve got most of the game working, but we can only make one guess. Let’s
change that by adding loops!</p>
<h1>Looping</h1>
<p>The <code>loop</code> keyword gives us an infinite loop. Let’s add that in:</p>
<pre><code class="language-rust,ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;The secret number is: {}&quot;, secret_number);

    loop {
        println!(&quot;Please input your guess.&quot;);

        let mut guess = String::new();

        io::stdin().read_line(&amp;mut guess)
            .expect(&quot;failed to read line&quot;);

        let guess: u32 = guess.trim().parse()
            .expect(&quot;Please type a number!&quot;);

        println!(&quot;You guessed: {}&quot;, guess);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less    =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal   =&gt; println!(&quot;You win!&quot;),
        }
    }
}
</code></pre>
<p>And try it out. But wait, didn’t we just add an infinite loop? Yup. Remember
our discussion about <code>parse()</code>? If we give a non-number answer, we’ll <code>panic!</code>
and quit. Observe:</p>
<pre><code class="language-bash">$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit
thread '&lt;main&gt;' panicked at 'Please type a number!'
</code></pre>
<p>Ha! <code>quit</code> actually quits. As does any other non-number input. Well, this is
suboptimal to say the least. First, let’s actually quit when you win the game:</p>
<pre><code class="language-rust,ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;The secret number is: {}&quot;, secret_number);

    loop {
        println!(&quot;Please input your guess.&quot;);

        let mut guess = String::new();

        io::stdin().read_line(&amp;mut guess)
            .expect(&quot;failed to read line&quot;);

        let guess: u32 = guess.trim().parse()
            .expect(&quot;Please type a number!&quot;);

        println!(&quot;You guessed: {}&quot;, guess);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less    =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal   =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p>By adding the <code>break</code> line after the <code>You win!</code>, we’ll exit the loop when we
win. Exiting the loop also means exiting the program, since it’s the last
thing in <code>main()</code>. We have only one more tweak to make: when someone inputs a
non-number, we don’t want to quit, we want to ignore it. We can do that
like this:</p>
<pre><code class="language-rust,ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;The secret number is: {}&quot;, secret_number);

    loop {
        println!(&quot;Please input your guess.&quot;);

        let mut guess = String::new();

        io::stdin().read_line(&amp;mut guess)
            .expect(&quot;failed to read line&quot;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;You guessed: {}&quot;, guess);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less    =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal   =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p>These are the lines that changed:</p>
<pre><code class="language-rust,ignore">let guess: u32 = match guess.trim().parse() {
    Ok(num) =&gt; num,
    Err(_) =&gt; continue,
};
</code></pre>
<p>This is how you generally move from ‘crash on error’ to ‘actually handle the
error’, by switching from <code>expect()</code> to a <code>match</code> statement. The <code>Result</code>
returned by <code>parse()</code> is an <code>enum</code>  like <code>Ordering</code>, but in this case, each
variant has some data associated with it: <code>Ok</code> is a success, and <code>Err</code> is a
failure. Each contains more information: the successfully parsed integer, or an
error type. In this case, we <code>match</code> on <code>Ok(num)</code>, which sets the inner value
of the <code>Ok</code> to the name <code>num</code>, and then we  return it on the right-hand
side. In the <code>Err</code> case, we don’t care what kind of error it is, so we
use <code>_</code> instead of a name. This ignores the error, and <code>continue</code> causes us
to go to the next iteration of the <code>loop</code>.</p>
<p>Now we should be good! Let’s try:</p>
<pre><code class="language-bash">$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
</code></pre>
<p>Awesome! With one tiny last tweak, we have finished the guessing game. Can you
think of what it is? That’s right, we don’t want to print out the secret
number. It was good for testing, but it kind of ruins the game. Here’s our
final source:</p>
<pre><code class="language-rust,ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    loop {
        println!(&quot;Please input your guess.&quot;);

        let mut guess = String::new();

        io::stdin().read_line(&amp;mut guess)
            .expect(&quot;failed to read line&quot;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;You guessed: {}&quot;, guess);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less    =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal   =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<h1>Complete!</h1>
<p>At this point, you have successfully built the Guessing Game! Congratulations!</p>
<p>This first project showed you a lot: <code>let</code>, <code>match</code>, methods, associated
functions, using external crates, and more. Our next project will show off
even more.</p>
<blockquote>
<p><em>commit edd5f33</em></p>
</blockquote>
<h1>語法及語意</h1>
<p>本章將 Rust 依照各個概念分成幾塊。</p>
<p>如果你想由下而上學習 Rust，依序閱讀是最好的方法。</p>
<p>這些章節也同時組成了各個概念的參考資料，所以如果你正在閱讀其他教學，或遇到一些疑惑，你可以在這找到一些解釋。</p>
<blockquote>
<p><em>commit 3a6dbb3</em></p>
</blockquote>
<h1>變數綁定</h1>
<p>事實上所有非 &quot;Hello World&quot; 的 Rust 程式都會用到 <em>變數綁定</em>。
他們將數值綁定到一個名字上，以便在之後使用它。
<code>let</code> 用來聲明一個綁定，就像：</p>
<pre><code class="language-rust">fn main() {
    let x = 5;
}
</code></pre>
<p>在所有範例中放入 <code>fn main() {</code> 有點冗餘，所以我們在後面都會省略它。
如果你一路看下去，請記得寫上 <code>main()</code> 韓式，不要忘記了。
否則你會得到錯誤訊息。</p>
<h2>模式 (Patterns)</h2>
<p>在很多語言，變數綁定被叫做 <em>變數</em> (variable)，但是 Rust 的變數綁定藏有秘招。
例如 <code>let</code> 表達式左邊是一個<a href="patterns.html">模式</a>，而不是變數名稱。
這代表我們可以做一些如下的事：</p>
<pre><code class="language-rust">let (x, y) = (1, 2);
</code></pre>
<p>在這個表達式計算後，<code>x</code> 會是 1，而 <code>y</code> 會是 2。
模式非常強大，而且在本書中有<a href="patterns.html">自己的章節</a>。
現在我們還不需要這些功能，所以我們只要記住有這個東西，然後繼續就可以了。</p>
<h2>型別註釋 (Type annotations)</h2>
<p>Rust 是靜態型別語言，這代表我們要先具體指定我們所需的型別，然後它們會在編譯期被檢查。
那為什麼第一個例子可以編譯過呢？
恩，因為 Rust 有一個 &quot;型別推斷&quot; (type inference) 的功能。
如果它能判斷某個東西的型別，你就不需要確切地指出來。</p>
<p>如果我們想要，也可以加上型別。
型別寫在冒號 (<code>:</code>) 後面：</p>
<pre><code class="language-rust">let x: i32 = 5;
</code></pre>
<p>如果我要求你大聲唸給班上同學聽，你應該唸成『<code>x</code> 被綁定為 <code>i32</code> 型別，而且數值是 <code>5</code>。』</p>
<p>這個例子中我們宣稱 <code>x</code> 為一個 32 位元的帶號整數 (signed integer)。
Rust 有許多不同的基本整數型別。
以 <code>i</code> 開頭的是帶號整數 (signed integers)，而以 <code>u</code> 開頭的是非帶號整數 (unsigned integers)。
整數可能的大小有 8、16、32、及 64 位元。</p>
<p>之後的範例，我們會把型別註釋在註解中。
範例會像這樣：</p>
<pre><code class="language-rust">fn main() {
    let x = 5; // x: i32
}
</code></pre>
<p>注意，註釋和 <code>let</code> 語法很類似。
Rust 習慣上不會有這些註解，但是我們偶爾會加上它們來幫助你理解 Rust 推斷的是什麼型別。</p>
<h2>可變性 (Mutability)</h2>
<p>綁定的預設是 <em>不可變的</em> (immutable)。
下面的原始碼無法編譯：</p>
<pre><code class="language-rust,ignore">let x = 5;
x = 10;
</code></pre>
<p>他會給你以下錯誤訊息：</p>
<pre><code class="language-text">error: re-assignment of immutable variable `x`
     x = 10;
     ^~~~~~~
</code></pre>
<p>如果你要綁定成為可變的 (mutable)，你可以用 <code>mut</code>：</p>
<pre><code class="language-rust">let mut x = 5; // mut x: i32
x = 10;
</code></pre>
<p>有不只一個理由要讓綁定的預設是不可變的，但是我們可以藉由一個 Rust 的一個主要目標來想想看：安全。
如果你忘記宣告 <code>mut</code>，編譯器會抓到它，然後讓你知道你可能改了某些並非真的想要改的東西。
如果綁定預設是可變的，編譯器就無法告訴你了。
如果你 <em>真的</em> 打算要改變，解決方式很簡單：加上 <code>mut</code>。</p>
<p>盡可能的避免改變狀態有其他好的理由，但是他們不在本指南的範圍內。
一般來說，你會避免直接了當的使用可變數 (mutation)，這也是 Rust 希望的。
雖然如此，有時候，你還是需要可變數，所以他沒有被禁止使用。</p>
<h2>初始化綁定 (Initializing bindings)</h2>
<p>Rust 的變數綁定有跟其他語言不同的一個方面：綁定需要再使用之前初始化一個數值。</p>
<p>讓我們試試看。
把你的 <code>src/main.rs</code> 改成以下這樣：</p>
<pre><code class="language-rust">fn main() {
    let x: i32;

    println!(&quot;Hello world!&quot;);
}
</code></pre>
<p>你可以輸入 <code>cargo build</code> 去建構它。
你將會得到警告訊息，但是它仍會印出 &quot;Hello, world!&quot;：</p>
<pre><code class="language-text">   Compiling hello_world v0.0.1 (file:///home/you/projects/hello_world)
src/main.rs:2:9: 2:10 warning: unused variable: `x`, #[warn(unused_variable)]
   on by default
src/main.rs:2     let x: i32;
                      ^
</code></pre>
<p>Rust 警告我們沒有使用這個變數綁定，但是的確我們沒有使用它，沒關係。
但如果我們真的使用 <code>x</code>，事情就不同了。
讓我們試試看。
把你的程式改成這樣：</p>
<pre><code class="language-rust,ignore">fn main() {
    let x: i32;

    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre>
<p>然後試著建構它。
你會得到錯誤訊息：</p>
<pre><code class="language-bash">$ cargo build
   Compiling hello_world v0.0.1 (file:///home/you/projects/hello_world)
src/main.rs:4:39: 4:40 error: use of possibly uninitialized variable: `x`
src/main.rs:4     println!(&quot;The value of x is: {}&quot;, x);
                                                    ^
note: in expansion of format_args!
&lt;std macros&gt;:2:23: 2:77 note: expansion site
&lt;std macros&gt;:1:1: 3:2 note: in expansion of println!
src/main.rs:4:5: 4:42 note: expansion site
error: aborting due to previous error
Could not compile `hello_world`.
</code></pre>
<p>Rust 不讓我們使用沒有被初始化的數值。
接著，讓我們討論我們加在 <code>println!</code> 的東西。</p>
<p>如果你在要印出的字串中加入大括號（<code>{}</code> 有些人稱作 moustaches ...），Rust 會理解為這是一個插入數值的要求。
<em>字串插值</em> (string interpolation) 是個電腦科學術語，代表 &quot;插入到字串中&quot;。
我們加上一個逗號和 <code>x</code>，來表示我們想要用 <code>x</code> 當成插入的值。
逗號是當我們傳遞多個參數時，用來分隔我們傳遞給函式和巨集的參數用的。</p>
<p>當你使用大括號時，Rust 會試著檢查型別，用有意義的方式顯示數值。
如果你想用更詳細的方式去指定格式，這邊有<a href="../std/fmt/index.html">很多方式可供選擇</a>。
現在，我們使用預設方式插入：印出整數並不難。</p>
<h2>有效範圍及遮蔽 (Scope and shadowing)</h2>
<p>讓我們回到綁定。
變數綁定有有效範圍 - 它們被限制在它們被定義的區塊中存在。
一個區塊 (block) 是一個被用 <code>{</code> 和 <code>}</code> 包起來的陳述式的集合。
函式的定義也是一個區塊！
在以下範例我們定義兩個變數綁定，<code>x</code> 和 <code>y</code>，他們存在於不同區塊中。
<code>x</code> 可以在 <code>fn main() {}</code> 內存取，而 <code>y</code> 只能在內部區塊 (inner block) 存取。</p>
<pre><code class="language-rust,ignore">fn main() {
    let x: i32 = 17;
    {
        let y: i32 = 3;
        println!(&quot;The value of x is {} and value of y is {}&quot;, x, y);
    }
    println!(&quot;The value of x is {} and value of y is {}&quot;, x, y); // This won't work
}
</code></pre>
<p>第一個 <code>println!</code> 會印出 &quot;The value of x is 17 and the value of y is 3&quot;，但是本範例無法成功編譯，因為第二個 <code>println!</code> 不能存取 <code>y</code> 的值，因為它已經不在有效範圍內了。
我們會得到以下錯誤訊息：</p>
<pre><code class="language-bash">$ cargo build
   Compiling hello v0.1.0 (file:///home/you/projects/hello_world)
main.rs:7:62: 7:63 error: unresolved name `y`. Did you mean `x`? [E0425]
main.rs:7     println!(&quot;The value of x is {} and value of y is {}&quot;, x, y); // This won't work
                                                                       ^
note: in expansion of format_args!
&lt;std macros&gt;:2:25: 2:56 note: expansion site
&lt;std macros&gt;:1:1: 2:62 note: in expansion of print!
&lt;std macros&gt;:3:1: 3:54 note: expansion site
&lt;std macros&gt;:1:1: 3:58 note: in expansion of println!
main.rs:7:5: 7:65 note: expansion site
main.rs:7:62: 7:63 help: run `rustc --explain E0425` to see a detailed explanation
error: aborting due to previous error
Could not compile `hello`.

To learn more, run the command again with --verbose.
</code></pre>
<p>另外，變數綁定可以被遮蔽 (shadowed)。
這代表與其他變數綁定有同樣名稱的後一個變數綁定，在有效範圍內，將會覆蓋前一個綁定。</p>
<pre><code class="language-rust">let x: i32 = 8;
{
    println!(&quot;{}&quot;, x); // Prints &quot;8&quot;
    let x = 12;
    println!(&quot;{}&quot;, x); // Prints &quot;12&quot;
}
println!(&quot;{}&quot;, x); // Prints &quot;8&quot;
let x =  42;
println!(&quot;{}&quot;, x); // Prints &quot;42&quot;
</code></pre>
<p>遮蔽 (shadowing) 和可變綁定 (mutable bindings) 也許像同一枚硬幣的兩面一樣，但他們是兩個不同的概念，所以不一定總是可以直接替換。
作為其中之一，遮蔽可以讓我們重新綁定名稱到不同型別的變數。
它也可以改變綁定的可變性。</p>
<pre><code class="language-rust">let mut x: i32 = 1;
x = 7;
let x = x; // x is now immutable and is bound to 7

let y = 4;
let y = &quot;I can also be bound to text!&quot;; // y is now of a different type
</code></pre>
<blockquote>
<p><em>commit 6ba9520</em></p>
</blockquote>
<h1>函式</h1>
<p>所有的 Rust 程式都至少有一個函式，<code>main</code> 函式，又稱主函式：</p>
<pre><code class="language-rust">fn main() {
}
</code></pre>
<p>這也許是最簡單的函式宣告了。
像我們之前說的，<code>fn</code> 表示 &quot;這是一個函式&quot;，後面是名稱，有個括號，沒有參數，而且有大括號去標示函式的內容。
以下是一個名叫 <code>foo</code> 的函式：</p>
<pre><code class="language-rust">fn foo() {
}
</code></pre>
<p>那如果有參數呢？
以下是一個印出數字的函式：</p>
<pre><code class="language-rust">fn print_number(x: i32) {
    println!(&quot;x is: {}&quot;, x);
}
</code></pre>
<p>這是一個使用 <code>print_number</code> 函式的完整程式：</p>
<pre><code class="language-rust">fn main() {
    print_number(5);
}

fn print_number(x: i32) {
    println!(&quot;x is: {}&quot;, x);
}
</code></pre>
<p>如你所見，函式的參數作用的方式跟 <code>let</code> 宣告非常類似：
在參數名後面加上冒號，後面再加上型別。</p>
<p>以下是一個把兩個數字相加之後印出來的完整程式：</p>
<pre><code class="language-rust">fn main() {
    print_sum(5, 6);
}

fn print_sum(x: i32, y: i32) {
    println!(&quot;sum is: {}&quot;, x + y);
}
</code></pre>
<p>當你呼叫函式或宣告函式時，需要用逗號分隔多個參數。</p>
<p>與 <code>let</code> 不同的是，你 <em>必須</em> 宣告函式參數的型別。
以下是無法作用的程式碼：</p>
<pre><code class="language-rust,ignore">fn print_sum(x, y) {
    println!(&quot;sum is: {}&quot;, x + y);
}
</code></pre>
<p>你會得到這些錯誤訊息：</p>
<pre><code class="language-text">expected one of `!`, `:`, or `@`, found `)`
fn print_sum(x, y) {
</code></pre>
<p>這是個深思熟慮後的設計決定。
即使像 Haskell 這樣可以對整個程式推斷 (full-program inference) 的語言，在最佳做法中仍經常建議要明確地標註你的型別。
我們認為在宣告函式時強制宣告型別，且允許在函式內容中允許推斷，是個在全推斷 (full-inference) 與無推斷間的最佳平衡。</p>
<p>那要如何回傳值呢？
以下是一個把整數加一的函式：</p>
<pre><code class="language-rust">fn add_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
<p>Rust 函式就只能回傳一個值，你可以在 &quot;箭頭&quot; 後面宣告型別，箭頭是一個破折號（<code>-</code>）加上一個大於符號（<code>&gt;</code>）。
函式的最後一行決定了回傳什麼。
你會注意到這邊並沒有分號。
如果我們加上分號：</p>
<pre><code class="language-rust,ignore">fn add_one(x: i32) -&gt; i32 {
    x + 1;
}
</code></pre>
<p>我們將看到錯誤訊息：</p>
<pre><code class="language-text">error: not all control paths return a value
fn add_one(x: i32) -&gt; i32 {
     x + 1;
}

help: consider removing this semicolon:
     x + 1;
          ^
</code></pre>
<p>這展現出了 Rust 兩個有趣的點：它是以表達式為基礎的語言，而且分號的使用跟其他 &quot;大括號及分號&quot; 的語言不同。
這兩件事是息息相關的。</p>
<h2>表達式 vs. 陳述式</h2>
<p>Rust 主要是個以表達式為基礎的語言。
它只有兩種陳述式，而其他的都是表達式。</p>
<p>那這有什麼分別？
表達式回傳值，而陳述式則否。
這也是為什麼我們在這說 &quot;不是所有的控制路徑都回傳值&quot;：陳述式 <code>x + 1;</code> 不傳回值。
Rust 中有兩種陳述式：&quot;宣告陳述式&quot; (declaration statements) 和 &quot;表達陳述式&quot; (expression statements)。
其他的都是表達式。
讓我們先討論宣告陳述式。</p>
<p>在一些語言中，變數綁定可以被寫成表達式，而非陳述式。
像 Ruby：</p>
<pre><code class="language-ruby">x = y = 5
</code></pre>
<p>然而在 Rust 中，使用 <code>let</code> 提出綁定 <em>不是</em> 一個表達式。
以下程式碼會產生一個編譯期錯誤：</p>
<pre><code class="language-ignore">let x = (let y = 5); // expected identifier, found keyword `let`
</code></pre>
<p>編譯器或告訴我們這裡預期會看到表達式的開頭，而 <code>let</code> 只能用於開始一個陳述式，不是表達式。</p>
<p>請注意，賦值到一個已經綁定的變數（例如 <code>y = 5</code>）仍然是個表達式，雖然它的值沒有什麼用。
不像其他語言的賦值會被算為賦予的數值（在前面的例子中會是 <code>5</code>），在 Rust 中賦值的執會是一個空的多元組 (tuple) <code>()</code>，因為賦予的值<a href="ownership.html">只能有一個擁有者</a>，而其他任何回傳值都會讓人意外：</p>
<pre><code class="language-rust">let mut y = 5;

let x = (y = 6);  // x has the value `()`, not `6`
</code></pre>
<p>Rust 中的第二種陳述式是 <em>表達陳述式</em> (expression statement)。
它的作用是把表達式轉為陳述式。
實際上，Rust 的文法預期陳述式後面也是其他陳述式。
這意味著你要使用分號去分隔表達式們。
這代表 Rust 看起來跟要求在每行結果使用分號的大多數語言一樣，你幾乎將會在每行結尾看到分號。</p>
<p>是什麼例外讓我們說 &quot;幾乎&quot;？
你早就看到了，就在以下程式碼中：</p>
<pre><code class="language-rust">fn add_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
<p>我們的函式聲明會回傳一個 <code>i32</code>，但是有分號時，它卻會回傳 <code>()</code>。
Rust 覺得這應該不是我們想要的，所以在上面看到的錯誤訊息中建議我們移除分號。</p>
<h2>提早回傳 (Early returns)</h2>
<p>那麼提早回傳又該怎樣做？
Rust 的確有一個關鍵字 <code>return</code> 可以提早回傳：</p>
<pre><code class="language-rust">fn foo(x: i32) -&gt; i32 {
    return x;

    // we never run this code!
    x + 1
}
</code></pre>
<p>使用 <code>return</code> 在函式的最後一行是可行的，但是這被認為是個不好的程式風格：</p>
<pre><code class="language-rust">fn foo(x: i32) -&gt; i32 {
    return x + 1;
}
</code></pre>
<p>如果你過去沒有寫過以表達式為基礎的語言，那麼在之前沒有 <code>return</code> 的定義可能讓你覺得看起來有些奇怪。
不過隨著時間過去，它會變得很直觀。</p>
<h2>發散函式 (Diverging functions)</h2>
<p>Rust 也有一些特別的語法叫做 &quot;發散函式&quot;，這種函式不回傳值：</p>
<pre><code class="language-rust">fn diverges() -&gt; ! {
    panic!(&quot;This function never returns!&quot;);
}
</code></pre>
<p><code>panic!</code> 是一個巨集，跟我們看過的 <code>println!()</code> 類似。
不像 <code>println!()</code>，<code>panic!()</code> 會讓當前的執行緒帶著指定的訊息當機 (crash)。
因為這個函式將會導致當機，所以它不會回傳值，也因此它的型別是 &quot;<code>!</code>&quot;，它叫做 &quot;發散&quot; (diverges)。</p>
<p>如果你加入一個主函式去呼叫 <code>diverges()</code> 並執行它，你將會得到像以下的輸出：</p>
<pre><code class="language-text">thread ‘&lt;main&gt;’ panicked at ‘This function never returns!’, hello.rs:2
</code></pre>
<p>如果你想看到更多資訊，你可以透過設定 <code>RUST_BACKTRACE</code> 環境變數去取得 backtrace：</p>
<pre><code class="language-text">$ RUST_BACKTRACE=1 ./diverges
thread '&lt;main&gt;' panicked at 'This function never returns!', hello.rs:2
stack backtrace:
   1:     0x7f402773a829 - sys::backtrace::write::h0942de78b6c02817K8r
   2:     0x7f402773d7fc - panicking::on_panic::h3f23f9d0b5f4c91bu9w
   3:     0x7f402773960e - rt::unwind::begin_unwind_inner::h2844b8c5e81e79558Bw
   4:     0x7f4027738893 - rt::unwind::begin_unwind::h4375279447423903650
   5:     0x7f4027738809 - diverges::h2266b4c4b850236beaa
   6:     0x7f40277389e5 - main::h19bb1149c2f00ecfBaa
   7:     0x7f402773f514 - rt::unwind::try::try_fn::h13186883479104382231
   8:     0x7f402773d1d8 - __rust_try
   9:     0x7f402773f201 - rt::lang_start::ha172a3ce74bb453aK5w
  10:     0x7f4027738a19 - main
  11:     0x7f402694ab44 - __libc_start_main
  12:     0x7f40277386c8 - &lt;unknown&gt;
  13:                0x0 - &lt;unknown&gt;
</code></pre>
<p><code>RUST_BACKTRACE</code> 也能用在 Cargo 的 <code>run</code> 指令上：</p>
<pre><code class="language-text">$ RUST_BACKTRACE=1 cargo run
     Running `target/debug/diverges`
thread '&lt;main&gt;' panicked at 'This function never returns!', hello.rs:2
stack backtrace:
   1:     0x7f402773a829 - sys::backtrace::write::h0942de78b6c02817K8r
   2:     0x7f402773d7fc - panicking::on_panic::h3f23f9d0b5f4c91bu9w
   3:     0x7f402773960e - rt::unwind::begin_unwind_inner::h2844b8c5e81e79558Bw
   4:     0x7f4027738893 - rt::unwind::begin_unwind::h4375279447423903650
   5:     0x7f4027738809 - diverges::h2266b4c4b850236beaa
   6:     0x7f40277389e5 - main::h19bb1149c2f00ecfBaa
   7:     0x7f402773f514 - rt::unwind::try::try_fn::h13186883479104382231
   8:     0x7f402773d1d8 - __rust_try
   9:     0x7f402773f201 - rt::lang_start::ha172a3ce74bb453aK5w
  10:     0x7f4027738a19 - main
  11:     0x7f402694ab44 - __libc_start_main
  12:     0x7f40277386c8 - &lt;unknown&gt;
  13:                0x0 - &lt;unknown&gt;
</code></pre>
<p>一個發散函式可以被用在任何型別上：</p>
<pre><code class="language-should_panic"># fn diverges() -&gt; ! {
#    panic!(&quot;This function never returns!&quot;);
# }
let x: i32 = diverges();
let x: String = diverges();
</code></pre>
<h2>函式指標 (Function pointers)</h2>
<p>我們也可以建立指向函式的變數綁定：</p>
<pre><code class="language-rust">let f: fn(i32) -&gt; i32;
</code></pre>
<p><code>f</code> 是一個指向以 <code>i32</code> 作為參數且回傳 <code>i32</code> 的函式的變數綁定。
例如：</p>
<pre><code class="language-rust">fn plus_one(i: i32) -&gt; i32 {
    i + 1
}

// without type inference
let f: fn(i32) -&gt; i32 = plus_one;

// with type inference
let f = plus_one;
</code></pre>
<p>接著，我們可以使用 <code>f</code> 去呼叫函式：</p>
<pre><code class="language-rust"># fn plus_one(i: i32) -&gt; i32 { i + 1 }
# let f = plus_one;
let six = f(5);
</code></pre>
<blockquote>
<p><em>commit 3eebec6</em></p>
</blockquote>
<h1>基本型別</h1>
<p>Rust 語言有許多被認為是 &quot;基本&quot; (primitive) 的型別。
這代表他們是內建在語言內的。
Rust 的標準函式庫也提供了許多基於這些基本型別的有用型別，它們也是基本型別。</p>
<h2>布林 (Booleans)</h2>
<p>Rust 內建布林型別，叫做 <code>bool</code>。
他有兩種值，<code>true</code> 和 <code>false</code>：</p>
<pre><code class="language-rust">let x = true;

let y: bool = false;
</code></pre>
<p>布林通常用在 <a href="if.html">if 條件運算式</a>。</p>
<p>你可以在<a href="https://doc.rust-lang.org/std/primitive.bool.html">標準函式庫文件</a>中找到更多關於 <code>bool</code> 的文件。</p>
<h2><code>char</code></h2>
<p><code>char</code> 型別代表一個 Unicode 值。
你可以以單引號（<code>'</code>）建立 <code>char</code>：</p>
<pre><code class="language-rust">let x = 'x';
let two_hearts = '💕';
</code></pre>
<p>不像其他語言，這代表 Rust 的 <code>char</code> 並非一個位元組，而是四個。</p>
<p>你可以在<a href="https://doc.rust-lang.org/std/primitive.char.html">標準函式庫文件</a>中找到更多關於 <code>char</code> 的文件。</p>
<h2>數字型別</h2>
<p>Rust 有許多數字型別，分為一些不同類型：帶號 (signed) 和非帶號 (unsigned)，固定長度和可變長度，浮點數和整數。</p>
<p>這些型別包含兩部分：類型和大小。
例如，<code>u16</code> 是一個 16 位元大小的非帶號型別。
更多位元能讓你有更大的數字。</p>
<p>如果數字在字面上沒有其他東西可以推測他的型別，它會使用預設型別：</p>
<pre><code class="language-rust">let x = 42; // x has type i32

let y = 1.0; // y has type f64
</code></pre>
<p>這裡有一份不同數字型別的清單，以及它們在標準函式庫中的文件連結：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/primitive.i8.html">i8</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.i16.html">i16</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.i32.html">i32</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.i64.html">i64</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.u8.html">u8</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.u16.html">u16</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.u32.html">u32</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.u64.html">u64</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.isize.html">isize</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.usize.html">usize</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.f32.html">f32</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.f64.html">f64</a></li>
</ul>
<p>讓我們依照分類走一輪吧：</p>
<h3>帶號 (Signed) 及非帶號 (Unsigned)</h3>
<p>整數型別有兩種變形：帶號跟非帶號。
要了解差異之處，讓我們試想有一個 4 位元大小的數字。
如果是帶號整數，4 位元可以讓你儲存 <code>-8</code> 到 <code>+7</code> 的數字。
代號數字使用 &quot;二補數表示法&quot; (two's complement)。
一個非帶號的 4 位元數字因為不需要儲存負號，所以可以儲存 <code>0</code> 到 <code>+15</code> 的數字。</p>
<p>非帶號型別使用 <code>u</code> 作為分類，而帶號型別使用 <code>i</code>。
<code>i</code> 代表 &quot;integer&quot;。
所以 <code>u8</code> 代表一個 8 位元的非代號數字，而 <code>i8</code> 代表 8 位元的帶號數字。</p>
<h3>固定大小型別</h3>
<p>固定大小型別的表現方式有一些特定數量的位元。
有效的位元大小有 <code>8</code>、<code>16</code>、<code>32</code>、<code>64</code>。
所以 <code>u32</code> 是一個非帶號的 32 位元整數，而 <code>i64</code> 是一個帶號的 64 位元整數。</p>
<h3>可變大小型別</h3>
<p>Rust 也有提供一些大小依賴於底層機器的指標大小的型別。
這些型別的分類是 &quot;size&quot;，且分為帶號跟非帶號。
他分為兩類：<code>isize</code> 和 <code>usize</code>。</p>
<h3>浮點數型別</h3>
<p>Rust 也有兩種浮點數：<code>f32</code> 與 <code>f64</code>。
他們對應到 IEEE-754 的單精準度和雙精準度浮點數。</p>
<h2>陣列 (Arrays)</h2>
<p>跟很多程式語言一樣，Rust 有用來表現一組事物的清單型別。
最基本的就是 <em>陣列</em> (array)，一個固定大小、有相同型別的元素清單。
陣列預設是不可變的 (immutable)。</p>
<pre><code class="language-rust">let a = [1, 2, 3]; // a: [i32; 3]
let mut m = [1, 2, 3]; // m: [i32; 3]
</code></pre>
<p>陣列的型別是 <code>[T; N]</code>。
我們將在<a href="generics.html">泛型的章節</a>提到 <code>T</code> 標記。
<code>N</code> 是一個編譯期的常數，代表陣列的長度。</p>
<p>有一個可以初始化陣列中所有元素為同一個值的簡寫。
在以下範例，所有 <code>a</code> 中的元素將被初始化為 <code>0</code>：</p>
<pre><code class="language-rust">let a = [0; 20]; // a: [i32; 20]
</code></pre>
<p>你可以透過 <code>a.len()</code> 取得 <code>a</code> 陣列中元素的個數：</p>
<pre><code class="language-rust">let a = [1, 2, 3];

println!(&quot;a has {} elements&quot;, a.len());
</code></pre>
<p>你也可以使用 <em>下標</em> (subscript) 的標記方式存取陣列中特定元素：</p>
<blockquote>
<p>譯註：此處的 <em>下標</em> 應指 <code>[n]</code> 這個標記方式。</p>
</blockquote>
<pre><code class="language-rust">let names = [&quot;Graydon&quot;, &quot;Brian&quot;, &quot;Niko&quot;]; // names: [&amp;str; 3]

println!(&quot;The second name is: {}&quot;, names[1]);
</code></pre>
<p>與其他大多數程式語言一樣，下標從零開始，所以第一個元素名稱是 <code>names[0]</code>，第二個名稱是 <code>names[1]</code>。
上述範例會印出 <code>The second name is: Brian</code>。
如果你嘗試使用超出陣列的下標，你會得到錯誤訊息：陣列存取會在執行期做邊界檢查。
在其他系統程式語言中，這種不當存取是許多程式錯誤 (bug) 的根源。</p>
<p>你可以在<a href="https://doc.rust-lang.org/std/primitive.array.html">標準函式庫文件</a>中找到更多關於 <code>array</code> 的文件。</p>
<h2>Slices</h2>
<p>一個 &quot;slice&quot; 是一個其他資料結構的參照（或 &quot;視圖&quot;）。
它允許安全、有效的存取陣列的一部份而不用複製陣列。
例如，你可能只想要參考讀到記憶體中的檔案中的某一行。
本質上，一個 &quot;slice&quot; 不是直接建立的，而要從一個已經存在的變數綁定中建立。
Slices 會定義長度，它可以是可變 (mutable) 或不可變 (immutable)。</p>
<p>從內部來看，slices 像是一個指向資料開頭的指標，和它的長度。</p>
<h3>Slicing 語法</h3>
<p>你可以使用 <code>&amp;</code> 和 <code>[]</code> 的組合去從許多資料結構建立 slice。
<code>&amp;</code> 說明了 slices 跟<a href="references-and-borrowing.html">參照</a>很類似，我們會在本節的後面說到細節。
<code>[]</code> 帶有範圍的資訊，讓你定義 slice 的長度。</p>
<pre><code class="language-rust">let a = [0, 1, 2, 3, 4];
let complete = &amp;a[..]; // A slice containing all of the elements in a
let middle = &amp;a[1..4]; // A slice of a: only the elements 1, 2, and 3
</code></pre>
<p>Slices 的型別是 <code>&amp;[T]</code>。
我們將會在<a href="generics.html">泛型</a>談到 <code>T</code>。</p>
<p>你可以在<a href="https://doc.rust-lang.org/std/primitive.slice.html">標準函式庫文件</a>中找到更多關於 slices 的文件。</p>
<h2><code>str</code></h2>
<p>Rust 的 <code>str</code> 型別是最基本的字串型別。
跟<a href="unsized-types.html">動態大小型別</a>，它本身不是很有用，但當它放在參照之後就很有用了，像是 <code>$str</code>。
當我們談到<a href="strings.html">字串</a>和<a href="references-and-borrowing.html">參照</a>的時候再來細說。</p>
<p>你可以在<a href="https://doc.rust-lang.org/std/primitive.str.html">標準函式庫文件</a>中找到更多關於 <code>str</code> 的文件。</p>
<h2>多元組 (Tuples)</h2>
<p>一個多元組 (tuple) 是一組固定大小的有序 (ordered) 清單。
就像：</p>
<pre><code class="language-rust">let x = (1, &quot;hello&quot;);
</code></pre>
<p>這是長度為 2 的多元組，由括弧和逗號組成。
以下是同樣的程式碼，但是多了型別註釋：</p>
<pre><code class="language-rust">let x: (i32, &amp;str) = (1, &quot;hello&quot;);
</code></pre>
<p>如你所見，多元組的型別與多元組很像，只是各個位置是型別名稱而不是數值。
心細的讀者會注意到多元組是異質的 (heterogeneous)：我們在一個多元組中同時有 <code>i32</code> 與 <code>&amp;str</code>。
在系統程式語言中，字串會比其他語言複雜一點。
現在，把 <code>&amp;str</code> 當作 <em>字串 slice</em>，我們很快就會說到。</p>
<p>當兩個多元組有相同的型別和<a href="glossary.html#%E5%85%83%E6%95%B8%20(Arity)">元數</a> (arity) 時，你可以把一個多元組賦值給另一個。
相同長度的多元組有著相同的元數。</p>
<pre><code class="language-rust">let mut x = (1, 2); // x: (i32, i32)
let y = (2, 3); // y: (i32, i32)

x = y;
</code></pre>
<p>你可以透過 <em>destructuring let</em> 存取多元組的欄位。
以下是範例：</p>
<pre><code class="language-rust">let (x, y, z) = (1, 2, 3);

println!(&quot;x is {}&quot;, x);
</code></pre>
<p>還記得<a href="variable-bindings.html">之前</a>當我提到 <code>let</code> 陳述式的左邊遠比賦值綁定還強大嗎？
這就是了。
我們可以放一個模式 (pattern) 在 <code>let</code> 的左邊，然後如果它跟右邊相符，我們就可以一次賦值多個綁定。
在這情形下，<code>let</code> &quot;解構&quot; 或 &quot;拆開&quot; 了多元組，然後賦值到三個綁定上。</p>
<p>這樣的模式非常強大，我們將會在後面一直看到。</p>
<p>在括號中只有一個值時，在值後面加上逗號，可以消歧義確定它是一個單元素的多元組：</p>
<pre><code class="language-rust">(0,); // single-element tuple
(0); // zero in parentheses
</code></pre>
<h3>多元組索引 (Tuple Indexing)</h3>
<p>你也可以用索引語法去存取多元組的欄位：</p>
<pre><code class="language-rust">let tuple = (1, 2, 3);

let x = tuple.0;
let y = tuple.1;
let z = tuple.2;

println!(&quot;x is {}&quot;, x);
</code></pre>
<p>就像陣列的索引，它從零開始，但是不像陣列所以，它使用 <code>.</code> 而不是 <code>[]</code>。</p>
<p>你可以在<a href="https://doc.rust-lang.org/std/primitive.tuple.html">標準函式庫文件</a>中找到更多關於多元組的文件。</p>
<h2>函式</h2>
<p>函式也有型別！
它們像這樣：</p>
<pre><code class="language-rust">fn foo(x: i32) -&gt; i32 { x }

let x: fn(i32) -&gt; i32 = foo;
</code></pre>
<p>在這個例子中，<code>x</code> 是 &quot;函式指標&quot; 指向一個有 <code>i32</code> 參數並回傳 <code>i32</code> 的函式。</p>
<blockquote>
<p><em>commit 228afd7</em></p>
</blockquote>
<h1>註解</h1>
<p>現在我們有了一些函式，開始學習註解是個好點子。
註解是讓你留給其他程式設計師的備註，可以幫忙解釋你的程式碼。
編譯器幾乎會直接忽略它們。</p>
<p>Rust 有兩種你需要注意的註解方式：<em>行內註解</em> (line comments) 與 <em>文件註解</em> (doc comments)。</p>
<blockquote>
<p>譯註：以下是行內註解。</p>
</blockquote>
<pre><code class="language-rust">// Line comments are anything after ‘//’ and extend to the end of the line.

let x = 5; // this is also a line comment.

// If you have a long explanation for something, you can put line comments next
// to each other. Put a space between the // and your comment so that it’s
// more readable.
</code></pre>
<p>另一種註解是文件註解。
文件註解使用 <code>///</code> 而不是 <code>//</code>，而且支援 Markdown 標記：</p>
<pre><code class="language-rust">/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let five = 5;
///
/// assert_eq!(6, add_one(5));
/// # fn add_one(x: i32) -&gt; i32 {
/// #     x + 1
/// # }
/// ```
fn add_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
<p>還有另一種文件註解 <code>//!</code>，用來註解包含它的項目（例如：crates、模組、或函式），而不是在其後的東西。
一般用在 crates 的 root 檔（lib.rs）或模組的 root（mod.rs）：</p>
<pre><code>//! # The Rust Standard Library
//!
//! The Rust Standard Library provides the essential runtime
//! functionality for building portable Rust software.
</code></pre>
<p>當撰寫文件註解的時候，提供一些使用範例是非常非常有用的。
你會注意到我們用了一個新的巨集：<code>assert_eq!</code>。
它會比較兩個值，然後如果它們彼此不相等就會 <code>panic!</code>。
這在文件中非常有用。
還有一個巨集 <code>assert!</code>，如果傳給它 <code>false</code> 時會 <code>panic!</code>。</p>
<p>你可以使用 <a href="documentation.html">rustdoc</a> 工具從文件註解去產生 HTML 文件，也可以執行程式碼範例當作測試。</p>
<blockquote>
<p><em>commit 024aa9a</em></p>
</blockquote>
<h1>if</h1>
<p>Rust 的 <code>if</code> 沒有特別複雜，但你會發現它更像動態型別語言的 <code>if</code> 而非傳統的系統程式語言。
所以讓我們聊聊它，確定你領會了這些細微差別。</p>
<p><code>if</code> 是一個更通用的概念 &quot;分支&quot; (branch) 的特殊形式。
這個名字來自樹的分支：一個根據選擇而有不同路徑的決策點。</p>
<p>在 <code>if</code> 的情況下，一個選擇會導向兩個路徑：</p>
<pre><code class="language-rust">let x = 5;

if x == 5 {
    println!(&quot;x is five!&quot;);
}
</code></pre>
<p>如果我們改變 <code>x</code> 為其他值，就不會印出那一行。
確切的說，如果 <code>if</code> 後面的表達式是 <code>true</code>，那麼區塊內的程式碼就會被執行。
如果是 <code>false</code>，那就不執行。</p>
<p>如果你想在 <code>false</code> 的情況下做點什麼，就使用 <code>else</code>：</p>
<pre><code class="language-rust">let x = 5;

if x == 5 {
    println!(&quot;x is five!&quot;);
} else {
    println!(&quot;x is not five :(&quot;);
}
</code></pre>
<p>如果有超過一種情形，使用 <code>else if</code>：</p>
<pre><code class="language-rust">let x = 5;

if x == 5 {
    println!(&quot;x is five!&quot;);
} else if x == 6 {
    println!(&quot;x is six!&quot;);
} else {
    println!(&quot;x is not five or six :(&quot;);
}
</code></pre>
<p>這些都是標準情況。
然而你也可以這樣做：</p>
<pre><code class="language-rust">let x = 5;

let y = if x == 5 {
    10
} else {
    15
}; // y: i32
</code></pre>
<p>我們可以（且或許應該）寫成這樣：</p>
<pre><code class="language-rust">let x = 5;

let y = if x == 5 { 10 } else { 15 }; // y: i32
</code></pre>
<p>這是可行的，因為 <code>if</code> 是個表達式。
表達式的值就是任何一個被選擇的分支的最後一個表達式的值。
一個沒有 <code>else</code> 的 <code>if</code> 總是會回傳 <code>()</code> 值。</p>
<blockquote>
<p><em>commit 024aa9a</em></p>
</blockquote>
<h1>迴圈</h1>
<p>Rust 目前提供三種方式去執行一些疊代行為。
它們是 <code>loop</code>、<code>while</code>、及 <code>for</code>。
它們各有各自的用途。</p>
<blockquote>
<p>譯註：iterative activity 這邊參考<a href="https://zh.wikipedia.org/wiki/%E8%BF%AD%E4%BB%A3">維基百科</a>，故使用疊代來翻譯。</p>
</blockquote>
<h2>loop</h2>
<p>無限 <code>loop</code> 是 Rust 中最簡單的 loop 形式。
使用 <code>loop</code> 關鍵字，Rust 會提供給你一個方法，會無限循環直到某些終結陳述達成。
Rust 的無限 <code>loop</code> 看起來像這樣：</p>
<pre><code class="language-rust,ignore">loop {
    println!(&quot;Loop forever!&quot;);
}
</code></pre>
<h2>while</h2>
<p>Rust 也有 <code>while</code> 迴圈。
看起來像這樣：</p>
<pre><code class="language-rust">let mut x = 5; // mut x: i32
let mut done = false; // mut done: bool

while !done {
    x += x - 3;

    println!(&quot;{}&quot;, x);

    if x % 5 == 0 {
        done = true;
    }
}
</code></pre>
<p>當你不確定你需要循環幾次時，<code>while</code> 迴圈是你的正確選擇。</p>
<p>如果你需要無限迴圈，你可能會想這樣寫：</p>
<pre><code class="language-rust,ignore">while true {
</code></pre>
<p>然而 <code>loop</code> 更適合去處理這種情況：</p>
<pre><code class="language-rust,ignore">loop {
</code></pre>
<p>Rust 的控制流程分析器會差別對待這個結構與 <code>while true</code>，因為我們知道它會一直循環。
一般來說，你給編譯器越多資訊，越能讓它更安全且產生更好的程式碼，所以當你計畫要無限循環時，你應該使用 <code>loop</code>。</p>
<h2>for</h2>
<p><code>for</code> 迴圈用來循環特定次數。
然而，Rust 的 <code>for</code> 迴圈與其他系統程式語言有些不同。
Rust 的 <code>for</code> 迴圈看起來不像 &quot;C 語言風格&quot; 的 <code>for</code> 迴圈：</p>
<pre><code class="language-c">for (x = 0; x &lt; 10; x++) {
    printf( &quot;%d\n&quot;, x );
}
</code></pre>
<p>反之，它看起來像這樣：</p>
<pre><code class="language-rust">for x in 0..10 {
    println!(&quot;{}&quot;, x); // x: i32
}
</code></pre>
<p>更抽象一點：</p>
<pre><code class="language-ignore">for var in expression {
    code
}
</code></pre>
<p>這邊的表達式是一個能以 <a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html">IntoIterator</a> 轉成<a href="iterators.html">疊代器</a> (iterator) 的東西。
疊代器會傳回一系列的元素。
每個元素是迴圈中的一次循環。
在這次迴圈的有效範圍內，元素的值會跟 <code>var</code> 綁定。
當迴圈結束，下一個值會從疊代器中取出，然後重複另一次。
當疊代器中沒有值了，<code>for</code> 迴圈就結束。</p>
<p>在我們的範例中，<code>0..10</code> 表達式會根據開始和結束的值，給予一個含有兩者之間數字的疊代器。
上限值不包含在其中，所以我們的迴圈會印出 <code>0</code> 到 <code>9</code>，沒有 <code>10</code>。</p>
<p>Rust 特別不使用 &quot;C 語言風格&quot; 的 <code>for</code> 迴圈。
即使對有經驗的 C 語言程式設計師來說，手動控制迴圈中的每個元素仍是複雜且容易出錯的。</p>
<h3>枚舉 (Enumerate)</h3>
<p>當你需要追蹤你已經循環了幾次，你可以使用 <code>.enumerate()</code> 函式。</p>
<h4>對範圍</h4>
<pre><code class="language-rust">for (i,j) in (5..10).enumerate() {
    println!(&quot;i = {} and j = {}&quot;, i, j);
}
</code></pre>
<p>輸出：</p>
<pre><code class="language-text">i = 0 and j = 5
i = 1 and j = 6
i = 2 and j = 7
i = 3 and j = 8
i = 4 and j = 9
</code></pre>
<p>別忘了在範圍加上括號。</p>
<blockquote>
<p>譯註：<code>for (i,j) in (5..10).enumerate()</code> 中的 <code>i</code> 就像是 index，可以用來計數，<code>j</code> 則是原來的值。</p>
</blockquote>
<h4>對疊代器</h4>
<pre><code class="language-rust">let lines = &quot;hello\nworld&quot;.lines();

for (linenumber, line) in lines.enumerate() {
    println!(&quot;{}: {}&quot;, linenumber, line);
}
</code></pre>
<p>輸出：</p>
<pre><code class="language-text">0: hello
1: world
</code></pre>
<h2>提早結束疊代</h2>
<p>讓我們看看前面提到的 <code>while</code> 迴圈：</p>
<pre><code class="language-rust">let mut x = 5;
let mut done = false;

while !done {
    x += x - 3;

    println!(&quot;{}&quot;, x);

    if x % 5 == 0 {
        done = true;
    }
}
</code></pre>
<p>我們必須保持一個專用的 <code>mut</code> 布林變數綁定 <code>done</code>，用來知道何時我們應該離開迴圈。
Rust 有兩個關鍵字可以幫助我們修改這個疊代：<code>break</code> 和 <code>continue</code>。</p>
<p>在這個情況下，我們可以用 <code>break</code> 把迴圈寫得更好：</p>
<pre><code class="language-rust">let mut x = 5;

loop {
    x += x - 3;

    println!(&quot;{}&quot;, x);

    if x % 5 == 0 { break; }
}
</code></pre>
<p>我們現在使用 <code>loop</code> 無限循環，並使用 <code>break</code> 去提早結束。
使用 <code>return</code> 陳述式也可以提早結束迴圈。</p>
<p><code>continue</code> 也很類似，但是並非結束迴圈，而是跳到下一次疊代。
這是一個只印出奇數的程式碼：</p>
<pre><code class="language-rust">for x in 0..10 {
    if x % 2 == 0 { continue; }

    println!(&quot;{}&quot;, x);
}
</code></pre>
<h2>迴圈標籤 (Loop labels)</h2>
<p>你可能也會遇到一些情況，例如當你有槽狀迴圈，且希望你的 <code>break</code> 或 <code>continue</code> 能指定做用到哪一個的時候。
跟其他多數語言一樣，預設的 <code>break</code> 或 <code>continue</code> 會作用在最內層的迴圈。
當你希望你的 <code>break</code> 或 <code>continue</code> 要作用在外層的某個迴圈時，你可以使用標籤去指定 <code>break</code> 或 <code>continue</code> 要作用在哪層迴圈。
下面程式碼只會在 <code>x</code> 和 <code>y</code> 都是奇數的時候印出東西：</p>
<pre><code class="language-rust">'outer: for x in 0..10 {
    'inner: for y in 0..10 {
        if x % 2 == 0 { continue 'outer; } // continues the loop over x
        if y % 2 == 0 { continue 'inner; } // continues the loop over y
        println!(&quot;x: {}, y: {}&quot;, x, y);
    }
}
</code></pre>
<blockquote>
<p><em>commit 7df3bf1</em></p>
</blockquote>
<h1>所有權</h1>
<p>本指南是當前 Rust 的三個所有權系統之一。
這是 Rust 最獨特且引人注目的功能之一，作為 Rust 的開發者應該對此要有相當的了解。
所有權是 Rust 用來達成其最大的目標，記憶體安全，的方法。
它有一些不同的概念，各自有各自的章節：</p>
<ul>
<li>所有權 (ownership)，你正在閱讀的章節</li>
<li><a href="references-and-borrowing.html">借用</a> (borrowing)，及其相關功能 &quot;參照&quot; (references)</li>
<li><a href="lifetimes.html">生命週期</a> (lifetime)，借用的進階概念</li>
</ul>
<p>這三章依序相關。
你需要了解全部三章來完整了解所有權系統。</p>
<h2>Meta</h2>
<p>在我們開始細述前，有兩個所有權系統的重點。</p>
<p>Rust 注重安全和速度。
它透過許多 &quot;零成本抽象化&quot; 的方式去實現目標，也就是 Rust 將盡可能縮小抽象化成本去達成目標。
所有權系統是零成本抽象化的一個最佳範例。
我們在本指南中談到的所有分析，都是在 <em>編譯期完成的</em>。
這些功能不需要花費你任何執行期的成本。</p>
<p>然而，這套系統仍有某些成本：學習曲線。
許多 Rust 的新使用者會經歷我們所說的 &quot;與借用檢查器 (borrow checker) 戰鬥&quot; 的經驗，也就是 Rust 編譯器無法編譯一個作者認為合理的程式。
在程式設計師內心的所有權運作模型與實際上 Rust 實作不相符的時候，這會常常發生。
一開始你可能也會經歷類似的事情。
然而有個好消息：許多有經驗的 Rust 開發者回報，當他們適應所有權系統的規則一陣子之後，他們跟借用檢查器的戰鬥就越來越少了。</p>
<p>記住這些之後，讓我們開始學習所有權。</p>
<h2>所有權 (Ownership)</h2>
<p><a href="variable-bindings.html">變數綁定</a>在 Rust 中個屬性：它們有所綁定的值的 &quot;所有權&quot;。
這代表當綁定離開有效範圍，Rust 就會釋放綁定的資源。
例如：</p>
<pre><code class="language-rust">fn foo() {
    let v = vec![1, 2, 3];
}
</code></pre>
<p>當 <code>v</code> 進入有效範圍時，一個新的<a href="vectors.html">向量</a> (vector) 會在<a href="the-stack-and-the-heap.html#the-stack">堆疊</a> (stack) 中被建立，且在<a href="the-stack-and-the-heap.html">堆積</a> (heap) 中替其元素配置空間。
當 <code>v</code> 在 <code>foo()</code> 結尾離開有效範圍時，Rust 會清除任何與這個向量有關的東西，甚至是堆積內配置的記憶體。
這在有效範圍結束後必定發生。</p>
<p>我們會在後面章節詳細說明<a href="vectors.html">向量</a>；在此我們只用它來作為一個在執行期配置堆積中空間的例子。
它的行為跟<a href="primitive-types.html#arrays">陣列</a>類似，除了它的大小可以透過 <code>push()</code> 加入元素而改變這點。</p>
<p>向量有個<a href="generics.html">泛型</a> <code>Vec&lt;T&gt;</code>，在本範例 <code>v</code> 是 <code>Vec&lt;i32&gt;</code> 型別。
我們將會在本章後面提及泛型。</p>
<h2>移動語意 (Move semantics)</h2>
<p>此處是更加精妙的部分：Rust 確保所有的資源都 <em>只有一個</em> 對應的綁定。
例如，如果我們有個向量，我們可以賦值給另一個綁定：</p>
<pre><code class="language-rust">let v = vec![1, 2, 3];

let v2 = v;
</code></pre>
<p>但是，當我們在之後試著使用 <code>v</code> 時，會得到錯誤訊息：</p>
<pre><code class="language-rust,ignore">let v = vec![1, 2, 3];

let v2 = v;

println!(&quot;v[0] is: {}&quot;, v[0]);
</code></pre>
<p>看起來像這樣：</p>
<pre><code class="language-text">error: use of moved value: `v`
println!(&quot;v[0] is: {}&quot;, v[0]);
                        ^
</code></pre>
<p>當我們定義一個取得所有權的函式，且試著在傳遞參數之後使用同個參數時，會發生類似的事：</p>
<pre><code class="language-rust,ignore">fn take(v: Vec&lt;i32&gt;) {
    // what happens here isn’t important.
}

let v = vec![1, 2, 3];

take(v);

println!(&quot;v[0] is: {}&quot;, v[0]);
</code></pre>
<p>同樣的錯誤： &quot;use of moved value&quot;。
當我們轉移所有權給其他綁定後，我們稱此為 &quot;移動&quot; 了所引用的值。
這是 Rust 的預設行為，你不需特別註記什麼。</p>
<h3>細節</h3>
<p>在移動綁定後我們無法使用它的原因很精妙，也很重要。</p>
<p>當我們寫了以下程式碼：</p>
<pre><code class="language-rust">let x = 10;
</code></pre>
<p>Rust 替 <a href="primitive-types.html#%E6%95%B8%E5%AD%97%E5%9E%8B%E5%88%A5">i32</a> 配置記憶體在<a href="the-stack-and-the-heap.html">堆疊</a>上，複製代表 10 的值的位元到配置的記憶體中，且綁定變數名稱 <code>x</code> 到此區記憶體以便未來使用。</p>
<p>現在細想以下程式碼片段：</p>
<pre><code class="language-rust">let v = vec![1, 2, 3];

let mut v2 = v;
</code></pre>
<p>第一行就如同上述的 <code>x</code> 一樣，它替向量物件 <code>v</code> 配置記憶體到堆疊上。
但它還配置一些<a href="the-stack-and-the-heap.html">堆積</a>上的記憶體放實際的資料（<code>[1, 2, 3]</code>）。
Rust 複製堆積配置的記憶體位址給內部指標，這個內部指標是向量物件存在堆疊上的部份（讓我們稱它資料指標 data pointer）。</p>
<p>值得說明的是，向量物件和它的資料分別放在不同的記憶體區塊，而不在單一連續的記憶體配置中（因為一些理由我們不會細說）。
向量的這兩部分（一部份在堆疊、一部份在堆積）必須在任何時候都與對方一致，像長度、容量等。</p>
<p>當我們移動 <code>v</code> 到 <code>v2</code> 時，Rust 實際上把向量物件 <code>v</code> 照著位元複製一份到堆疊配置中的 <code>v2</code>。
這份複本並沒有建立堆積配置中實際資料的複本。
這代表會同時有指向向量內容的兩個指標，兩者都指向堆積中的同一塊記憶體配置。
如果同時可以存取 <code>v</code> 跟 <code>v2</code> 將會有資料競爭 (data race)，這會違背 Rust 的安全保證。</p>
<blockquote>
<p>譯註：當 <code>let mut v2 = v</code> 時，只是把 <code>v</code> 中的資料指標複製一份給 <code>v2</code>，所以 <code>v</code> 與 <code>v2</code> 同時指向堆積中的同一份資料。
當兩者同時存取時就會出現資料競爭的可能性。</p>
</blockquote>
<p>舉例來說，如果我們從 <code>v2</code> 截去向量中的兩個元素：</p>
<pre><code class="language-rust"># let v = vec![1, 2, 3];
# let mut v2 = v;
v2.truncate(2);
</code></pre>
<p>而 <code>v</code> 仍可存取，因此我們最終將得到一個非法的向量，因為 <code>v</code> 不知道堆積資料被截去了。
現在，<code>v</code> 向量在堆疊上的部份與堆積上的部分並不一致。
<code>v</code> 仍認為有三個元素在向量中，且仍非常歡迎我們存取已不存在的元素 <code>v[2]</code>，但就如你早已知道的，這將導致後患無窮。
特別是這可能還會引起記憶體區段錯誤 (segmentation fault)，甚至更糟的情況會允許未經認證的使用者從記憶體中讀取不應存取的東西。</p>
<blockquote>
<p>譯註：此處原文為 <code>v1</code>，修正為 <code>v</code>。</p>
</blockquote>
<p>這也是為何 Rust 禁止在我們移動綁定之後使用 <code>v</code>。</p>
<p>另外也很重要的是，依照情況，最佳化可能會移除堆疊上位元的實際複本。
所以它可能不像一開始看起來的那麼沒效率。</p>
<h3><code>Copy</code> 型別</h3>
<p>我們已經知道當所有權轉移到另一個綁定後，你不能再使用原來的綁定。
然而，有一個 <a href="traits.html">trait</a> 可以改變這個行為，它稱為 <code>Copy</code>。
我們還沒說到 traits，但現在，你可以把它當成替特定型別加上額外行為的一種註釋。
例如：</p>
<pre><code class="language-rust">let v = 1;

let v2 = v;

println!(&quot;v is: {}&quot;, v);
</code></pre>
<p>在此情況下，<code>v</code> 是個實作 <code>Copy</code> trait 的 <code>i32</code>。
這代表，跟移動一樣，當我們把 <code>v</code> 賦值給 <code>v2</code> 時，一個資料的複本會被建立。
但跟移動不同的是，在之後我們仍可使用 <code>v</code>。
這是因為 <code>i32</code> 並沒有指標指向其他資料，複製時就是個完整的複本。</p>
<p>所有的基本型別都實作了 <code>Copy</code> trait，也因此它們的所有權並不會像 &quot;所有權規則&quot; 所假設的那樣被移動。
以下兩個程式碼片段的範例都可以編譯，因為 <code>i32</code> 與 <code>bool</code> 型別都實作了 <code>Copy</code> trait。</p>
<pre><code class="language-rust">fn main() {
    let a = 5;

    let _y = double(a);
    println!(&quot;{}&quot;, a);
}

fn double(x: i32) -&gt; i32 {
    x * 2
}
</code></pre>
<pre><code class="language-rust">fn main() {
    let a = true;

    let _y = change_truth(a);
    println!(&quot;{}&quot;, a);
}

fn change_truth(x: bool) -&gt; bool {
    !x
}
</code></pre>
<p>如果我們使用沒有實作 <code>Copy</code> trait 的型別，我們將會得到編譯錯誤，因為我們試圖使用一個被移動的值。</p>
<pre><code class="language-text">error: use of moved value: `a`
println!(&quot;{}&quot;, a);
               ^
</code></pre>
<p>我們將在 <a href="traits.html">traits</a> 章節討論如何撰寫你自己型別的 <code>Copy</code>。</p>
<h2>所有權以外 (More than ownership)</h2>
<p>當然，如果我們必須在每個函式都交還所有權：</p>
<pre><code class="language-rust">fn foo(v: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    // do stuff with v

    // hand back ownership
    v
}
</code></pre>
<p>這將會非常煩人。
當我們想處理更多所有權的時候會變得更糟：</p>
<pre><code class="language-rust">fn foo(v1: Vec&lt;i32&gt;, v2: Vec&lt;i32&gt;) -&gt; (Vec&lt;i32&gt;, Vec&lt;i32&gt;, i32) {
    // do stuff with v1 and v2

    // hand back ownership, and the result of our function
    (v1, v2, 42)
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];

let (v1, v2, answer) = foo(v1, v2);
</code></pre>
<p>呃！
回傳型別、回傳的那行程式碼、和呼叫函式都變得更複雜了。</p>
<p>幸運的是，Rust 提供一個功能，借用 (borrowing)，可以幫助我們解決這個問題。
這就是下一節的主題！</p>
<blockquote>
<p><em>commit 145190b</em></p>
</blockquote>
<h1>參照與借用</h1>
<p>本指南是當前 Rust 的三個所有權系統之一。
這是 Rust 最獨特且引人注目的功能之一，作為 Rust 的開發者應該對此要有相當的了解。
所有權是 Rust 用來達成其最大的目標，記憶體安全，的方法。
它有一些不同的概念，各自有各自的章節：</p>
<ul>
<li><a href="ownership.html">所有權</a> (ownership)，關鍵的概念</li>
<li>借用 (borrowing)，你正在閱讀的章節</li>
<li><a href="lifetimes.html">生命週期</a> (lifetime)，借用的進階概念</li>
</ul>
<p>這三章依序相關。
你需要了解全部三章來完整了解所有權系統。</p>
<h2>Meta</h2>
<p>在我們開始細述前，有兩個所有權系統的重點。</p>
<p>Rust 注重安全和速度。
它透過許多 &quot;零成本抽象化&quot; 的方式去實現目標，也就是 Rust 將盡可能縮小抽象化成本去達成目標。
所有權系統是零成本抽象化的一個最佳範例。
我們在本指南中談到的所有分析，都是在 <em>編譯期完成的</em>。
這些功能不需要花費你任何執行期的成本。</p>
<p>然而，這套系統仍有某些成本：學習曲線。
許多 Rust 的新使用者會經歷我們所說的 &quot;與借用檢查器 (borrow checker) 戰鬥&quot; 的經驗，也就是 Rust 編譯器無法編譯一個作者認為合理的程式。
在程式設計師內心的所有權運作模型與實際上 Rust 實作不相符的時候，這會常常發生。
一開始你可能也會經歷類似的事情。
然而有個好消息：許多有經驗的 Rust 開發者回報，當他們適應所有權系統的規則一陣子之後，他們跟借用檢查器的戰鬥就越來越少了。</p>
<p>記住這些之後，讓我們開始學習借用。</p>
<h2>借用 (Borrowing)</h2>
<p>在<a href="ownership.html">所有權</a>一節的最後，我們提到一個看起來頗糟的函式：</p>
<pre><code class="language-rust">fn foo(v1: Vec&lt;i32&gt;, v2: Vec&lt;i32&gt;) -&gt; (Vec&lt;i32&gt;, Vec&lt;i32&gt;, i32) {
    // do stuff with v1 and v2

    // hand back ownership, and the result of our function
    (v1, v2, 42)
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];

let (v1, v2, answer) = foo(v1, v2);
</code></pre>
<p>這不符合 Rust 的語言習慣，因為它沒有利用到借用的優點。
以下是第一步：</p>
<pre><code class="language-rust">fn foo(v1: &amp;Vec&lt;i32&gt;, v2: &amp;Vec&lt;i32&gt;) -&gt; i32 {
    // do stuff with v1 and v2

    // return the answer
    42
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];

let answer = foo(&amp;v1, &amp;v2);

// we can use v1 and v2 here!
</code></pre>
<p>與其把 <code>Vec&lt;i32&gt;</code> 作為我們的參數，不如使用參照 (reference)：<code>&amp;Vec&lt;i32&gt;</code>。
而且不要直接傳遞 <code>v1</code> 與 <code>v2</code>，我們傳遞 <code>&amp;v1</code> 與 <code>&amp;v2</code>。
我們把 <code>&amp;T</code> 型別稱為 &quot;參照&quot; (reference)，它借用了所有權，而非掌握所有權。
一個借用東西的綁定不會在離開有效範圍時釋放資源。
這代表在呼叫 <code>foo()</code> 完之後，我們仍可以再度使用我們原始的綁定。</p>
<p>跟綁定一樣，參照是不可變的 (immutable)。
這意味著在 <code>foo()</code> 內，向量完全不能更改：</p>
<pre><code class="language-rust,ignore">fn foo(v: &amp;Vec&lt;i32&gt;) {
     v.push(5);
}

let v = vec![];

foo(&amp;v);
</code></pre>
<p>出現以下錯誤：</p>
<pre><code class="language-text">error: cannot borrow immutable borrowed content `*v` as mutable
v.push(5);
^
</code></pre>
<p>因為放入一個值會改變向量，所以我們不允許這樣做。</p>
<h2>&amp;mut 參照</h2>
<p>還有第二類的參照：<code>&amp;mut T</code>。
一個 &quot;可變的參照&quot; 允許你改變你所借用的資源。
例如：</p>
<pre><code class="language-rust">let mut x = 5;
{
    let y = &amp;mut x;
    *y += 1;
}
println!(&quot;{}&quot;, x);
</code></pre>
<p>這將會印出 <code>6</code>。
我們將 <code>y</code> 作為一個指到 <code>x</code> 的可變參照，然後對 <code>y</code> 指向的東西加一。
你將注意到 <code>x</code> 也必須被標註為 <code>mut</code>。
如果不是的話，我們將無法建立一個可變得借用到一個不可變的值。</p>
<blockquote>
<p>譯註：如果 <code>x</code> 不是 <code>mut</code>，會得到 <code>error: cannot borrow immutable local variable</code>x<code>as mutable</code> 錯誤訊息。</p>
</blockquote>
<p>你同時也會發現我們在 <code>y</code> 前面加上星號（<code>*</code>）成為 <code>*y</code>，這是因為 <code>y</code> 是一個 <code>&amp;mut</code> 參照，
你需要使用它們去存取參照的內容。</p>
<p>此外，<code>&amp;mut</code> 參照如同一般的參照。它們兩者和它們的互動方式 <em>有著</em> 巨大的區別。
你可以說以上的範例有點不可靠，因為我們需要額外的 <code>{</code> 和 <code>}</code> 定義有效區域。
如果移除它們，我們會得到錯誤訊息：</p>
<pre><code class="language-text">error: cannot borrow `x` as immutable because it is also borrowed as mutable
    println!(&quot;{}&quot;, x);
                   ^
note: previous borrow of `x` occurs here; the mutable borrow prevents
subsequent moves, borrows, or modification of `x` until the borrow ends
        let y = &amp;mut x;
                     ^
note: previous borrow ends here
fn main() {

}
^
</code></pre>
<p>事實證明如此，所以以下是一些規則。</p>
<h2>規則</h2>
<p>以下是 Rust 中關於借用 (borrowing) 的規則：</p>
<p>首先，任何借用的有效範圍都必須比擁有者的有效範圍還要小。
其次，你可以使用以下兩種借用，但是不能同時使用兩者：</p>
<ul>
<li>一到多個對資源的參照（<code>&amp;T</code>）</li>
<li>唯一一個可變參照（<code>&amp;mut T</code>）</li>
</ul>
<p>你可能有注意到有點類似、但不完全相同於資料競爭的定義：</p>
<blockquote>
<p>當兩個或多個指標同時存取相同的記憶體，其中至少有一個正在寫入，且操作沒有同步時，會出現 &quot;資料競爭&quot; (date race)。</p>
</blockquote>
<p>使用參照時，你可以想要多少參照就用多少參照，因為它們沒有人在寫入。
然而，一次只能擁有一個 <code>&amp;mut</code>，這才不會產生資料競爭。
這就是 Rust 如何在編譯期預防資料競爭：當我們違反規則時，會得到錯誤訊息。</p>
<p>記住這些之後，讓我們再次想想我們的範例。</p>
<h3>對有效範圍的深思 (Thinking in scopes)</h3>
<p>以下是程式碼：</p>
<pre><code class="language-rust,ignore">let mut x = 5;
let y = &amp;mut x;

*y += 1;

println!(&quot;{}&quot;, x);
</code></pre>
<p>這段程式碼會有這些錯誤訊息：</p>
<pre><code class="language-text">error: cannot borrow `x` as immutable because it is also borrowed as mutable
    println!(&quot;{}&quot;, x);
                   ^
</code></pre>
<blockquote>
<p>譯註：此處 <code>println!()</code> 試圖借用 <code>x</code>。</p>
</blockquote>
<p>這是因為我們違反了規則：我們有了一個指向 <code>x</code> 的 <code>&amp;mut T</code>，所以我們不允許建立任何其他 <code>&amp;T</code>。
要在兩者間做出選擇。
錯誤中的註解提示我們該如何思考這個問題：</p>
<pre><code class="language-text">note: previous borrow ends here
fn main() {

}
^
</code></pre>
<p>換句話說，可變借用 (mutable borrow) 在我們的範例中一直存在。
所以我們希望可變借用能在我們呼叫 <code>println!</code> 並建立不可變借用 <em>之前</em> 能結束掉。
在 Rust 中，借用綁定在借用有效的範圍中。
我們的有效範圍看起來會像這樣：</p>
<pre><code class="language-rust,ignore">let mut x = 5;

let y = &amp;mut x;    // -+ &amp;mut borrow of x starts here
                   //  |
*y += 1;           //  |
                   //  |
println!(&quot;{}&quot;, x); // -+ - try to borrow x here
                   // -+ &amp;mut borrow of x ends here
</code></pre>
<p>這些有效範圍有衝突：我們不能在 <code>y</code> 仍在有效範圍時建立 <code>&amp;x</code>。</p>
<p>而當我們增加大括號之後：</p>
<pre><code class="language-rust">let mut x = 5;

{
    let y = &amp;mut x; // -+ &amp;mut borrow starts here
    *y += 1;        //  |
}                   // -+ ... and ends here

println!(&quot;{}&quot;, x);  // &lt;- try to borrow x here
</code></pre>
<p>這樣就沒有問題了。
我們的可變借用會在我們建立不可變借用前離開有效範圍。
有效範圍是個看清借用持續多久的關鍵。</p>
<h3>借用所預防的問題 (Issues borrowing prevents)</h3>
<p>為何我們需要這些限制規則？
好吧，如同我們所說的，這些規則避免資料競爭。
資料競爭會引發哪些問題？
以下是一些例子。</p>
<h4>疊代器失效</h4>
<p>一個例子是 &quot;疊代器失效&quot; (Iterator invalidation)，當你試圖改變一個正在疊代的集合 (collection) 時會發生。
Rust 的借用檢查器會預防這件事發生：</p>
<pre><code class="language-rust">let mut v = vec![1, 2, 3];

for i in &amp;v {
    println!(&quot;{}&quot;, i);
}
</code></pre>
<p>這會印出一到三。
當我們疊代這個向量時，我們只會用到元素的參照。
而且 <code>v</code> 是一個不可變的借用，所以我們在疊代時不能更改它：</p>
<pre><code class="language-rust,ignore">let mut v = vec![1, 2, 3];

for i in &amp;v {
    println!(&quot;{}&quot;, i);
    v.push(34);
}
</code></pre>
<p>以下是錯誤訊息：</p>
<pre><code class="language-text">error: cannot borrow `v` as mutable because it is also borrowed as immutable
    v.push(34);
    ^
note: previous borrow of `v` occurs here; the immutable borrow prevents
subsequent moves or mutable borrows of `v` until the borrow ends
for i in &amp;v {
          ^
note: previous borrow ends here
for i in &amp;v {
    println!(“{}”, i);
    v.push(34);
}
^
</code></pre>
<p>我們不能修改 <code>v</code>，因為它已經借用給迴圈了。</p>
<h4>在釋放之後使用 (use after free)</h4>
<p>參照不能存活得比所參考的資源還久。
Rust 會檢查你的參照的有效範圍來確保符合這個條件。</p>
<p>如果 Rust 沒有檢查這個屬性，我們可能會意外地用到一個無效的參照。
例如：</p>
<pre><code class="language-rust,ignore">let y: &amp;i32;
{
    let x = 5;
    y = &amp;x;
}

println!(&quot;{}&quot;, y);
</code></pre>
<p>會得到以下錯誤：</p>
<pre><code class="language-text">error: `x` does not live long enough
    y = &amp;x;
         ^
note: reference must be valid for the block suffix following statement 0 at
2:16...
let y: &amp;i32;
{
    let x = 5;
    y = &amp;x;
}

note: ...but borrowed value is only valid for the block suffix following
statement 0 at 4:18
    let x = 5;
    y = &amp;x;
}
</code></pre>
<p>換句話說，<code>y</code> 只在 <code>x</code> 存在的有效範圍內有效。
當 <code>x</code> 消失，它就成為無效的參照。
這個錯誤訊息說，這個借用 &quot;存在得不夠久&quot; 就是因為它在應該存在的時候已經失效了。</p>
<p>當一個參照在它所參考的變數 <em>之前</em> 宣告，也會發生一樣的問題。
這是因為資源在同樣的有效範圍內，它們被釋放的順序是跟它們宣告順序相反：</p>
<blockquote>
<p>譯註：也就是 <code>宣告 y; 宣告 x;</code> 的話，離開有效範圍時會 <code>釋放 x; 釋放 y</code>。所以 <code>y</code> 比 <code>x</code> 存活的久。</p>
</blockquote>
<pre><code class="language-rust,ignore">let y: &amp;i32;
let x = 5;
y = &amp;x;

println!(&quot;{}&quot;, y);
</code></pre>
<p>得到以下錯誤訊息：</p>
<pre><code class="language-text">error: `x` does not live long enough
y = &amp;x;
     ^
note: reference must be valid for the block suffix following statement 0 at
2:16...
    let y: &amp;i32;
    let x = 5;
    y = &amp;x;

    println!(&quot;{}&quot;, y);
}

note: ...but borrowed value is only valid for the block suffix following
statement 1 at 3:14
    let x = 5;
    y = &amp;x;

    println!(&quot;{}&quot;, y);
}
</code></pre>
<p>在以上範例，<code>y</code> 在 <code>x</code> 之前宣告，代表 <code>y</code> 存活的比 <code>x</code> 還長，這不被允許。</p>
<blockquote>
<p><em>commit 6ba9520</em></p>
</blockquote>
<h1>生命週期</h1>
<p>本指南是當前 Rust 的三個所有權系統之一。
這是 Rust 最獨特且引人注目的功能之一，作為 Rust 的開發者應該對此要有相當的了解。
所有權是 Rust 用來達成其最大的目標，記憶體安全，的方法。
它有一些不同的概念，各自有各自的章節：</p>
<ul>
<li><a href="ownership.html">所有權</a> (ownership)，關鍵的概念</li>
<li><a href="references-and-borrowing.html">借用</a> (borrowing)，及其相關功能 &quot;參照&quot; (references)</li>
<li>生命週期 (lifetimes)，你正在閱讀的章節</li>
</ul>
<p>這三章依序相關。
你需要了解全部三章來完整了解所有權系統。</p>
<h2>Meta</h2>
<p>在我們開始細述前，有兩個所有權系統的重點。</p>
<p>Rust 注重安全和速度。
它透過許多 &quot;零成本抽象化&quot; 的方式去實現目標，也就是 Rust 將盡可能縮小抽象化成本去達成目標。
所有權系統是零成本抽象化的一個最佳範例。
我們在本指南中談到的所有分析，都是在 <em>編譯期完成的</em>。
這些功能不需要花費你任何執行期的成本。</p>
<p>然而，這套系統仍有某些成本：學習曲線。
許多 Rust 的新使用者會經歷我們所說的 &quot;與借用檢查器 (borrow checker) 戰鬥&quot; 的經驗，也就是 Rust 編譯器無法編譯一個作者認為合理的程式。
在程式設計師內心的所有權運作模型與實際上 Rust 實作不相符的時候，這會常常發生。
一開始你可能也會經歷類似的事情。
然而有個好消息：許多有經驗的 Rust 開發者回報，當他們適應所有權系統的規則一陣子之後，他們跟借用檢查器的戰鬥就越來越少了。</p>
<p>記住這些之後，讓我們開始學習生命週期。</p>
<h2>生命週期 (Lifetimes)</h2>
<p>出借一個指向他人擁有的資源的參照是很複雜的。
舉例來說，想像一下以下的操作行為：</p>
<ol>
<li>我獲得一個某種資源的控制代碼 (handle)。</li>
<li>我把指向這個資源的參照借給你。</li>
<li>我決定不再使用這個資源，釋放它，但你仍還有你那邊的參照。</li>
<li>你決定要使用此資源。</li>
</ol>
<p>噢！你的參照指向了一個無效的資源。
如果資源是記憶體時，我們叫它迷途指標 (dangling pointer) 或 &quot;釋放後的使用&quot;。</p>
<p>要修正這個問題，我們必須確保上述第四步不會在第三步之後發生。
Rust 的所有權系統透過一個叫做生命週期 (lifetimes) 的概念達成這點，它會描述參照的有效範圍。</p>
<p>當我們有一個函式透過參數取用了一個參照，我們可以不言明 (implicit) 或言明 (explicit) 參照的生命週期：</p>
<pre><code class="language-rust">// implicit
fn foo(x: &amp;i32) {
}

// explicit
fn bar&lt;'a&gt;(x: &amp;'a i32) {
}
</code></pre>
<p><code>'a</code> 唸作 &quot;生命週期 a&quot;。
技術上，所有參照都有關聯的生命週期，但是編譯器通常讓你可以省略它（參考後述的 <a href="#%E7%94%9F%E5%91%BD%E9%80%B1%E6%9C%9F%E7%9C%81%E7%95%A5%20(Lifetime%20Elision)">&quot;生命週期省略&quot;</a>）。
在我們講到省略之前，先讓我們拆解言明生命週期的範例：</p>
<pre><code class="language-rust,ignore">fn bar&lt;'a&gt;(...)
</code></pre>
<p>我們之前談到了一些<a href="functions.html">函式語法</a>，但我們沒有討論到函式後面的 <code>&lt;&gt;</code>。
一個函式可以在 <code>&lt;&gt;</code> 間放入 &quot;泛型參數&quot; (generic parameters)，生命週期也是其中一種。
我們<a href="generics.html">在之後</a>會討論到其他的泛型，但現在讓我們專注在生命週期方面。</p>
<p>我們使用 <code>&lt;&gt;</code> 去宣告我們的生命週期。
這代表 <code>bar</code> 有一個生命週期 <code>'a</code>。
如果我們有兩個參照參數，那麼將會看起來像：</p>
<pre><code class="language-rust,ignore">fn bar&lt;'a, 'b&gt;(...)
</code></pre>
<p>然後在我們的參數列表中，我們使用我們所命名的生命週期：</p>
<pre><code class="language-rust,ignore">...(x: &amp;'a i32)
</code></pre>
<p>如果我們想要一個 <code>&amp;mut</code> 參照，這樣做：
I</p>
<pre><code class="language-rust,ignore">...(x: &amp;'a mut i32)
</code></pre>
<p>如果你比較 <code>&amp;mut i32</code> 和 <code>&amp;'a mut i32</code> 兩者，除了在 <code>&amp;</code> 和 <code>mut i32</code> 間多出生命週期 <code>'a</code>，你會發現他們是一樣的。
我們把 <code>&amp;mut i32</code> 叫做 &quot;一個 <code>i32</code> 可變參照&quot;，而 <code>&amp;'a mut i32</code> 叫做 &quot;一個生命週期為 <code>'a</code> 的 <code>i32</code> 可變參照&quot;</p>
<h2>在 <code>struct</code> 中</h2>
<p>當處理含有參照的<a href="structs.html">結構體</a> (struct) 食，你也同樣需要言明生命週期：</p>
<pre><code class="language-rust">struct Foo&lt;'a&gt; {
    x: &amp;'a i32,
}

fn main() {
    let y = &amp;5; // this is the same as `let _y = 5; let y = &amp;_y;`
    let f = Foo { x: y };

    println!(&quot;{}&quot;, f.x);
}
</code></pre>
<p>如你所見，<code>struct</code> 也有生命週期。
它的表示方式跟函式很像：</p>
<pre><code class="language-rust">struct Foo&lt;'a&gt; {
# x: &amp;'a i32,
# }
</code></pre>
<p>宣告生命週期，接著：</p>
<pre><code class="language-rust"># struct Foo&lt;'a&gt; {
x: &amp;'a i32,
# }
</code></pre>
<p>使用生命週期。
那為何我們在此處需要生命週期呢？
因為我們必須確保任何參考到 <code>Foo</code> 的參照不能存活的比 <code>Foo</code> 所內含的 <code>i32</code> 參照還久。</p>
<blockquote>
<p>譯註：簡單說，如果 <code>Foo</code> 內的 <code>i32</code> 參照失效後，如果仍有指向 <code>Foo</code> 的參照，取用此參照內的 <code>i32</code> 參照就會出問題。</p>
</blockquote>
<h3><code>impl</code> 區塊</h3>
<p>讓我們替 <code>Foo</code> 實作一個方法：</p>
<pre><code class="language-rust">struct Foo&lt;'a&gt; {
    x: &amp;'a i32,
}

impl&lt;'a&gt; Foo&lt;'a&gt; {
    fn x(&amp;self) -&gt; &amp;'a i32 { self.x }
}

fn main() {
    let y = &amp;5; // this is the same as `let _y = 5; let y = &amp;_y;`
    let f = Foo { x: y };

    println!(&quot;x is: {}&quot;, f.x());
}
</code></pre>
<p>如你所見，我們需要在 <code>impl</code> 那行宣告 <code>Foo</code> 的生命週期。
我們重複了 <code>'a</code> 兩次，跟函式一樣：<code>impl&lt;'a&gt;</code> 定義了生命週期 <code>'a</code>，而 <code>Foo&lt;'a&gt;</code> 則使用它。</p>
<h3>多重生命週期</h3>
<p>如果你有多個參照，你可以重複使用相同的生命週期：</p>
<pre><code class="language-rust">fn x_or_y&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
#    x
# }
</code></pre>
<p>這代表 <code>x</code> 和 <code>y</code> 都存活在同樣的有效範圍內，且回傳值也存活在同樣的有效範圍。
如果你想要讓 <code>x</code> 和 <code>y</code> 有不同的生命週期，你可以使用多個生命週期參數：</p>
<pre><code class="language-rust">fn x_or_y&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;'a str {
#    x
# }
</code></pre>
<p>在此範例中，<code>x</code> 與 <code>y</code> 有不同的有效範圍，但回傳值的生命週期與 <code>x</code> 相同。</p>
<h3>對有效範圍的深思 (Thinking in scopes)</h3>
<p>瞭解生命週期的一個方式是將參照的有效範圍視覺化。
例如：</p>
<pre><code class="language-rust">fn main() {
    let y = &amp;5;     // -+ y goes into scope
                    //  |
    // stuff        //  |
                    //  |
}                   // -+ y goes out of scope
</code></pre>
<p>加入 <code>Foo</code>：</p>
<pre><code class="language-rust">struct Foo&lt;'a&gt; {
    x: &amp;'a i32,
}

fn main() {
    let y = &amp;5;           // -+ y goes into scope
    let f = Foo { x: y }; // -+ f goes into scope
    // stuff              //  |
                          //  |
}                         // -+ f and y go out of scope
</code></pre>
<p><code>f</code> 存活在 <code>y</code> 的有效範圍內，所以一切運作正常。
但如果不是（在有效範圍內）呢？
以下程式碼無法運作：</p>
<pre><code class="language-rust,ignore">struct Foo&lt;'a&gt; {
    x: &amp;'a i32,
}

fn main() {
    let x;                    // -+ x goes into scope
                              //  |
    {                         //  |
        let y = &amp;5;           // ---+ y goes into scope
        let f = Foo { x: y }; // ---+ f goes into scope
        x = &amp;f.x;             //  | | error here
    }                         // ---+ f and y go out of scope
                              //  |
    println!(&quot;{}&quot;, x);        //  |
}                             // -+ x goes out of scope
</code></pre>
<p>唷！如你所見，<code>f</code> 和 <code>y</code> 的有效範圍比 <code>x</code> 的有效範圍小。
但是當我們執行 <code>x = &amp;f.x</code> 時，我們會使 <code>x</code> 參考到已經離開有效範圍的東西。</p>
<p>命名生命週期是給予有效範圍名稱的方式。
賦予東西一個名稱，是開始討論它的第一步。</p>
<h3>'static</h3>
<p>名稱叫做 <code>static</code> 的生命週期是特殊的生命週期。
它代表了某樣東西具有整個程式的生命週期。
大多數 Rust 程式設計師會在處理字串時第一次遇到 <code>'static</code>：</p>
<pre><code class="language-rust">let x: &amp;'static str = &quot;Hello, world.&quot;;
</code></pre>
<p>字串是 <code>&amp;'static str</code> 型別，因為參照一直存活著：他們被放在最後的執行檔內的資料區段。
另一個例子是全域變數：</p>
<pre><code class="language-rust">static FOO: i32 = 5;
let x: &amp;'static i32 = &amp;FOO;
</code></pre>
<p>這會加入一個 <code>i32</code> 到執行檔的資料區段，<code>x</code> 則是指向它的參照。</p>
<h3>生命週期省略 (Lifetime Elision)</h3>
<p>Rust 在函式中支援強大的局部型別推斷 (local type inference)，但在 item signatures 中則被禁止，才能讓它根據簽署去推論其型別。
然而，為了人機工程的理由，第二種受限的推斷方式 &quot;生命週期省略&quot; 被允許用在函式的簽署。
它只根據簽署元件本身推斷，而不基於函式內容，而且只根據三個簡單易記、不易混淆的規則推斷生命週期參數。
這使得撰寫 item signatures 時可以速寫生命週期省略，但不能隱藏它的實際型別，因為局部型別推斷時可能會需要它。</p>
<blockquote>
<p>譯註：<code>item signatures</code> 應是指宣告函式時的輸入參數們，以及回傳值的宣告。</p>
</blockquote>
<p>當我們談到生命週期省略，我們使用 <em>輸入生命週期</em> (input lifetime) 與 <em>輸出生命週期</em> (output lifetime) 的字眼。
<em>輸入生命週期</em> 是指函式的參數的生命週期，而 <em>輸出生命週期</em> 是指函式回傳值的生命週期。
例如，以下函式有一個輸入生命週期：</p>
<pre><code class="language-rust,ignore">fn foo&lt;'a&gt;(bar: &amp;'a str)
</code></pre>
<p>此函式則有一個輸出生命週期：</p>
<pre><code class="language-rust,ignore">fn foo&lt;'a&gt;() -&gt; &amp;'a str
</code></pre>
<p>此一函式兩者皆有：</p>
<pre><code class="language-rust,ignore">fn foo&lt;'a&gt;(bar: &amp;'a str) -&gt; &amp;'a str
</code></pre>
<p>以下是三條規則：</p>
<ul>
<li>每個函式的參數所省略的生命週期都成為個別不同的生命週期參數。</li>
<li>如果恰好只有一個輸入生命週期，無論省略與否，其生命週期會被賦予所有回傳值中所省略的生命週期。</li>
<li>如果有多個輸入生命週期，但其中有 <code>&amp;self</code> 或 <code>&amp;mut self</code>，那 <code>self</code> 的生命週期會被賦予所有省略的生命週期。</li>
</ul>
<p>否則，省略輸入生命週期會出現錯誤訊息。</p>
<h4>範例</h4>
<p>以下有一些省略生命週期的函式範例。
我們把省略的範例與其展開生命週期的樣子，各別放在一起比對。</p>
<pre><code class="language-rust,ignore">fn print(s: &amp;str); // elided
fn print&lt;'a&gt;(s: &amp;'a str); // expanded

fn debug(lvl: u32, s: &amp;str); // elided
fn debug&lt;'a&gt;(lvl: u32, s: &amp;'a str); // expanded

// In the preceding example, `lvl` doesn’t need a lifetime because it’s not a
// reference (`&amp;`). Only things relating to references (such as a `struct`
// which contains a reference) need lifetimes.

fn substr(s: &amp;str, until: u32) -&gt; &amp;str; // elided
fn substr&lt;'a&gt;(s: &amp;'a str, until: u32) -&gt; &amp;'a str; // expanded

fn get_str() -&gt; &amp;str; // ILLEGAL, no inputs

fn frob(s: &amp;str, t: &amp;str) -&gt; &amp;str; // ILLEGAL, two inputs
fn frob&lt;'a, 'b&gt;(s: &amp;'a str, t: &amp;'b str) -&gt; &amp;str; // Expanded: Output lifetime is ambiguous

fn get_mut(&amp;mut self) -&gt; &amp;mut T; // elided
fn get_mut&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a mut T; // expanded

fn args&lt;T: ToCStr&gt;(&amp;mut self, args: &amp;[T]) -&gt; &amp;mut Command; // elided
fn args&lt;'a, 'b, T: ToCStr&gt;(&amp;'a mut self, args: &amp;'b [T]) -&gt; &amp;'a mut Command; // expanded

fn new(buf: &amp;mut [u8]) -&gt; BufWriter; // elided
fn new&lt;'a&gt;(buf: &amp;'a mut [u8]) -&gt; BufWriter&lt;'a&gt;; // expanded
</code></pre>
<blockquote>
<p><em>commit f4fac9b</em></p>
</blockquote>
<p>% Mutability</p>
<p>Mutability, the ability to change something, works a bit differently in Rust
than in other languages. The first aspect of mutability is its non-default
status:</p>
<pre><code class="language-rust,ignore">let x = 5;
x = 6; // error!
</code></pre>
<p>We can introduce mutability with the <code>mut</code> keyword:</p>
<pre><code class="language-rust">let mut x = 5;

x = 6; // no problem!
</code></pre>
<p>This is a mutable <a href="variable-bindings.html">variable binding</a>. When a binding is mutable, it means
you’re allowed to change what the binding points to. So in the above example,
it’s not so much that the value at <code>x</code> is changing, but that the binding
changed from one <code>i32</code> to another.</p>
<p>If you want to change what the binding points to, you’ll need a <a href="references-and-borrowing.html">mutable reference</a>:</p>
<pre><code class="language-rust">let mut x = 5;
let y = &amp;mut x;
</code></pre>
<p><code>y</code> is an immutable binding to a mutable reference, which means that you can’t
bind <code>y</code> to something else (<code>y = &amp;mut z</code>), but you can mutate the thing that’s
bound to <code>y</code> (<code>*y = 5</code>). A subtle distinction.</p>
<p>Of course, if you need both:</p>
<pre><code class="language-rust">let mut x = 5;
let mut y = &amp;mut x;
</code></pre>
<p>Now <code>y</code> can be bound to another value, and the value it’s referencing can be
changed.</p>
<p>It’s important to note that <code>mut</code> is part of a <a href="patterns.html">pattern</a>, so you
can do things like this:</p>
<pre><code class="language-rust">let (mut x, y) = (5, 6);

fn foo(mut x: i32) {
# }
</code></pre>
<h1>Interior vs. Exterior Mutability</h1>
<p>However, when we say something is ‘immutable’ in Rust, that doesn’t mean that
it’s not able to be changed: we mean something has ‘exterior mutability’. Consider,
for example, [<code>Arc&lt;T&gt;</code>]<a href="../std/sync/struct.Arc.html">arc</a>:</p>
<pre><code class="language-rust">use std::sync::Arc;

let x = Arc::new(5);
let y = x.clone();
</code></pre>
<p>When we call <code>clone()</code>, the <code>Arc&lt;T&gt;</code> needs to update the reference count. Yet
we’ve not used any <code>mut</code>s here, <code>x</code> is an immutable binding, and we didn’t take
<code>&amp;mut 5</code> or anything. So what gives?</p>
<p>To understand this, we have to go back to the core of Rust’s guiding
philosophy, memory safety, and the mechanism by which Rust guarantees it, the
<a href="ownership.html">ownership</a> system, and more specifically, <a href="references-and-borrowing.html#borrowing">borrowing</a>:</p>
<blockquote>
<p>You may have one or the other of these two kinds of borrows, but not both at
the same time:</p>
<ul>
<li>one or more references (<code>&amp;T</code>) to a resource,</li>
<li>exactly one mutable reference (<code>&amp;mut T</code>).</li>
</ul>
</blockquote>
<p>So, that’s the real definition of ‘immutability’: is this safe to have two
pointers to? In <code>Arc&lt;T&gt;</code>’s case, yes: the mutation is entirely contained inside
the structure itself. It’s not user facing. For this reason, it hands out <code>&amp;T</code>
with <code>clone()</code>. If it handed out <code>&amp;mut T</code>s, though, that would be a problem.</p>
<p>Other types, like the ones in the [<code>std::cell</code>]<a href="../std/cell/index.html">stdcell</a> module, have the
opposite: interior mutability. For example:</p>
<pre><code class="language-rust">use std::cell::RefCell;

let x = RefCell::new(42);

let y = x.borrow_mut();
</code></pre>
<p>RefCell hands out <code>&amp;mut</code> references to what’s inside of it with the
<code>borrow_mut()</code> method. Isn’t that dangerous? What if we do:</p>
<pre><code class="language-rust,ignore">use std::cell::RefCell;

let x = RefCell::new(42);

let y = x.borrow_mut();
let z = x.borrow_mut();
# (y, z);
</code></pre>
<p>This will in fact panic, at runtime. This is what <code>RefCell</code> does: it enforces
Rust’s borrowing rules at runtime, and <code>panic!</code>s if they’re violated. This
allows us to get around another aspect of Rust’s mutability rules. Let’s talk
about it first.</p>
<h2>Field-level mutability</h2>
<p>Mutability is a property of either a borrow (<code>&amp;mut</code>) or a binding (<code>let mut</code>).
This means that, for example, you cannot have a [<code>struct</code>]<a href="structs.html">struct</a> with
some fields mutable and some immutable:</p>
<pre><code class="language-rust,ignore">struct Point {
    x: i32,
    mut y: i32, // nope
}
</code></pre>
<p>The mutability of a struct is in its binding:</p>
<pre><code class="language-rust,ignore">struct Point {
    x: i32,
    y: i32,
}

let mut a = Point { x: 5, y: 6 };

a.x = 10;

let b = Point { x: 5, y: 6};

b.x = 10; // error: cannot assign to immutable field `b.x`
</code></pre>
<p>However, by using [<code>Cell&lt;T&gt;</code>]<a href="../std/cell/struct.Cell.html">cell</a>, you can emulate field-level mutability:</p>
<pre><code class="language-rust">use std::cell::Cell;

struct Point {
    x: i32,
    y: Cell&lt;i32&gt;,
}

let point = Point { x: 5, y: Cell::new(6) };

point.y.set(7);

println!(&quot;y: {:?}&quot;, point.y);
</code></pre>
<p>This will print <code>y: Cell { value: 7 }</code>. We’ve successfully updated <code>y</code>.</p>
<blockquote>
<p><em>commit 024aa9a</em></p>
</blockquote>
<p>% Structs</p>
<p><code>struct</code>s are a way of creating more complex data types. For example, if we were
doing calculations involving coordinates in 2D space, we would need both an <code>x</code>
and a <code>y</code> value:</p>
<pre><code class="language-rust">let origin_x = 0;
let origin_y = 0;
</code></pre>
<p>A <code>struct</code> lets us combine these two into a single, unified datatype with <code>x</code>
and <code>y</code> as field labels:</p>
<pre><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let origin = Point { x: 0, y: 0 }; // origin: Point

    println!(&quot;The origin is at ({}, {})&quot;, origin.x, origin.y);
}
</code></pre>
<p>There’s a lot going on here, so let’s break it down. We declare a <code>struct</code> with
the <code>struct</code> keyword, and then with a name. By convention, <code>struct</code>s begin with
a capital letter and are camel cased: <code>PointInSpace</code>, not <code>Point_In_Space</code>.</p>
<p>We can create an instance of our <code>struct</code> via <code>let</code>, as usual, but we use a <code>key: value</code> style syntax to set each field. The order doesn’t need to be the same as
in the original declaration.</p>
<p>Finally, because fields have names, we can access them through dot
notation: <code>origin.x</code>.</p>
<p>The values in <code>struct</code>s are immutable by default, like other bindings in Rust.
Use <code>mut</code> to make them mutable:</p>
<pre><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let mut point = Point { x: 0, y: 0 };

    point.x = 5;

    println!(&quot;The point is at ({}, {})&quot;, point.x, point.y);
}
</code></pre>
<p>This will print <code>The point is at (5, 0)</code>.</p>
<p>Rust does not support field mutability at the language level, so you cannot
write something like this:</p>
<pre><code class="language-rust,ignore">struct Point {
    mut x: i32,
    y: i32,
}
</code></pre>
<p>Mutability is a property of the binding, not of the structure itself. If you’re
used to field-level mutability, this may seem strange at first, but it
significantly simplifies things. It even lets you make things mutable on a temporary
basis:</p>
<pre><code class="language-rust,ignore">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let mut point = Point { x: 0, y: 0 };

    point.x = 5;

    let point = point; // now immutable

    point.y = 6; // this causes an error
}
</code></pre>
<p>Your structure can still contain <code>&amp;mut</code> pointers, which will let
you do some kinds of mutation:</p>
<pre><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

struct PointRef&lt;'a&gt; {
    x: &amp;'a mut i32,
    y: &amp;'a mut i32,
}

fn main() {
    let mut point = Point { x: 0, y: 0 };

    {
        let r = PointRef { x: &amp;mut point.x, y: &amp;mut point.y };

        *r.x = 5;
        *r.y = 6;
    }

    assert_eq!(5, point.x);
    assert_eq!(6, point.y);
}
</code></pre>
<h1>Update syntax</h1>
<p>A <code>struct</code> can include <code>..</code> to indicate that you want to use a copy of some
other <code>struct</code> for some of the values. For example:</p>
<pre><code class="language-rust">struct Point3d {
    x: i32,
    y: i32,
    z: i32,
}

let mut point = Point3d { x: 0, y: 0, z: 0 };
point = Point3d { y: 1, .. point };
</code></pre>
<p>This gives <code>point</code> a new <code>y</code>, but keeps the old <code>x</code> and <code>z</code> values. It doesn’t
have to be the same <code>struct</code> either, you can use this syntax when making new
ones, and it will copy the values you don’t specify:</p>
<pre><code class="language-rust"># struct Point3d {
#     x: i32,
#     y: i32,
#     z: i32,
# }
let origin = Point3d { x: 0, y: 0, z: 0 };
let point = Point3d { z: 1, x: 2, .. origin };
</code></pre>
<h1>Tuple structs</h1>
<p>Rust has another data type that’s like a hybrid between a <a href="primitive-types.html#tuples">tuple</a> and a
<code>struct</code>, called a ‘tuple struct’. Tuple structs have a name, but their fields
don't. They are declared with the <code>struct</code> keyword, and then with a name
followed by a tuple:</p>
<pre><code class="language-rust">struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
</code></pre>
<p>Here, <code>black</code> and <code>origin</code> are not equal, even though they contain the same
values.</p>
<p>It is almost always better to use a <code>struct</code> than a tuple struct. We
would write <code>Color</code> and <code>Point</code> like this instead:</p>
<pre><code class="language-rust">struct Color {
    red: i32,
    blue: i32,
    green: i32,
}

struct Point {
    x: i32,
    y: i32,
    z: i32,
}
</code></pre>
<p>Good names are important, and while values in a tuple struct can be
referenced with dot notation as well, a <code>struct</code> gives us actual names,
rather than positions.</p>
<p>There <em>is</em> one case when a tuple struct is very useful, though, and that is when
it has only one element. We call this the ‘newtype’ pattern, because
it allows you to create a new type that is distinct from its contained value
and also expresses its own semantic meaning:</p>
<pre><code class="language-rust">struct Inches(i32);

let length = Inches(10);

let Inches(integer_length) = length;
println!(&quot;length is {} inches&quot;, integer_length);
</code></pre>
<p>As you can see here, you can extract the inner integer type through a
destructuring <code>let</code>, as with regular tuples. In this case, the
<code>let Inches(integer_length)</code> assigns <code>10</code> to <code>integer_length</code>.</p>
<h1>Unit-like structs</h1>
<p>You can define a <code>struct</code> with no members at all:</p>
<pre><code class="language-rust">struct Electron;

let x = Electron;
</code></pre>
<p>Such a <code>struct</code> is called ‘unit-like’ because it resembles the empty
tuple, <code>()</code>, sometimes called ‘unit’. Like a tuple struct, it defines a
new type.</p>
<p>This is rarely useful on its own (although sometimes it can serve as a
marker type), but in combination with other features, it can become
useful. For instance, a library may ask you to create a structure that
implements a certain <a href="traits.html">trait</a> to handle events. If you don’t have
any data you need to store in the structure, you can create a
unit-like <code>struct</code>.</p>
<blockquote>
<p><em>commit 6ba9520</em></p>
</blockquote>
<p>% Enums</p>
<p>An <code>enum</code> in Rust is a type that represents data that is one of
several possible variants. Each variant in the <code>enum</code> can optionally
have data associated with it:</p>
<pre><code class="language-rust">enum Message {
    Quit,
    ChangeColor(i32, i32, i32),
    Move { x: i32, y: i32 },
    Write(String),
}
</code></pre>
<p>The syntax for defining variants resembles the syntaxes used to define structs:
you can have variants with no data (like unit-like structs), variants with named
data, and variants with unnamed data (like tuple structs). Unlike
separate struct definitions, however, an <code>enum</code> is a single type. A
value of the enum can match any of the variants. For this reason, an
enum is sometimes called a ‘sum type’: the set of possible values of the
enum is the sum of the sets of possible values for each variant.</p>
<p>We use the <code>::</code> syntax to use the name of each variant: they’re scoped by the name
of the <code>enum</code> itself. This allows both of these to work:</p>
<pre><code class="language-rust"># enum Message {
#     Move { x: i32, y: i32 },
# }
let x: Message = Message::Move { x: 3, y: 4 };

enum BoardGameTurn {
    Move { squares: i32 },
    Pass,
}

let y: BoardGameTurn = BoardGameTurn::Move { squares: 1 };
</code></pre>
<p>Both variants are named <code>Move</code>, but since they’re scoped to the name of
the enum, they can both be used without conflict.</p>
<p>A value of an <code>enum</code> type contains information about which variant it is,
in addition to any data associated with that variant. This is sometimes
referred to as a ‘tagged union’, since the data includes a ‘tag’
indicating what type it is. The compiler uses this information to
enforce that you’re accessing the data in the enum safely. For instance,
you can’t simply try to destructure a value as if it were one of the
possible variants:</p>
<pre><code class="language-rust,ignore">fn process_color_change(msg: Message) {
    let Message::ChangeColor(r, g, b) = msg; // compile-time error
}
</code></pre>
<p>Not supporting these operations may seem rather limiting, but it’s a limitation
which we can overcome. There are two ways: by implementing equality ourselves,
or by pattern matching variants with [<code>match</code>]<a href="match.html">match</a> expressions, which you’ll
learn in the next section. We don’t know enough about Rust to implement
equality yet, but we’ll find out in the [<code>traits</code>]<a href="traits.html">traits</a> section.</p>
<h1>Constructors as functions</h1>
<p>An <code>enum</code> constructor can also be used like a function. For example:</p>
<pre><code class="language-rust"># enum Message {
# Write(String),
# }
let m = Message::Write(&quot;Hello, world&quot;.to_string());
</code></pre>
<p>is the same as</p>
<pre><code class="language-rust"># enum Message {
# Write(String),
# }
fn foo(x: String) -&gt; Message {
    Message::Write(x)
}

let x = foo(&quot;Hello, world&quot;.to_string());
</code></pre>
<p>This is not immediately useful to us, but when we get to
[<code>closures</code>]<a href="closures.html">closures</a>, we’ll talk about passing functions as arguments to
other functions. For example, with [<code>iterators</code>]<a href="iterators.html">iterators</a>, we can do this
to convert a vector of <code>String</code>s into a vector of <code>Message::Write</code>s:</p>
<pre><code class="language-rust"># enum Message {
# Write(String),
# }

let v = vec![&quot;Hello&quot;.to_string(), &quot;World&quot;.to_string()];

let v1: Vec&lt;Message&gt; = v.into_iter().map(Message::Write).collect();
</code></pre>
<blockquote>
<p><em>commit 31e39cd</em></p>
</blockquote>
<p>% Match</p>
<p>Often, a simple [<code>if</code>]<a href="if.html">if</a>/<code>else</code> isn’t enough, because you have more than two
possible options. Also, conditions can get quite complex. Rust
has a keyword, <code>match</code>, that allows you to replace complicated <code>if</code>/<code>else</code>
groupings with something more powerful. Check it out:</p>
<pre><code class="language-rust">let x = 5;

match x {
    1 =&gt; println!(&quot;one&quot;),
    2 =&gt; println!(&quot;two&quot;),
    3 =&gt; println!(&quot;three&quot;),
    4 =&gt; println!(&quot;four&quot;),
    5 =&gt; println!(&quot;five&quot;),
    _ =&gt; println!(&quot;something else&quot;),
}
</code></pre>
<p><code>match</code> takes an expression and then branches based on its value. Each ‘arm’ of
the branch is of the form <code>val =&gt; expression</code>. When the value matches, that arm’s
expression will be evaluated. It’s called <code>match</code> because of the term ‘pattern
matching’, which <code>match</code> is an implementation of. There’s a <a href="patterns.html">separate section on
patterns</a> that covers all the patterns that are possible here.</p>
<p>One of the many advantages of <code>match</code> is it enforces ‘exhaustiveness checking’.
For example if we remove the last arm with the underscore <code>_</code>, the compiler will
give us an error:</p>
<pre><code class="language-text">error: non-exhaustive patterns: `_` not covered
</code></pre>
<p>Rust is telling us that we forgot a value. The compiler infers from <code>x</code> that it
can have any positive 32bit value; for example 1 to 2,147,483,647. The <code>_</code> acts
as a 'catch-all', and will catch all possible values that <em>aren't</em> specified in
an arm of <code>match</code>. As you can see with the previous example, we provide <code>match</code>
arms for integers 1-5, if <code>x</code> is 6 or any other value, then it is caught by <code>_</code>.</p>
<p><code>match</code> is also an expression, which means we can use it on the right-hand
side of a <code>let</code> binding or directly where an expression is used:</p>
<pre><code class="language-rust">let x = 5;

let number = match x {
    1 =&gt; &quot;one&quot;,
    2 =&gt; &quot;two&quot;,
    3 =&gt; &quot;three&quot;,
    4 =&gt; &quot;four&quot;,
    5 =&gt; &quot;five&quot;,
    _ =&gt; &quot;something else&quot;,
};
</code></pre>
<p>Sometimes it’s a nice way of converting something from one type to another; in
this example the integers are converted to <code>String</code>.</p>
<h1>Matching on enums</h1>
<p>Another important use of the <code>match</code> keyword is to process the possible
variants of an enum:</p>
<pre><code class="language-rust">enum Message {
    Quit,
    ChangeColor(i32, i32, i32),
    Move { x: i32, y: i32 },
    Write(String),
}

fn quit() { /* ... */ }
fn change_color(r: i32, g: i32, b: i32) { /* ... */ }
fn move_cursor(x: i32, y: i32) { /* ... */ }

fn process_message(msg: Message) {
    match msg {
        Message::Quit =&gt; quit(),
        Message::ChangeColor(r, g, b) =&gt; change_color(r, g, b),
        Message::Move { x: x, y: y } =&gt; move_cursor(x, y),
        Message::Write(s) =&gt; println!(&quot;{}&quot;, s),
    };
}
</code></pre>
<p>Again, the Rust compiler checks exhaustiveness, so it demands that you
have a match arm for every variant of the enum. If you leave one off, it
will give you a compile-time error unless you use <code>_</code> or provide all possible
arms.</p>
<p>Unlike the previous uses of <code>match</code>, you can’t use the normal <code>if</code>
statement to do this. You can use the [<code>if let</code>]<a href="if-let.html">if-let</a> statement,
which can be seen as an abbreviated form of <code>match</code>.</p>
<blockquote>
<p><em>commit fc4bb5f</em></p>
</blockquote>
<p>% Patterns</p>
<p>Patterns are quite common in Rust. We use them in <a href="variable-bindings.html">variable
bindings</a>, <a href="match.html">match statements</a>, and other places, too. Let’s go
on a whirlwind tour of all of the things patterns can do!</p>
<p>A quick refresher: you can match against literals directly, and <code>_</code> acts as an
‘any’ case:</p>
<pre><code class="language-rust">let x = 1;

match x {
    1 =&gt; println!(&quot;one&quot;),
    2 =&gt; println!(&quot;two&quot;),
    3 =&gt; println!(&quot;three&quot;),
    _ =&gt; println!(&quot;anything&quot;),
}
</code></pre>
<p>This prints <code>one</code>.</p>
<p>There’s one pitfall with patterns: like anything that introduces a new binding,
they introduce shadowing. For example:</p>
<pre><code class="language-rust">let x = 1;
let c = 'c';

match c {
    x =&gt; println!(&quot;x: {} c: {}&quot;, x, c),
}

println!(&quot;x: {}&quot;, x)
</code></pre>
<p>This prints:</p>
<pre><code class="language-text">x: c c: c
x: 1
</code></pre>
<p>In other words, <code>x =&gt;</code> matches the pattern and introduces a new binding named
<code>x</code>. This new binding is in scope for the match arm and takes on the value of
<code>c</code>. Notice that the value of <code>x</code> outside the scope of the match has no bearing
on the value of <code>x</code> within it. Because we already have a binding named <code>x</code>, this
new <code>x</code> shadows it.</p>
<h1>Multiple patterns</h1>
<p>You can match multiple patterns with <code>|</code>:</p>
<pre><code class="language-rust">let x = 1;

match x {
    1 | 2 =&gt; println!(&quot;one or two&quot;),
    3 =&gt; println!(&quot;three&quot;),
    _ =&gt; println!(&quot;anything&quot;),
}
</code></pre>
<p>This prints <code>one or two</code>.</p>
<h1>Destructuring</h1>
<p>If you have a compound data type, like a [<code>struct</code>]<a href="structs.html">struct</a>, you can destructure it
inside of a pattern:</p>
<pre><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

match origin {
    Point { x, y } =&gt; println!(&quot;({},{})&quot;, x, y),
}
</code></pre>
<p>We can use <code>:</code> to give a value a different name.</p>
<pre><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

match origin {
    Point { x: x1, y: y1 } =&gt; println!(&quot;({},{})&quot;, x1, y1),
}
</code></pre>
<p>If we only care about some of the values, we don’t have to give them all names:</p>
<pre><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

match origin {
    Point { x, .. } =&gt; println!(&quot;x is {}&quot;, x),
}
</code></pre>
<p>This prints <code>x is 0</code>.</p>
<p>You can do this kind of match on any member, not only the first:</p>
<pre><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

match origin {
    Point { y, .. } =&gt; println!(&quot;y is {}&quot;, y),
}
</code></pre>
<p>This prints <code>y is 0</code>.</p>
<p>This ‘destructuring’ behavior works on any compound data type, like
<a href="primitive-types.html#tuples">tuples</a> or <a href="enums.html">enums</a>.</p>
<h1>Ignoring bindings</h1>
<p>You can use <code>_</code> in a pattern to disregard the type and value.
For example, here’s a <code>match</code> against a <code>Result&lt;T, E&gt;</code>:</p>
<pre><code class="language-rust"># let some_value: Result&lt;i32, &amp;'static str&gt; = Err(&quot;There was an error&quot;);
match some_value {
    Ok(value) =&gt; println!(&quot;got a value: {}&quot;, value),
    Err(_) =&gt; println!(&quot;an error occurred&quot;),
}
</code></pre>
<p>In the first arm, we bind the value inside the <code>Ok</code> variant to <code>value</code>. But
in the <code>Err</code> arm, we use <code>_</code> to disregard the specific error, and print
a general error message.</p>
<p><code>_</code> is valid in any pattern that creates a binding. This can be useful to
ignore parts of a larger structure:</p>
<pre><code class="language-rust">fn coordinate() -&gt; (i32, i32, i32) {
    // generate and return some sort of triple tuple
# (1, 2, 3)
}

let (x, _, z) = coordinate();
</code></pre>
<p>Here, we bind the first and last element of the tuple to <code>x</code> and <code>z</code>, but
ignore the middle element.</p>
<p>It’s worth noting that using <code>_</code> never binds the value in the first place,
which means a value may not move:</p>
<pre><code class="language-rust">let tuple: (u32, String) = (5, String::from(&quot;five&quot;));

// Here, tuple is moved, because the String moved:
let (x, _s) = tuple;

// The next line would give &quot;error: use of partially moved value: `tuple`&quot;
// println!(&quot;Tuple is: {:?}&quot;, tuple);

// However,

let tuple = (5, String::from(&quot;five&quot;));

// Here, tuple is _not_ moved, as the String was never moved, and u32 is Copy:
let (x, _) = tuple;

// That means this works:
println!(&quot;Tuple is: {:?}&quot;, tuple);
</code></pre>
<p>This also means that any temporary variables will be dropped at the end of the
statement:</p>
<pre><code class="language-rust">// Here, the String created will be dropped immediately, as it’s not bound:

let _ = String::from(&quot;  hello  &quot;).trim();
</code></pre>
<p>You can also use <code>..</code> in a pattern to disregard multiple values:</p>
<pre><code class="language-rust">enum OptionalTuple {
    Value(i32, i32, i32),
    Missing,
}

let x = OptionalTuple::Value(5, -2, 3);

match x {
    OptionalTuple::Value(..) =&gt; println!(&quot;Got a tuple!&quot;),
    OptionalTuple::Missing =&gt; println!(&quot;No such luck.&quot;),
}
</code></pre>
<p>This prints <code>Got a tuple!</code>.</p>
<h1>ref and ref mut</h1>
<p>If you want to get a <a href="references-and-borrowing.html">reference</a>, use the <code>ref</code> keyword:</p>
<pre><code class="language-rust">let x = 5;

match x {
    ref r =&gt; println!(&quot;Got a reference to {}&quot;, r),
}
</code></pre>
<p>This prints <code>Got a reference to 5</code>.</p>
<p>Here, the <code>r</code> inside the <code>match</code> has the type <code>&amp;i32</code>. In other words, the <code>ref</code>
keyword <em>creates</em> a reference, for use in the pattern. If you need a mutable
reference, <code>ref mut</code> will work in the same way:</p>
<pre><code class="language-rust">let mut x = 5;

match x {
    ref mut mr =&gt; println!(&quot;Got a mutable reference to {}&quot;, mr),
}
</code></pre>
<h1>Ranges</h1>
<p>You can match a range of values with <code>...</code>:</p>
<pre><code class="language-rust">let x = 1;

match x {
    1 ... 5 =&gt; println!(&quot;one through five&quot;),
    _ =&gt; println!(&quot;anything&quot;),
}
</code></pre>
<p>This prints <code>one through five</code>.</p>
<p>Ranges are mostly used with integers and <code>char</code>s:</p>
<pre><code class="language-rust">let x = '💅';

match x {
    'a' ... 'j' =&gt; println!(&quot;early letter&quot;),
    'k' ... 'z' =&gt; println!(&quot;late letter&quot;),
    _ =&gt; println!(&quot;something else&quot;),
}
</code></pre>
<p>This prints <code>something else</code>.</p>
<h1>Bindings</h1>
<p>You can bind values to names with <code>@</code>:</p>
<pre><code class="language-rust">let x = 1;

match x {
    e @ 1 ... 5 =&gt; println!(&quot;got a range element {}&quot;, e),
    _ =&gt; println!(&quot;anything&quot;),
}
</code></pre>
<p>This prints <code>got a range element 1</code>. This is useful when you want to
do a complicated match of part of a data structure:</p>
<pre><code class="language-rust">#[derive(Debug)]
struct Person {
    name: Option&lt;String&gt;,
}

let name = &quot;Steve&quot;.to_string();
let x: Option&lt;Person&gt; = Some(Person { name: Some(name) });
match x {
    Some(Person { name: ref a @ Some(_), .. }) =&gt; println!(&quot;{:?}&quot;, a),
    _ =&gt; {}
}
</code></pre>
<p>This prints <code>Some(&quot;Steve&quot;)</code>: we’ve bound the inner <code>name</code> to <code>a</code>.</p>
<p>If you use <code>@</code> with <code>|</code>, you need to make sure the name is bound in each part
of the pattern:</p>
<pre><code class="language-rust">let x = 5;

match x {
    e @ 1 ... 5 | e @ 8 ... 10 =&gt; println!(&quot;got a range element {}&quot;, e),
    _ =&gt; println!(&quot;anything&quot;),
}
</code></pre>
<h1>Guards</h1>
<p>You can introduce ‘match guards’ with <code>if</code>:</p>
<pre><code class="language-rust">enum OptionalInt {
    Value(i32),
    Missing,
}

let x = OptionalInt::Value(5);

match x {
    OptionalInt::Value(i) if i &gt; 5 =&gt; println!(&quot;Got an int bigger than five!&quot;),
    OptionalInt::Value(..) =&gt; println!(&quot;Got an int!&quot;),
    OptionalInt::Missing =&gt; println!(&quot;No such luck.&quot;),
}
</code></pre>
<p>This prints <code>Got an int!</code>.</p>
<p>If you’re using <code>if</code> with multiple patterns, the <code>if</code> applies to both sides:</p>
<pre><code class="language-rust">let x = 4;
let y = false;

match x {
    4 | 5 if y =&gt; println!(&quot;yes&quot;),
    _ =&gt; println!(&quot;no&quot;),
}
</code></pre>
<p>This prints <code>no</code>, because the <code>if</code> applies to the whole of <code>4 | 5</code>, and not to
only the <code>5</code>. In other words, the precedence of <code>if</code> behaves like this:</p>
<pre><code class="language-text">(4 | 5) if y =&gt; ...
</code></pre>
<p>not this:</p>
<pre><code class="language-text">4 | (5 if y) =&gt; ...
</code></pre>
<h1>Mix and Match</h1>
<p>Whew! That’s a lot of different ways to match things, and they can all be
mixed and matched, depending on what you’re doing:</p>
<pre><code class="language-rust,ignore">match x {
    Foo { x: Some(ref name), y: None } =&gt; ...
}
</code></pre>
<p>Patterns are very powerful. Make good use of them.</p>
<blockquote>
<p><em>commit b49ce1a</em></p>
</blockquote>
<p>% Method Syntax</p>
<p>Functions are great, but if you want to call a bunch of them on some data, it
can be awkward. Consider this code:</p>
<pre><code class="language-rust,ignore">baz(bar(foo));
</code></pre>
<p>We would read this left-to-right, and so we see ‘baz bar foo’. But this isn’t the
order that the functions would get called in, that’s inside-out: ‘foo bar baz’.
Wouldn’t it be nice if we could do this instead?</p>
<pre><code class="language-rust,ignore">foo.bar().baz();
</code></pre>
<p>Luckily, as you may have guessed with the leading question, you can! Rust provides
the ability to use this ‘method call syntax’ via the <code>impl</code> keyword.</p>
<h1>Method calls</h1>
<p>Here’s how it works:</p>
<pre><code class="language-rust">struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    fn area(&amp;self) -&gt; f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}

fn main() {
    let c = Circle { x: 0.0, y: 0.0, radius: 2.0 };
    println!(&quot;{}&quot;, c.area());
}
</code></pre>
<p>This will print <code>12.566371</code>.</p>
<p>We’ve made a <code>struct</code> that represents a circle. We then write an <code>impl</code> block,
and inside it, define a method, <code>area</code>.</p>
<p>Methods take a special first parameter, of which there are three variants:
<code>self</code>, <code>&amp;self</code>, and <code>&amp;mut self</code>. You can think of this first parameter as
being the <code>foo</code> in <code>foo.bar()</code>. The three variants correspond to the three
kinds of things <code>foo</code> could be: <code>self</code> if it’s a value on the stack,
<code>&amp;self</code> if it’s a reference, and <code>&amp;mut self</code> if it’s a mutable reference.
Because we took the <code>&amp;self</code> parameter to <code>area</code>, we can use it like any
other parameter. Because we know it’s a <code>Circle</code>, we can access the <code>radius</code>
like we would with any other <code>struct</code>.</p>
<p>We should default to using <code>&amp;self</code>, as you should prefer borrowing over taking
ownership, as well as taking immutable references over mutable ones. Here’s an
example of all three variants:</p>
<pre><code class="language-rust">struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    fn reference(&amp;self) {
       println!(&quot;taking self by reference!&quot;);
    }

    fn mutable_reference(&amp;mut self) {
       println!(&quot;taking self by mutable reference!&quot;);
    }

    fn takes_ownership(self) {
       println!(&quot;taking ownership of self!&quot;);
    }
}
</code></pre>
<p>You can use as many <code>impl</code> blocks as you’d like. The previous example could
have also been written like this:</p>
<pre><code class="language-rust">struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    fn reference(&amp;self) {
       println!(&quot;taking self by reference!&quot;);
    }
}

impl Circle {
    fn mutable_reference(&amp;mut self) {
       println!(&quot;taking self by mutable reference!&quot;);
    }
}

impl Circle {
    fn takes_ownership(self) {
       println!(&quot;taking ownership of self!&quot;);
    }
}
</code></pre>
<h1>Chaining method calls</h1>
<p>So, now we know how to call a method, such as <code>foo.bar()</code>. But what about our
original example, <code>foo.bar().baz()</code>? This is called ‘method chaining’. Let’s
look at an example:</p>
<pre><code class="language-rust">struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    fn area(&amp;self) -&gt; f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }

    fn grow(&amp;self, increment: f64) -&gt; Circle {
        Circle { x: self.x, y: self.y, radius: self.radius + increment }
    }
}

fn main() {
    let c = Circle { x: 0.0, y: 0.0, radius: 2.0 };
    println!(&quot;{}&quot;, c.area());

    let d = c.grow(2.0).area();
    println!(&quot;{}&quot;, d);
}
</code></pre>
<p>Check the return type:</p>
<pre><code class="language-rust"># struct Circle;
# impl Circle {
fn grow(&amp;self, increment: f64) -&gt; Circle {
# Circle } }
</code></pre>
<p>We say we’re returning a <code>Circle</code>. With this method, we can grow a new
<code>Circle</code> to any arbitrary size.</p>
<h1>Associated functions</h1>
<p>You can also define associated functions that do not take a <code>self</code> parameter.
Here’s a pattern that’s very common in Rust code:</p>
<pre><code class="language-rust">struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    fn new(x: f64, y: f64, radius: f64) -&gt; Circle {
        Circle {
            x: x,
            y: y,
            radius: radius,
        }
    }
}

fn main() {
    let c = Circle::new(0.0, 0.0, 2.0);
}
</code></pre>
<p>This ‘associated function’ builds a new <code>Circle</code> for us. Note that associated
functions are called with the <code>Struct::function()</code> syntax, rather than the
<code>ref.method()</code> syntax. Some other languages call associated functions ‘static
methods’.</p>
<h1>Builder Pattern</h1>
<p>Let’s say that we want our users to be able to create <code>Circle</code>s, but we will
allow them to only set the properties they care about. Otherwise, the <code>x</code>
and <code>y</code> attributes will be <code>0.0</code>, and the <code>radius</code> will be <code>1.0</code>. Rust doesn’t
have method overloading, named arguments, or variable arguments. We employ
the builder pattern instead. It looks like this:</p>
<pre><code class="language-rust">struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    fn area(&amp;self) -&gt; f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}

struct CircleBuilder {
    x: f64,
    y: f64,
    radius: f64,
}

impl CircleBuilder {
    fn new() -&gt; CircleBuilder {
        CircleBuilder { x: 0.0, y: 0.0, radius: 1.0, }
    }

    fn x(&amp;mut self, coordinate: f64) -&gt; &amp;mut CircleBuilder {
        self.x = coordinate;
        self
    }

    fn y(&amp;mut self, coordinate: f64) -&gt; &amp;mut CircleBuilder {
        self.y = coordinate;
        self
    }

    fn radius(&amp;mut self, radius: f64) -&gt; &amp;mut CircleBuilder {
        self.radius = radius;
        self
    }

    fn finalize(&amp;self) -&gt; Circle {
        Circle { x: self.x, y: self.y, radius: self.radius }
    }
}

fn main() {
    let c = CircleBuilder::new()
                .x(1.0)
                .y(2.0)
                .radius(2.0)
                .finalize();

    println!(&quot;area: {}&quot;, c.area());
    println!(&quot;x: {}&quot;, c.x);
    println!(&quot;y: {}&quot;, c.y);
}
</code></pre>
<p>What we’ve done here is make another <code>struct</code>, <code>CircleBuilder</code>. We’ve defined our
builder methods on it. We’ve also defined our <code>area()</code> method on <code>Circle</code>. We
also made one more method on <code>CircleBuilder</code>: <code>finalize()</code>. This method creates
our final <code>Circle</code> from the builder. Now, we’ve used the type system to enforce
our concerns: we can use the methods on <code>CircleBuilder</code> to constrain making
<code>Circle</code>s in any way we choose.</p>
<blockquote>
<p><em>commit 6ba9520</em></p>
</blockquote>
<p>% Vectors</p>
<p>A ‘vector’ is a dynamic or ‘growable’ array, implemented as the standard
library type [<code>Vec&lt;T&gt;</code>]<a href="../std/vec/index.html">vec</a>. The <code>T</code> means that we can have vectors
of any type (see the chapter on <a href="generics.html">generics</a> for more).
Vectors always allocate their data on the heap.
You can create them with the <code>vec!</code> macro:</p>
<pre><code class="language-rust">let v = vec![1, 2, 3, 4, 5]; // v: Vec&lt;i32&gt;
</code></pre>
<p>(Notice that unlike the <code>println!</code> macro we’ve used in the past, we use square
brackets <code>[]</code> with <code>vec!</code> macro. Rust allows you to use either in either
situation, this is just convention.)</p>
<p>There’s an alternate form of <code>vec!</code> for repeating an initial value:</p>
<pre><code class="language-rust">let v = vec![0; 10]; // ten zeroes
</code></pre>
<p>Vectors store their contents as contiguous arrays of <code>T</code> on the heap. This means
that they must be able to know the size of <code>T</code> at compile time (that is, how
many bytes are needed to store a <code>T</code>?). The size of some things can't be known
at compile time. For these you'll have to store a pointer to that thing:
thankfully, the [<code>Box</code>]<a href="../std/boxed/index.html">box</a> type works perfectly for this.</p>
<h2>Accessing elements</h2>
<p>To get the value at a particular index in the vector, we use <code>[]</code>s:</p>
<pre><code class="language-rust">let v = vec![1, 2, 3, 4, 5];

println!(&quot;The third element of v is {}&quot;, v[2]);
</code></pre>
<p>The indices count from <code>0</code>, so the third element is <code>v[2]</code>.</p>
<p>It’s also important to note that you must index with the <code>usize</code> type:</p>
<pre><code class="language-ignore">let v = vec![1, 2, 3, 4, 5];

let i: usize = 0;
let j: i32 = 0;

// works
v[i];

// doesn’t
v[j];
</code></pre>
<p>Indexing with a non-<code>usize</code> type gives an error that looks like this:</p>
<pre><code class="language-text">error: the trait `core::ops::Index&lt;i32&gt;` is not implemented for the type
`collections::vec::Vec&lt;_&gt;` [E0277]
v[j];
^~~~
note: the type `collections::vec::Vec&lt;_&gt;` cannot be indexed by `i32`
error: aborting due to previous error
</code></pre>
<p>There’s a lot of punctuation in that message, but the core of it makes sense:
you cannot index with an <code>i32</code>.</p>
<h2>Out-of-bounds Access</h2>
<p>If you try to access an index that doesn’t exist:</p>
<pre><code class="language-ignore">let v = vec![1, 2, 3];
println!(&quot;Item 7 is {}&quot;, v[7]);
</code></pre>
<p>then the current thread will <a href="concurrency.html#panics">panic</a> with a message like this:</p>
<pre><code class="language-text">thread '&lt;main&gt;' panicked at 'index out of bounds: the len is 3 but the index is 7'
</code></pre>
<p>If you want to handle out-of-bounds errors without panicking, you can use
methods like [<code>get</code>]<a href="http://doc.rust-lang.org/std/vec/struct.Vec.html#method.get">get</a> or [<code>get_mut</code>]<a href="http://doc.rust-lang.org/std/vec/struct.Vec.html#method.get_mut">get_mut</a> that return <code>None</code> when
given an invalid index:</p>
<pre><code class="language-rust">let v = vec![1, 2, 3];
match v.get(7) {
    Some(x) =&gt; println!(&quot;Item 7 is {}&quot;, x),
    None =&gt; println!(&quot;Sorry, this vector is too short.&quot;)
}
</code></pre>
<h2>Iterating</h2>
<p>Once you have a vector, you can iterate through its elements with <code>for</code>. There
are three versions:</p>
<pre><code class="language-rust">let mut v = vec![1, 2, 3, 4, 5];

for i in &amp;v {
    println!(&quot;A reference to {}&quot;, i);
}

for i in &amp;mut v {
    println!(&quot;A mutable reference to {}&quot;, i);
}

for i in v {
    println!(&quot;Take ownership of the vector and its element {}&quot;, i);
}
</code></pre>
<p>Vectors have many more useful methods, which you can read about in <a href="../std/vec/index.html">their
API documentation</a>.</p>
<blockquote>
<p><em>commit f2bea1c</em></p>
</blockquote>
<p>% Strings</p>
<p>Strings are an important concept for any programmer to master. Rust’s string
handling system is a bit different from other languages, due to its systems
focus. Any time you have a data structure of variable size, things can get
tricky, and strings are a re-sizable data structure. That being said, Rust’s
strings also work differently than in some other systems languages, such as C.</p>
<p>Let’s dig into the details. A ‘string’ is a sequence of Unicode scalar values
encoded as a stream of UTF-8 bytes. All strings are guaranteed to be a valid
encoding of UTF-8 sequences. Additionally, unlike some systems languages,
strings are not null-terminated and can contain null bytes.</p>
<p>Rust has two main types of strings: <code>&amp;str</code> and <code>String</code>. Let’s talk about
<code>&amp;str</code> first. These are called ‘string slices’. A string slice has a fixed
size, and cannot be mutated. It is a reference to a sequence of UTF-8 bytes.</p>
<pre><code class="language-rust">let greeting = &quot;Hello there.&quot;; // greeting: &amp;'static str
</code></pre>
<p><code>&quot;Hello there.&quot;</code> is a string literal and its type is <code>&amp;'static str</code>. A string
literal is a string slice that is statically allocated, meaning that it’s saved
inside our compiled program, and exists for the entire duration it runs. The
<code>greeting</code> binding is a reference to this statically allocated string. Any
function expecting a string slice will also accept a string literal.</p>
<p>String literals can span multiple lines. There are two forms. The first will
include the newline and the leading spaces:</p>
<pre><code class="language-rust">let s = &quot;foo
    bar&quot;;

assert_eq!(&quot;foo\n        bar&quot;, s);
</code></pre>
<p>The second, with a <code>\</code>, trims the spaces and the newline:</p>
<pre><code class="language-rust">let s = &quot;foo\
    bar&quot;;

assert_eq!(&quot;foobar&quot;, s);
</code></pre>
<p>Rust has more than only <code>&amp;str</code>s though. A <code>String</code>, is a heap-allocated string.
This string is growable, and is also guaranteed to be UTF-8. <code>String</code>s are
commonly created by converting from a string slice using the <code>to_string</code>
method.</p>
<pre><code class="language-rust">let mut s = &quot;Hello&quot;.to_string(); // mut s: String
println!(&quot;{}&quot;, s);

s.push_str(&quot;, world.&quot;);
println!(&quot;{}&quot;, s);
</code></pre>
<p><code>String</code>s will coerce into <code>&amp;str</code> with an <code>&amp;</code>:</p>
<pre><code class="language-rust">fn takes_slice(slice: &amp;str) {
    println!(&quot;Got: {}&quot;, slice);
}

fn main() {
    let s = &quot;Hello&quot;.to_string();
    takes_slice(&amp;s);
}
</code></pre>
<p>This coercion does not happen for functions that accept one of <code>&amp;str</code>’s traits
instead of <code>&amp;str</code>. For example, [<code>TcpStream::connect</code>]<a href="../std/net/struct.TcpStream.html#method.connect">connect</a> has a parameter
of type <code>ToSocketAddrs</code>. A <code>&amp;str</code> is okay but a <code>String</code> must be explicitly
converted using <code>&amp;*</code>.</p>
<pre><code class="language-rust,no_run">use std::net::TcpStream;

TcpStream::connect(&quot;192.168.0.1:3000&quot;); // &amp;str parameter

let addr_string = &quot;192.168.0.1:3000&quot;.to_string();
TcpStream::connect(&amp;*addr_string); // convert addr_string to &amp;str
</code></pre>
<p>Viewing a <code>String</code> as a <code>&amp;str</code> is cheap, but converting the <code>&amp;str</code> to a
<code>String</code> involves allocating memory. No reason to do that unless you have to!</p>
<h2>Indexing</h2>
<p>Because strings are valid UTF-8, strings do not support indexing:</p>
<pre><code class="language-rust,ignore">let s = &quot;hello&quot;;

println!(&quot;The first letter of s is {}&quot;, s[0]); // ERROR!!!
</code></pre>
<p>Usually, access to a vector with <code>[]</code> is very fast. But, because each character
in a UTF-8 encoded string can be multiple bytes, you have to walk over the
string to find the nᵗʰ letter of a string. This is a significantly more
expensive operation, and we don’t want to be misleading. Furthermore, ‘letter’
isn’t something defined in Unicode, exactly. We can choose to look at a string as
individual bytes, or as codepoints:</p>
<pre><code class="language-rust">let hachiko = &quot;忠犬ハチ公&quot;;

for b in hachiko.as_bytes() {
    print!(&quot;{}, &quot;, b);
}

println!(&quot;&quot;);

for c in hachiko.chars() {
    print!(&quot;{}, &quot;, c);
}

println!(&quot;&quot;);
</code></pre>
<p>This prints:</p>
<pre><code class="language-text">229, 191, 160, 231, 138, 172, 227, 131, 143, 227, 131, 129, 229, 133, 172,
忠, 犬, ハ, チ, 公,
</code></pre>
<p>As you can see, there are more bytes than <code>char</code>s.</p>
<p>You can get something similar to an index like this:</p>
<pre><code class="language-rust"># let hachiko = &quot;忠犬ハチ公&quot;;
let dog = hachiko.chars().nth(1); // kinda like hachiko[1]
</code></pre>
<p>This emphasizes that we have to walk from the beginning of the list of <code>chars</code>.</p>
<h2>Slicing</h2>
<p>You can get a slice of a string with slicing syntax:</p>
<pre><code class="language-rust">let dog = &quot;hachiko&quot;;
let hachi = &amp;dog[0..5];
</code></pre>
<p>But note that these are <em>byte</em> offsets, not <em>character</em> offsets. So
this will fail at runtime:</p>
<pre><code class="language-rust,should_panic">let dog = &quot;忠犬ハチ公&quot;;
let hachi = &amp;dog[0..2];
</code></pre>
<p>with this error:</p>
<pre><code class="language-text">thread '&lt;main&gt;' panicked at 'index 0 and/or 2 in `忠犬ハチ公` do not lie on
character boundary'
</code></pre>
<h2>Concatenation</h2>
<p>If you have a <code>String</code>, you can concatenate a <code>&amp;str</code> to the end of it:</p>
<pre><code class="language-rust">let hello = &quot;Hello &quot;.to_string();
let world = &quot;world!&quot;;

let hello_world = hello + world;
</code></pre>
<p>But if you have two <code>String</code>s, you need an <code>&amp;</code>:</p>
<pre><code class="language-rust">let hello = &quot;Hello &quot;.to_string();
let world = &quot;world!&quot;.to_string();

let hello_world = hello + &amp;world;
</code></pre>
<p>This is because <code>&amp;String</code> can automatically coerce to a <code>&amp;str</code>. This is a
feature called ‘<a href="deref-coercions.html"><code>Deref</code> coercions</a>’.</p>
<blockquote>
<p><em>commit 310ab5e</em></p>
</blockquote>
<p>% Generics</p>
<p>Sometimes, when writing a function or data type, we may want it to work for
multiple types of arguments. In Rust, we can do this with generics.
Generics are called ‘parametric polymorphism’ in type theory,
which means that they are types or functions that have multiple forms (‘poly’
is multiple, ‘morph’ is form) over a given parameter (‘parametric’).</p>
<p>Anyway, enough type theory, let’s check out some generic code. Rust’s
standard library provides a type, <code>Option&lt;T&gt;</code>, that’s generic:</p>
<pre><code class="language-rust">enum Option&lt;T&gt; {
    Some(T),
    None,
}
</code></pre>
<p>The <code>&lt;T&gt;</code> part, which you’ve seen a few times before, indicates that this is
a generic data type. Inside the declaration of our <code>enum</code>, wherever we see a <code>T</code>,
we substitute that type for the same type used in the generic. Here’s an
example of using <code>Option&lt;T&gt;</code>, with some extra type annotations:</p>
<pre><code class="language-rust">let x: Option&lt;i32&gt; = Some(5);
</code></pre>
<p>In the type declaration, we say <code>Option&lt;i32&gt;</code>. Note how similar this looks to
<code>Option&lt;T&gt;</code>. So, in this particular <code>Option</code>, <code>T</code> has the value of <code>i32</code>. On
the right-hand side of the binding, we make a <code>Some(T)</code>, where <code>T</code> is <code>5</code>.
Since that’s an <code>i32</code>, the two sides match, and Rust is happy. If they didn’t
match, we’d get an error:</p>
<pre><code class="language-rust,ignore">let x: Option&lt;f64&gt; = Some(5);
// error: mismatched types: expected `core::option::Option&lt;f64&gt;`,
// found `core::option::Option&lt;_&gt;` (expected f64 but found integral variable)
</code></pre>
<p>That doesn’t mean we can’t make <code>Option&lt;T&gt;</code>s that hold an <code>f64</code>! They have
to match up:</p>
<pre><code class="language-rust">let x: Option&lt;i32&gt; = Some(5);
let y: Option&lt;f64&gt; = Some(5.0f64);
</code></pre>
<p>This is just fine. One definition, multiple uses.</p>
<p>Generics don’t have to only be generic over one type. Consider another type from Rust’s standard library that’s similar, <code>Result&lt;T, E&gt;</code>:</p>
<pre><code class="language-rust">enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
</code></pre>
<p>This type is generic over <em>two</em> types: <code>T</code> and <code>E</code>. By the way, the capital letters
can be any letter you’d like. We could define <code>Result&lt;T, E&gt;</code> as:</p>
<pre><code class="language-rust">enum Result&lt;A, Z&gt; {
    Ok(A),
    Err(Z),
}
</code></pre>
<p>if we wanted to. Convention says that the first generic parameter should be
<code>T</code>, for ‘type’, and that we use <code>E</code> for ‘error’. Rust doesn’t care, however.</p>
<p>The <code>Result&lt;T, E&gt;</code> type is intended to be used to return the result of a
computation, and to have the ability to return an error if it didn’t work out.</p>
<h2>Generic functions</h2>
<p>We can write functions that take generic types with a similar syntax:</p>
<pre><code class="language-rust">fn takes_anything&lt;T&gt;(x: T) {
    // do something with x
}
</code></pre>
<p>The syntax has two parts: the <code>&lt;T&gt;</code> says “this function is generic over one
type, <code>T</code>”, and the <code>x: T</code> says “x has the type <code>T</code>.”</p>
<p>Multiple arguments can have the same generic type:</p>
<pre><code class="language-rust">fn takes_two_of_the_same_things&lt;T&gt;(x: T, y: T) {
    // ...
}
</code></pre>
<p>We could write a version that takes multiple types:</p>
<pre><code class="language-rust">fn takes_two_things&lt;T, U&gt;(x: T, y: U) {
    // ...
}
</code></pre>
<h2>Generic structs</h2>
<p>You can store a generic type in a <code>struct</code> as well:</p>
<pre><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

let int_origin = Point { x: 0, y: 0 };
let float_origin = Point { x: 0.0, y: 0.0 };
</code></pre>
<p>Similar to functions, the <code>&lt;T&gt;</code> is where we declare the generic parameters,
and we then use <code>x: T</code> in the type declaration, too.</p>
<p>When you want to add an implementation for the generic <code>struct</code>, you
declare the type parameter after the <code>impl</code>:</p>
<pre><code class="language-rust"># struct Point&lt;T&gt; {
#     x: T,
#     y: T,
# }
#
impl&lt;T&gt; Point&lt;T&gt; {
    fn swap(&amp;mut self) {
        std::mem::swap(&amp;mut self.x, &amp;mut self.y);
    }
}
</code></pre>
<p>So far you’ve seen generics that take absolutely any type. These are useful in
many cases: you’ve already seen <code>Option&lt;T&gt;</code>, and later you’ll meet universal
container types like [<code>Vec&lt;T&gt;</code>]<a href="../std/vec/struct.Vec.html">Vec</a>. On the other hand, often you want to
trade that flexibility for increased expressive power. Read about <a href="traits.html">trait
bounds</a> to see why and how.</p>
<blockquote>
<p><em>commit 6ba9520</em></p>
</blockquote>
<p>% Traits</p>
<p>A trait is a language feature that tells the Rust compiler about
functionality a type must provide.</p>
<p>Recall the <code>impl</code> keyword, used to call a function with <a href="method-syntax.html">method
syntax</a>:</p>
<pre><code class="language-rust">struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    fn area(&amp;self) -&gt; f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}
</code></pre>
<p>Traits are similar, except that we first define a trait with a method
signature, then implement the trait for a type. In this example, we implement the trait <code>HasArea</code> for <code>Circle</code>:</p>
<pre><code class="language-rust">struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

trait HasArea {
    fn area(&amp;self) -&gt; f64;
}

impl HasArea for Circle {
    fn area(&amp;self) -&gt; f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}
</code></pre>
<p>As you can see, the <code>trait</code> block looks very similar to the <code>impl</code> block,
but we don’t define a body, only a type signature. When we <code>impl</code> a trait,
we use <code>impl Trait for Item</code>, rather than only <code>impl Item</code>.</p>
<h2>Trait bounds on generic functions</h2>
<p>Traits are useful because they allow a type to make certain promises about its
behavior. Generic functions can exploit this to constrain, or <a href="glossary.html#bounds">bound</a>, the types they
accept. Consider this function, which does not compile:</p>
<pre><code class="language-rust,ignore">fn print_area&lt;T&gt;(shape: T) {
    println!(&quot;This shape has an area of {}&quot;, shape.area());
}
</code></pre>
<p>Rust complains:</p>
<pre><code class="language-text">error: no method named `area` found for type `T` in the current scope
</code></pre>
<p>Because <code>T</code> can be any type, we can’t be sure that it implements the <code>area</code>
method. But we can add a trait bound to our generic <code>T</code>, ensuring
that it does:</p>
<pre><code class="language-rust"># trait HasArea {
#     fn area(&amp;self) -&gt; f64;
# }
fn print_area&lt;T: HasArea&gt;(shape: T) {
    println!(&quot;This shape has an area of {}&quot;, shape.area());
}
</code></pre>
<p>The syntax <code>&lt;T: HasArea&gt;</code> means “any type that implements the <code>HasArea</code> trait.”
Because traits define function type signatures, we can be sure that any type
which implements <code>HasArea</code> will have an <code>.area()</code> method.</p>
<p>Here’s an extended example of how this works:</p>
<pre><code class="language-rust">trait HasArea {
    fn area(&amp;self) -&gt; f64;
}

struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl HasArea for Circle {
    fn area(&amp;self) -&gt; f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}

struct Square {
    x: f64,
    y: f64,
    side: f64,
}

impl HasArea for Square {
    fn area(&amp;self) -&gt; f64 {
        self.side * self.side
    }
}

fn print_area&lt;T: HasArea&gt;(shape: T) {
    println!(&quot;This shape has an area of {}&quot;, shape.area());
}

fn main() {
    let c = Circle {
        x: 0.0f64,
        y: 0.0f64,
        radius: 1.0f64,
    };

    let s = Square {
        x: 0.0f64,
        y: 0.0f64,
        side: 1.0f64,
    };

    print_area(c);
    print_area(s);
}
</code></pre>
<p>This program outputs:</p>
<pre><code class="language-text">This shape has an area of 3.141593
This shape has an area of 1
</code></pre>
<p>As you can see, <code>print_area</code> is now generic, but also ensures that we have
passed in the correct types. If we pass in an incorrect type:</p>
<pre><code class="language-rust,ignore">print_area(5);
</code></pre>
<p>We get a compile-time error:</p>
<pre><code class="language-text">error: the trait `HasArea` is not implemented for the type `_` [E0277]
</code></pre>
<h2>Trait bounds on generic structs</h2>
<p>Your generic structs can also benefit from trait bounds. All you need to
do is append the bound when you declare type parameters. Here is a new
type <code>Rectangle&lt;T&gt;</code> and its operation <code>is_square()</code>:</p>
<pre><code class="language-rust">struct Rectangle&lt;T&gt; {
    x: T,
    y: T,
    width: T,
    height: T,
}

impl&lt;T: PartialEq&gt; Rectangle&lt;T&gt; {
    fn is_square(&amp;self) -&gt; bool {
        self.width == self.height
    }
}

fn main() {
    let mut r = Rectangle {
        x: 0,
        y: 0,
        width: 47,
        height: 47,
    };

    assert!(r.is_square());

    r.height = 42;
    assert!(!r.is_square());
}
</code></pre>
<p><code>is_square()</code> needs to check that the sides are equal, so the sides must be of
a type that implements the [<code>core::cmp::PartialEq</code>]<a href="../core/cmp/trait.PartialEq.html">PartialEq</a> trait:</p>
<pre><code class="language-ignore">impl&lt;T: PartialEq&gt; Rectangle&lt;T&gt; { ... }
</code></pre>
<p>Now, a rectangle can be defined in terms of any type that can be compared for
equality.</p>
<p>Here we defined a new struct <code>Rectangle</code> that accepts numbers of any
precision—really, objects of pretty much any type—as long as they can be
compared for equality. Could we do the same for our <code>HasArea</code> structs, <code>Square</code>
and <code>Circle</code>? Yes, but they need multiplication, and to work with that we need
to know more about <a href="operators-and-overloading.html">operator traits</a>.</p>
<h1>Rules for implementing traits</h1>
<p>So far, we’ve only added trait implementations to structs, but you can
implement a trait for any type. So technically, we <em>could</em> implement <code>HasArea</code>
for <code>i32</code>:</p>
<pre><code class="language-rust">trait HasArea {
    fn area(&amp;self) -&gt; f64;
}

impl HasArea for i32 {
    fn area(&amp;self) -&gt; f64 {
        println!(&quot;this is silly&quot;);

        *self as f64
    }
}

5.area();
</code></pre>
<p>It is considered poor style to implement methods on such primitive types, even
though it is possible.</p>
<p>This may seem like the Wild West, but there are two restrictions around
implementing traits that prevent this from getting out of hand. The first is
that if the trait isn’t defined in your scope, it doesn’t apply. Here’s an
example: the standard library provides a [<code>Write</code>]<a href="../std/io/trait.Write.html">write</a> trait which adds
extra functionality to <code>File</code>s, for doing file I/O. By default, a <code>File</code>
won’t have its methods:</p>
<pre><code class="language-rust,ignore">let mut f = std::fs::File::open(&quot;foo.txt&quot;).expect(&quot;Couldn’t open foo.txt&quot;);
let buf = b&quot;whatever&quot;; // byte string literal. buf: &amp;[u8; 8]
let result = f.write(buf);
# result.unwrap(); // ignore the error
</code></pre>
<p>Here’s the error:</p>
<pre><code class="language-text">error: type `std::fs::File` does not implement any method in scope named `write`
let result = f.write(buf);
               ^~~~~~~~~~
</code></pre>
<p>We need to <code>use</code> the <code>Write</code> trait first:</p>
<pre><code class="language-rust,ignore">use std::io::Write;

let mut f = std::fs::File::open(&quot;foo.txt&quot;).expect(&quot;Couldn’t open foo.txt&quot;);
let buf = b&quot;whatever&quot;;
let result = f.write(buf);
# result.unwrap(); // ignore the error
</code></pre>
<p>This will compile without error.</p>
<p>This means that even if someone does something bad like add methods to <code>i32</code>,
it won’t affect you, unless you <code>use</code> that trait.</p>
<p>There’s one more restriction on implementing traits: either the trait
or the type you’re implementing it for must be defined by you. Or more
precisely, one of them must be defined in the same crate as the <code>impl</code>
you're writing. For more on Rust's module and package system, see the
chapter on <a href="crates-and-modules.html">crates and modules</a>.</p>
<p>So, we could implement the <code>HasArea</code> type for <code>i32</code>, because we defined
<code>HasArea</code> in our code. But if we tried to implement <code>ToString</code>, a trait
provided by Rust, for <code>i32</code>, we could not, because neither the trait nor
the type are defined in our crate.</p>
<p>One last thing about traits: generic functions with a trait bound use
‘monomorphization’ (mono: one, morph: form), so they are statically dispatched.
What’s that mean? Check out the chapter on <a href="trait-objects.html">trait objects</a> for more details.</p>
<h1>Multiple trait bounds</h1>
<p>You’ve seen that you can bound a generic type parameter with a trait:</p>
<pre><code class="language-rust">fn foo&lt;T: Clone&gt;(x: T) {
    x.clone();
}
</code></pre>
<p>If you need more than one bound, you can use <code>+</code>:</p>
<pre><code class="language-rust">use std::fmt::Debug;

fn foo&lt;T: Clone + Debug&gt;(x: T) {
    x.clone();
    println!(&quot;{:?}&quot;, x);
}
</code></pre>
<p><code>T</code> now needs to be both <code>Clone</code> as well as <code>Debug</code>.</p>
<h1>Where clause</h1>
<p>Writing functions with only a few generic types and a small number of trait
bounds isn’t too bad, but as the number increases, the syntax gets increasingly
awkward:</p>
<pre><code class="language-rust">use std::fmt::Debug;

fn foo&lt;T: Clone, K: Clone + Debug&gt;(x: T, y: K) {
    x.clone();
    y.clone();
    println!(&quot;{:?}&quot;, y);
}
</code></pre>
<p>The name of the function is on the far left, and the parameter list is on the
far right. The bounds are getting in the way.</p>
<p>Rust has a solution, and it’s called a ‘<code>where</code> clause’:</p>
<pre><code class="language-rust">use std::fmt::Debug;

fn foo&lt;T: Clone, K: Clone + Debug&gt;(x: T, y: K) {
    x.clone();
    y.clone();
    println!(&quot;{:?}&quot;, y);
}

fn bar&lt;T, K&gt;(x: T, y: K) where T: Clone, K: Clone + Debug {
    x.clone();
    y.clone();
    println!(&quot;{:?}&quot;, y);
}

fn main() {
    foo(&quot;Hello&quot;, &quot;world&quot;);
    bar(&quot;Hello&quot;, &quot;world&quot;);
}
</code></pre>
<p><code>foo()</code> uses the syntax we showed earlier, and <code>bar()</code> uses a <code>where</code> clause.
All you need to do is leave off the bounds when defining your type parameters,
and then add <code>where</code> after the parameter list. For longer lists, whitespace can
be added:</p>
<pre><code class="language-rust">use std::fmt::Debug;

fn bar&lt;T, K&gt;(x: T, y: K)
    where T: Clone,
          K: Clone + Debug {

    x.clone();
    y.clone();
    println!(&quot;{:?}&quot;, y);
}
</code></pre>
<p>This flexibility can add clarity in complex situations.</p>
<p><code>where</code> is also more powerful than the simpler syntax. For example:</p>
<pre><code class="language-rust">trait ConvertTo&lt;Output&gt; {
    fn convert(&amp;self) -&gt; Output;
}

impl ConvertTo&lt;i64&gt; for i32 {
    fn convert(&amp;self) -&gt; i64 { *self as i64 }
}

// can be called with T == i32
fn normal&lt;T: ConvertTo&lt;i64&gt;&gt;(x: &amp;T) -&gt; i64 {
    x.convert()
}

// can be called with T == i64
fn inverse&lt;T&gt;() -&gt; T
        // this is using ConvertTo as if it were &quot;ConvertTo&lt;i64&gt;&quot;
        where i32: ConvertTo&lt;T&gt; {
    42.convert()
}
</code></pre>
<p>This shows off the additional feature of <code>where</code> clauses: they allow bounds
on the left-hand side not only of type parameters <code>T</code>, but also of types (<code>i32</code> in this case). In this example, <code>i32</code> must implement
<code>ConvertTo&lt;T&gt;</code>. Rather than defining what <code>i32</code> is (since that's obvious), the
<code>where</code> clause here constrains <code>T</code>.</p>
<h1>Default methods</h1>
<p>A default method can be added to a trait definition if it is already known how a typical implementor will define a method. For example, <code>is_invalid()</code> is defined as the opposite of <code>is_valid()</code>:</p>
<pre><code class="language-rust">trait Foo {
    fn is_valid(&amp;self) -&gt; bool;

    fn is_invalid(&amp;self) -&gt; bool { !self.is_valid() }
}
</code></pre>
<p>Implementors of the <code>Foo</code> trait need to implement <code>is_valid()</code> but not <code>is_invalid()</code> due to the added default behavior. This default behavior can still be overridden as in:</p>
<pre><code class="language-rust"># trait Foo {
#     fn is_valid(&amp;self) -&gt; bool;
#
#     fn is_invalid(&amp;self) -&gt; bool { !self.is_valid() }
# }
struct UseDefault;

impl Foo for UseDefault {
    fn is_valid(&amp;self) -&gt; bool {
        println!(&quot;Called UseDefault.is_valid.&quot;);
        true
    }
}

struct OverrideDefault;

impl Foo for OverrideDefault {
    fn is_valid(&amp;self) -&gt; bool {
        println!(&quot;Called OverrideDefault.is_valid.&quot;);
        true
    }

    fn is_invalid(&amp;self) -&gt; bool {
        println!(&quot;Called OverrideDefault.is_invalid!&quot;);
        true // overrides the expected value of is_invalid()
    }
}

let default = UseDefault;
assert!(!default.is_invalid()); // prints &quot;Called UseDefault.is_valid.&quot;

let over = OverrideDefault;
assert!(over.is_invalid()); // prints &quot;Called OverrideDefault.is_invalid!&quot;
</code></pre>
<h1>Inheritance</h1>
<p>Sometimes, implementing a trait requires implementing another trait:</p>
<pre><code class="language-rust">trait Foo {
    fn foo(&amp;self);
}

trait FooBar : Foo {
    fn foobar(&amp;self);
}
</code></pre>
<p>Implementors of <code>FooBar</code> must also implement <code>Foo</code>, like this:</p>
<pre><code class="language-rust"># trait Foo {
#     fn foo(&amp;self);
# }
# trait FooBar : Foo {
#     fn foobar(&amp;self);
# }
struct Baz;

impl Foo for Baz {
    fn foo(&amp;self) { println!(&quot;foo&quot;); }
}

impl FooBar for Baz {
    fn foobar(&amp;self) { println!(&quot;foobar&quot;); }
}
</code></pre>
<p>If we forget to implement <code>Foo</code>, Rust will tell us:</p>
<pre><code class="language-text">error: the trait `main::Foo` is not implemented for the type `main::Baz` [E0277]
</code></pre>
<h1>Deriving</h1>
<p>Implementing traits like <code>Debug</code> and <code>Default</code> repeatedly can become
quite tedious. For that reason, Rust provides an <a href="attributes.html">attribute</a> that
allows you to let Rust automatically implement traits for you:</p>
<pre><code class="language-rust">#[derive(Debug)]
struct Foo;

fn main() {
    println!(&quot;{:?}&quot;, Foo);
}
</code></pre>
<p>However, deriving is limited to a certain set of traits:</p>
<ul>
<li>[<code>Clone</code>](../core/clone/trait.Clone.html)</li>
<li>[<code>Copy</code>](../core/marker/trait.Copy.html)</li>
<li>[<code>Debug</code>](../core/fmt/trait.Debug.html)</li>
<li>[<code>Default</code>](../core/default/trait.Default.html)</li>
<li>[<code>Eq</code>](../core/cmp/trait.Eq.html)</li>
<li>[<code>Hash</code>](../core/hash/trait.Hash.html)</li>
<li>[<code>Ord</code>](../core/cmp/trait.Ord.html)</li>
<li>[<code>PartialEq</code>](../core/cmp/trait.PartialEq.html)</li>
<li>[<code>PartialOrd</code>](../core/cmp/trait.PartialOrd.html)</li>
</ul>
<blockquote>
<p><em>commit a559577</em></p>
</blockquote>
<p>% Drop</p>
<p>Now that we’ve discussed traits, let’s talk about a particular trait provided
by the Rust standard library, [<code>Drop</code>]<a href="../std/ops/trait.Drop.html">drop</a>. The <code>Drop</code> trait provides a way
to run some code when a value goes out of scope. For example:</p>
<pre><code class="language-rust">struct HasDrop;

impl Drop for HasDrop {
    fn drop(&amp;mut self) {
        println!(&quot;Dropping!&quot;);
    }
}

fn main() {
    let x = HasDrop;

    // do stuff

} // x goes out of scope here
</code></pre>
<p>When <code>x</code> goes out of scope at the end of <code>main()</code>, the code for <code>Drop</code> will
run. <code>Drop</code> has one method, which is also called <code>drop()</code>. It takes a mutable
reference to <code>self</code>.</p>
<p>That’s it! The mechanics of <code>Drop</code> are very simple, but there are some
subtleties. For example, values are dropped in the opposite order they are
declared. Here’s another example:</p>
<pre><code class="language-rust">struct Firework {
    strength: i32,
}

impl Drop for Firework {
    fn drop(&amp;mut self) {
        println!(&quot;BOOM times {}!!!&quot;, self.strength);
    }
}

fn main() {
    let firecracker = Firework { strength: 1 };
    let tnt = Firework { strength: 100 };
}
</code></pre>
<p>This will output:</p>
<pre><code class="language-text">BOOM times 100!!!
BOOM times 1!!!
</code></pre>
<p>The TNT goes off before the firecracker does, because it was declared
afterwards. Last in, first out.</p>
<p>So what is <code>Drop</code> good for? Generally, <code>Drop</code> is used to clean up any resources
associated with a <code>struct</code>. For example, the <a href="../std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code> type</a> is a
reference-counted type. When <code>Drop</code> is called, it will decrement the reference
count, and if the total number of references is zero, will clean up the
underlying value.</p>
<blockquote>
<p><em>commit 024aa9a</em></p>
</blockquote>
<p>% if let</p>
<p><code>if let</code> allows you to combine <code>if</code> and <code>let</code> together to reduce the overhead
of certain kinds of pattern matches.</p>
<p>For example, let’s say we have some sort of <code>Option&lt;T&gt;</code>. We want to call a function
on it if it’s <code>Some&lt;T&gt;</code>, but do nothing if it’s <code>None</code>. That looks like this:</p>
<pre><code class="language-rust"># let option = Some(5);
# fn foo(x: i32) { }
match option {
    Some(x) =&gt; { foo(x) },
    None =&gt; {},
}
</code></pre>
<p>We don’t have to use <code>match</code> here, for example, we could use <code>if</code>:</p>
<pre><code class="language-rust"># let option = Some(5);
# fn foo(x: i32) { }
if option.is_some() {
    let x = option.unwrap();
    foo(x);
}
</code></pre>
<p>Neither of these options is particularly appealing. We can use <code>if let</code> to
do the same thing in a nicer way:</p>
<pre><code class="language-rust"># let option = Some(5);
# fn foo(x: i32) { }
if let Some(x) = option {
    foo(x);
}
</code></pre>
<p>If a <a href="patterns.html">pattern</a> matches successfully, it binds any appropriate parts of
the value to the identifiers in the pattern, then evaluates the expression. If
the pattern doesn’t match, nothing happens.</p>
<p>If you want to do something else when the pattern does not match, you can
use <code>else</code>:</p>
<pre><code class="language-rust"># let option = Some(5);
# fn foo(x: i32) { }
# fn bar() { }
if let Some(x) = option {
    foo(x);
} else {
    bar();
}
</code></pre>
<h2><code>while let</code></h2>
<p>In a similar fashion, <code>while let</code> can be used when you want to conditionally
loop  as long as a value matches a certain pattern. It turns code like this:</p>
<pre><code class="language-rust">let mut v = vec![1, 3, 5, 7, 11];
loop {
    match v.pop() {
        Some(x) =&gt;  println!(&quot;{}&quot;, x),
        None =&gt; break,
    }
}
</code></pre>
<p>Into code like this:</p>
<pre><code class="language-rust">let mut v = vec![1, 3, 5, 7, 11];
while let Some(x) = v.pop() {
    println!(&quot;{}&quot;, x);
}
</code></pre>
<blockquote>
<p><em>commit 797a0bd</em></p>
</blockquote>
<p>% Trait Objects</p>
<p>When code involves polymorphism, there needs to be a mechanism to determine
which specific version is actually run. This is called ‘dispatch’. There are
two major forms of dispatch: static dispatch and dynamic dispatch. While Rust
favors static dispatch, it also supports dynamic dispatch through a mechanism
called ‘trait objects’.</p>
<h2>Background</h2>
<p>For the rest of this chapter, we’ll need a trait and some implementations.
Let’s make a simple one, <code>Foo</code>. It has one method that is expected to return a
<code>String</code>.</p>
<pre><code class="language-rust">trait Foo {
    fn method(&amp;self) -&gt; String;
}
</code></pre>
<p>We’ll also implement this trait for <code>u8</code> and <code>String</code>:</p>
<pre><code class="language-rust"># trait Foo { fn method(&amp;self) -&gt; String; }
impl Foo for u8 {
    fn method(&amp;self) -&gt; String { format!(&quot;u8: {}&quot;, *self) }
}

impl Foo for String {
    fn method(&amp;self) -&gt; String { format!(&quot;string: {}&quot;, *self) }
}
</code></pre>
<h2>Static dispatch</h2>
<p>We can use this trait to perform static dispatch with trait bounds:</p>
<pre><code class="language-rust"># trait Foo { fn method(&amp;self) -&gt; String; }
# impl Foo for u8 { fn method(&amp;self) -&gt; String { format!(&quot;u8: {}&quot;, *self) } }
# impl Foo for String { fn method(&amp;self) -&gt; String { format!(&quot;string: {}&quot;, *self) } }
fn do_something&lt;T: Foo&gt;(x: T) {
    x.method();
}

fn main() {
    let x = 5u8;
    let y = &quot;Hello&quot;.to_string();

    do_something(x);
    do_something(y);
}
</code></pre>
<p>Rust uses ‘monomorphization’ to perform static dispatch here. This means that
Rust will create a special version of <code>do_something()</code> for both <code>u8</code> and
<code>String</code>, and then replace the call sites with calls to these specialized
functions. In other words, Rust generates something like this:</p>
<pre><code class="language-rust"># trait Foo { fn method(&amp;self) -&gt; String; }
# impl Foo for u8 { fn method(&amp;self) -&gt; String { format!(&quot;u8: {}&quot;, *self) } }
# impl Foo for String { fn method(&amp;self) -&gt; String { format!(&quot;string: {}&quot;, *self) } }
fn do_something_u8(x: u8) {
    x.method();
}

fn do_something_string(x: String) {
    x.method();
}

fn main() {
    let x = 5u8;
    let y = &quot;Hello&quot;.to_string();

    do_something_u8(x);
    do_something_string(y);
}
</code></pre>
<p>This has a great upside: static dispatch allows function calls to be
inlined because the callee is known at compile time, and inlining is
the key to good optimization. Static dispatch is fast, but it comes at
a tradeoff: ‘code bloat’, due to many copies of the same function
existing in the binary, one for each type.</p>
<p>Furthermore, compilers aren’t perfect and may “optimize” code to become slower.
For example, functions inlined too eagerly will bloat the instruction cache
(cache rules everything around us). This is part of the reason that <code>#[inline]</code>
and <code>#[inline(always)]</code> should be used carefully, and one reason why using a
dynamic dispatch is sometimes more efficient.</p>
<p>However, the common case is that it is more efficient to use static dispatch,
and one can always have a thin statically-dispatched wrapper function that does
a dynamic dispatch, but not vice versa, meaning static calls are more flexible.
The standard library tries to be statically dispatched where possible for this
reason.</p>
<h2>Dynamic dispatch</h2>
<p>Rust provides dynamic dispatch through a feature called ‘trait objects’. Trait
objects, like <code>&amp;Foo</code> or <code>Box&lt;Foo&gt;</code>, are normal values that store a value of
<em>any</em> type that implements the given trait, where the precise type can only be
known at runtime.</p>
<p>A trait object can be obtained from a pointer to a concrete type that
implements the trait by <em>casting</em> it (e.g. <code>&amp;x as &amp;Foo</code>) or <em>coercing</em> it
(e.g. using <code>&amp;x</code> as an argument to a function that takes <code>&amp;Foo</code>).</p>
<p>These trait object coercions and casts also work for pointers like <code>&amp;mut T</code> to
<code>&amp;mut Foo</code> and <code>Box&lt;T&gt;</code> to <code>Box&lt;Foo&gt;</code>, but that’s all at the moment. Coercions
and casts are identical.</p>
<p>This operation can be seen as ‘erasing’ the compiler’s knowledge about the
specific type of the pointer, and hence trait objects are sometimes referred to
as ‘type erasure’.</p>
<p>Coming back to the example above, we can use the same trait to perform dynamic
dispatch with trait objects by casting:</p>
<pre><code class="language-rust"># trait Foo { fn method(&amp;self) -&gt; String; }
# impl Foo for u8 { fn method(&amp;self) -&gt; String { format!(&quot;u8: {}&quot;, *self) } }
# impl Foo for String { fn method(&amp;self) -&gt; String { format!(&quot;string: {}&quot;, *self) } }

fn do_something(x: &amp;Foo) {
    x.method();
}

fn main() {
    let x = 5u8;
    do_something(&amp;x as &amp;Foo);
}
</code></pre>
<p>or by coercing:</p>
<pre><code class="language-rust"># trait Foo { fn method(&amp;self) -&gt; String; }
# impl Foo for u8 { fn method(&amp;self) -&gt; String { format!(&quot;u8: {}&quot;, *self) } }
# impl Foo for String { fn method(&amp;self) -&gt; String { format!(&quot;string: {}&quot;, *self) } }

fn do_something(x: &amp;Foo) {
    x.method();
}

fn main() {
    let x = &quot;Hello&quot;.to_string();
    do_something(&amp;x);
}
</code></pre>
<p>A function that takes a trait object is not specialized to each of the types
that implements <code>Foo</code>: only one copy is generated, often (but not always)
resulting in less code bloat. However, this comes at the cost of requiring
slower virtual function calls, and effectively inhibiting any chance of
inlining and related optimizations from occurring.</p>
<h3>Why pointers?</h3>
<p>Rust does not put things behind a pointer by default, unlike many managed
languages, so types can have different sizes. Knowing the size of the value at
compile time is important for things like passing it as an argument to a
function, moving it about on the stack and allocating (and deallocating) space
on the heap to store it.</p>
<p>For <code>Foo</code>, we would need to have a value that could be at least either a
<code>String</code> (24 bytes) or a <code>u8</code> (1 byte), as well as any other type for which
dependent crates may implement <code>Foo</code> (any number of bytes at all). There’s no
way to guarantee that this last point can work if the values are stored without
a pointer, because those other types can be arbitrarily large.</p>
<p>Putting the value behind a pointer means the size of the value is not relevant
when we are tossing a trait object around, only the size of the pointer itself.</p>
<h3>Representation</h3>
<p>The methods of the trait can be called on a trait object via a special record
of function pointers traditionally called a ‘vtable’ (created and managed by
the compiler).</p>
<p>Trait objects are both simple and complicated: their core representation and
layout is quite straight-forward, but there are some curly error messages and
surprising behaviors to discover.</p>
<p>Let’s start simple, with the runtime representation of a trait object. The
<code>std::raw</code> module contains structs with layouts that are the same as the
complicated built-in types, <a href="../std/raw/struct.TraitObject.html">including trait objects</a>:</p>
<pre><code class="language-rust"># mod foo {
pub struct TraitObject {
    pub data: *mut (),
    pub vtable: *mut (),
}
# }
</code></pre>
<p>That is, a trait object like <code>&amp;Foo</code> consists of a ‘data’ pointer and a ‘vtable’
pointer.</p>
<p>The data pointer addresses the data (of some unknown type <code>T</code>) that the trait
object is storing, and the vtable pointer points to the vtable (‘virtual method
table’) corresponding to the implementation of <code>Foo</code> for <code>T</code>.</p>
<p>A vtable is essentially a struct of function pointers, pointing to the concrete
piece of machine code for each method in the implementation. A method call like
<code>trait_object.method()</code> will retrieve the correct pointer out of the vtable and
then do a dynamic call of it. For example:</p>
<pre><code class="language-rust,ignore">struct FooVtable {
    destructor: fn(*mut ()),
    size: usize,
    align: usize,
    method: fn(*const ()) -&gt; String,
}

// u8:

fn call_method_on_u8(x: *const ()) -&gt; String {
    // the compiler guarantees that this function is only called
    // with `x` pointing to a u8
    let byte: &amp;u8 = unsafe { &amp;*(x as *const u8) };

    byte.method()
}

static Foo_for_u8_vtable: FooVtable = FooVtable {
    destructor: /* compiler magic */,
    size: 1,
    align: 1,

    // cast to a function pointer
    method: call_method_on_u8 as fn(*const ()) -&gt; String,
};


// String:

fn call_method_on_String(x: *const ()) -&gt; String {
    // the compiler guarantees that this function is only called
    // with `x` pointing to a String
    let string: &amp;String = unsafe { &amp;*(x as *const String) };

    string.method()
}

static Foo_for_String_vtable: FooVtable = FooVtable {
    destructor: /* compiler magic */,
    // values for a 64-bit computer, halve them for 32-bit ones
    size: 24,
    align: 8,

    method: call_method_on_String as fn(*const ()) -&gt; String,
};
</code></pre>
<p>The <code>destructor</code> field in each vtable points to a function that will clean up
any resources of the vtable’s type: for <code>u8</code> it is trivial, but for <code>String</code> it
will free the memory. This is necessary for owning trait objects like
<code>Box&lt;Foo&gt;</code>, which need to clean-up both the <code>Box</code> allocation as well as the
internal type when they go out of scope. The <code>size</code> and <code>align</code> fields store
the size of the erased type, and its alignment requirements; these are
essentially unused at the moment since the information is embedded in the
destructor, but will be used in the future, as trait objects are progressively
made more flexible.</p>
<p>Suppose we’ve got some values that implement <code>Foo</code>. The explicit form of
construction and use of <code>Foo</code> trait objects might look a bit like (ignoring the
type mismatches: they’re all pointers anyway):</p>
<pre><code class="language-rust,ignore">let a: String = &quot;foo&quot;.to_string();
let x: u8 = 1;

// let b: &amp;Foo = &amp;a;
let b = TraitObject {
    // store the data
    data: &amp;a,
    // store the methods
    vtable: &amp;Foo_for_String_vtable
};

// let y: &amp;Foo = x;
let y = TraitObject {
    // store the data
    data: &amp;x,
    // store the methods
    vtable: &amp;Foo_for_u8_vtable
};

// b.method();
(b.vtable.method)(b.data);

// y.method();
(y.vtable.method)(y.data);
</code></pre>
<h2>Object Safety</h2>
<p>Not every trait can be used to make a trait object. For example, vectors implement
<code>Clone</code>, but if we try to make a trait object:</p>
<pre><code class="language-ignore">let v = vec![1, 2, 3];
let o = &amp;v as &amp;Clone;
</code></pre>
<p>We get an error:</p>
<pre><code class="language-text">error: cannot convert to a trait object because trait `core::clone::Clone` is not object-safe [E0038]
let o = &amp;v as &amp;Clone;
        ^~
note: the trait cannot require that `Self : Sized`
let o = &amp;v as &amp;Clone;
        ^~
</code></pre>
<p>The error says that <code>Clone</code> is not ‘object-safe’. Only traits that are
object-safe can be made into trait objects. A trait is object-safe if both of
these are true:</p>
<ul>
<li>the trait does not require that <code>Self: Sized</code></li>
<li>all of its methods are object-safe</li>
</ul>
<p>So what makes a method object-safe? Each method must require that <code>Self: Sized</code>
or all of the following:</p>
<ul>
<li>must not have any type parameters</li>
<li>must not use <code>Self</code></li>
</ul>
<p>Whew! As we can see, almost all of these rules talk about <code>Self</code>. A good intuition
is “except in special circumstances, if your trait’s method uses <code>Self</code>, it is not
object-safe.”</p>
<blockquote>
<p><em>commit 6ba9520</em></p>
</blockquote>
<p>% Closures</p>
<p>Sometimes it is useful to wrap up a function and <em>free variables</em> for better
clarity and reuse. The free variables that can be used come from the
enclosing scope and are ‘closed over’ when used in the function. From this, we
get the name ‘closures’ and Rust provides a really great implementation of
them, as we’ll see.</p>
<h1>Syntax</h1>
<p>Closures look like this:</p>
<pre><code class="language-rust">let plus_one = |x: i32| x + 1;

assert_eq!(2, plus_one(1));
</code></pre>
<p>We create a binding, <code>plus_one</code>, and assign it to a closure. The closure’s
arguments go between the pipes (<code>|</code>), and the body is an expression, in this
case, <code>x + 1</code>. Remember that <code>{ }</code> is an expression, so we can have multi-line
closures too:</p>
<pre><code class="language-rust">let plus_two = |x| {
    let mut result: i32 = x;

    result += 1;
    result += 1;

    result
};

assert_eq!(4, plus_two(2));
</code></pre>
<p>You’ll notice a few things about closures that are a bit different from regular
named functions defined with <code>fn</code>. The first is that we did not need to
annotate the types of arguments the closure takes or the values it returns. We
can:</p>
<pre><code class="language-rust">let plus_one = |x: i32| -&gt; i32 { x + 1 };

assert_eq!(2, plus_one(1));
</code></pre>
<p>But we don’t have to. Why is this? Basically, it was chosen for ergonomic
reasons. While specifying the full type for named functions is helpful with
things like documentation and type inference, the full type signatures of
closures are rarely documented since they’re anonymous, and they don’t cause
the kinds of error-at-a-distance problems that inferring named function types
can.</p>
<p>The second is that the syntax is similar, but a bit different. I’ve added
spaces here for easier comparison:</p>
<pre><code class="language-rust">fn  plus_one_v1   (x: i32) -&gt; i32 { x + 1 }
let plus_one_v2 = |x: i32| -&gt; i32 { x + 1 };
let plus_one_v3 = |x: i32|          x + 1  ;
</code></pre>
<p>Small differences, but they’re similar.</p>
<h1>Closures and their environment</h1>
<p>The environment for a closure can include bindings from its enclosing scope in
addition to parameters and local bindings. It looks like this:</p>
<pre><code class="language-rust">let num = 5;
let plus_num = |x: i32| x + num;

assert_eq!(10, plus_num(5));
</code></pre>
<p>This closure, <code>plus_num</code>, refers to a <code>let</code> binding in its scope: <code>num</code>. More
specifically, it borrows the binding. If we do something that would conflict
with that binding, we get an error. Like this one:</p>
<pre><code class="language-rust,ignore">let mut num = 5;
let plus_num = |x: i32| x + num;

let y = &amp;mut num;
</code></pre>
<p>Which errors with:</p>
<pre><code class="language-text">error: cannot borrow `num` as mutable because it is also borrowed as immutable
    let y = &amp;mut num;
                 ^~~
note: previous borrow of `num` occurs here due to use in closure; the immutable
  borrow prevents subsequent moves or mutable borrows of `num` until the borrow
  ends
    let plus_num = |x| x + num;
                   ^~~~~~~~~~~
note: previous borrow ends here
fn main() {
    let mut num = 5;
    let plus_num = |x| x + num;

    let y = &amp;mut num;
}
^
</code></pre>
<p>A verbose yet helpful error message! As it says, we can’t take a mutable borrow
on <code>num</code> because the closure is already borrowing it. If we let the closure go
out of scope, we can:</p>
<pre><code class="language-rust">let mut num = 5;
{
    let plus_num = |x: i32| x + num;

} // plus_num goes out of scope, borrow of num ends

let y = &amp;mut num;
</code></pre>
<p>If your closure requires it, however, Rust will take ownership and move
the environment instead. This doesn’t work:</p>
<pre><code class="language-rust,ignore">let nums = vec![1, 2, 3];

let takes_nums = || nums;

println!(&quot;{:?}&quot;, nums);
</code></pre>
<p>We get this error:</p>
<pre><code class="language-text">note: `nums` moved into closure environment here because it has type
  `[closure(()) -&gt; collections::vec::Vec&lt;i32&gt;]`, which is non-copyable
let takes_nums = || nums;
                 ^~~~~~~
</code></pre>
<p><code>Vec&lt;T&gt;</code> has ownership over its contents, and therefore, when we refer to it
in our closure, we have to take ownership of <code>nums</code>. It’s the same as if we’d
passed <code>nums</code> to a function that took ownership of it.</p>
<h2><code>move</code> closures</h2>
<p>We can force our closure to take ownership of its environment with the <code>move</code>
keyword:</p>
<pre><code class="language-rust">let num = 5;

let owns_num = move |x: i32| x + num;
</code></pre>
<p>Now, even though the keyword is <code>move</code>, the variables follow normal move semantics.
In this case, <code>5</code> implements <code>Copy</code>, and so <code>owns_num</code> takes ownership of a copy
of <code>num</code>. So what’s the difference?</p>
<pre><code class="language-rust">let mut num = 5;

{
    let mut add_num = |x: i32| num += x;

    add_num(5);
}

assert_eq!(10, num);
</code></pre>
<p>So in this case, our closure took a mutable reference to <code>num</code>, and then when
we called <code>add_num</code>, it mutated the underlying value, as we’d expect. We also
needed to declare <code>add_num</code> as <code>mut</code> too, because we’re mutating its
environment.</p>
<p>If we change to a <code>move</code> closure, it’s different:</p>
<pre><code class="language-rust">let mut num = 5;

{
    let mut add_num = move |x: i32| num += x;

    add_num(5);
}

assert_eq!(5, num);
</code></pre>
<p>We only get <code>5</code>. Rather than taking a mutable borrow out on our <code>num</code>, we took
ownership of a copy.</p>
<p>Another way to think about <code>move</code> closures: they give a closure its own stack
frame.  Without <code>move</code>, a closure may be tied to the stack frame that created
it, while a <code>move</code> closure is self-contained. This means that you cannot
generally return a non-<code>move</code> closure from a function, for example.</p>
<p>But before we talk about taking and returning closures, we should talk some
more about the way that closures are implemented. As a systems language, Rust
gives you tons of control over what your code does, and closures are no
different.</p>
<h1>Closure implementation</h1>
<p>Rust’s implementation of closures is a bit different than other languages. They
are effectively syntax sugar for traits. You’ll want to make sure to have read
the <a href="traits.html">traits</a> section before this one, as well as the section on <a href="trait-objects.html">trait
objects</a>.</p>
<p>Got all that? Good.</p>
<p>The key to understanding how closures work under the hood is something a bit
strange: Using <code>()</code> to call a function, like <code>foo()</code>, is an overloadable
operator. From this, everything else clicks into place. In Rust, we use the
trait system to overload operators. Calling functions is no different. We have
three separate traits to overload with:</p>
<pre><code class="language-rust"># mod foo {
pub trait Fn&lt;Args&gt; : FnMut&lt;Args&gt; {
    extern &quot;rust-call&quot; fn call(&amp;self, args: Args) -&gt; Self::Output;
}

pub trait FnMut&lt;Args&gt; : FnOnce&lt;Args&gt; {
    extern &quot;rust-call&quot; fn call_mut(&amp;mut self, args: Args) -&gt; Self::Output;
}

pub trait FnOnce&lt;Args&gt; {
    type Output;

    extern &quot;rust-call&quot; fn call_once(self, args: Args) -&gt; Self::Output;
}
# }
</code></pre>
<p>You’ll notice a few differences between these traits, but a big one is <code>self</code>:
<code>Fn</code> takes <code>&amp;self</code>, <code>FnMut</code> takes <code>&amp;mut self</code>, and <code>FnOnce</code> takes <code>self</code>. This
covers all three kinds of <code>self</code> via the usual method call syntax. But we’ve
split them up into three traits, rather than having a single one. This gives us
a large amount of control over what kind of closures we can take.</p>
<p>The <code>|| {}</code> syntax for closures is sugar for these three traits. Rust will
generate a struct for the environment, <code>impl</code> the appropriate trait, and then
use it.</p>
<h1>Taking closures as arguments</h1>
<p>Now that we know that closures are traits, we already know how to accept and
return closures: the same as any other trait!</p>
<p>This also means that we can choose static vs dynamic dispatch as well. First,
let’s write a function which takes something callable, calls it, and returns
the result:</p>
<pre><code class="language-rust">fn call_with_one&lt;F&gt;(some_closure: F) -&gt; i32
    where F : Fn(i32) -&gt; i32 {

    some_closure(1)
}

let answer = call_with_one(|x| x + 2);

assert_eq!(3, answer);
</code></pre>
<p>We pass our closure, <code>|x| x + 2</code>, to <code>call_with_one</code>. It does what it
suggests: it calls the closure, giving it <code>1</code> as an argument.</p>
<p>Let’s examine the signature of <code>call_with_one</code> in more depth:</p>
<pre><code class="language-rust">fn call_with_one&lt;F&gt;(some_closure: F) -&gt; i32
#    where F : Fn(i32) -&gt; i32 {
#    some_closure(1) }
</code></pre>
<p>We take one parameter, and it has the type <code>F</code>. We also return a <code>i32</code>. This part
isn’t interesting. The next part is:</p>
<pre><code class="language-rust"># fn call_with_one&lt;F&gt;(some_closure: F) -&gt; i32
    where F : Fn(i32) -&gt; i32 {
#   some_closure(1) }
</code></pre>
<p>Because <code>Fn</code> is a trait, we can bound our generic with it. In this case, our
closure takes a <code>i32</code> as an argument and returns an <code>i32</code>, and so the generic
bound we use is <code>Fn(i32) -&gt; i32</code>.</p>
<p>There’s one other key point here: because we’re bounding a generic with a
trait, this will get monomorphized, and therefore, we’ll be doing static
dispatch into the closure. That’s pretty neat. In many languages, closures are
inherently heap allocated, and will always involve dynamic dispatch. In Rust,
we can stack allocate our closure environment, and statically dispatch the
call. This happens quite often with iterators and their adapters, which often
take closures as arguments.</p>
<p>Of course, if we want dynamic dispatch, we can get that too. A trait object
handles this case, as usual:</p>
<pre><code class="language-rust">fn call_with_one(some_closure: &amp;Fn(i32) -&gt; i32) -&gt; i32 {
    some_closure(1)
}

let answer = call_with_one(&amp;|x| x + 2);

assert_eq!(3, answer);
</code></pre>
<p>Now we take a trait object, a <code>&amp;Fn</code>. And we have to make a reference
to our closure when we pass it to <code>call_with_one</code>, so we use <code>&amp;||</code>.</p>
<h1>Function pointers and closures</h1>
<p>A function pointer is kind of like a closure that has no environment. As such,
you can pass a function pointer to any function expecting a closure argument,
and it will work:</p>
<pre><code class="language-rust">fn call_with_one(some_closure: &amp;Fn(i32) -&gt; i32) -&gt; i32 {
    some_closure(1)
}

fn add_one(i: i32) -&gt; i32 {
    i + 1
}

let f = add_one;

let answer = call_with_one(&amp;f);

assert_eq!(2, answer);
</code></pre>
<p>In this example, we don’t strictly need the intermediate variable <code>f</code>,
the name of the function works just fine too:</p>
<pre><code class="language-ignore">let answer = call_with_one(&amp;add_one);
</code></pre>
<h1>Returning closures</h1>
<p>It’s very common for functional-style code to return closures in various
situations. If you try to return a closure, you may run into an error. At
first, it may seem strange, but we’ll figure it out. Here’s how you’d probably
try to return a closure from a function:</p>
<pre><code class="language-rust,ignore">fn factory() -&gt; (Fn(i32) -&gt; i32) {
    let num = 5;

    |x| x + num
}

let f = factory();

let answer = f(1);
assert_eq!(6, answer);
</code></pre>
<p>This gives us these long, related errors:</p>
<pre><code class="language-text">error: the trait `core::marker::Sized` is not implemented for the type
`core::ops::Fn(i32) -&gt; i32` [E0277]
fn factory() -&gt; (Fn(i32) -&gt; i32) {
                ^~~~~~~~~~~~~~~~
note: `core::ops::Fn(i32) -&gt; i32` does not have a constant size known at compile-time
fn factory() -&gt; (Fn(i32) -&gt; i32) {
                ^~~~~~~~~~~~~~~~
error: the trait `core::marker::Sized` is not implemented for the type `core::ops::Fn(i32) -&gt; i32` [E0277]
let f = factory();
    ^
note: `core::ops::Fn(i32) -&gt; i32` does not have a constant size known at compile-time
let f = factory();
    ^
</code></pre>
<p>In order to return something from a function, Rust needs to know what
size the return type is. But since <code>Fn</code> is a trait, it could be various
things of various sizes: many different types can implement <code>Fn</code>. An easy
way to give something a size is to take a reference to it, as references
have a known size. So we’d write this:</p>
<pre><code class="language-rust,ignore">fn factory() -&gt; &amp;(Fn(i32) -&gt; i32) {
    let num = 5;

    |x| x + num
}

let f = factory();

let answer = f(1);
assert_eq!(6, answer);
</code></pre>
<p>But we get another error:</p>
<pre><code class="language-text">error: missing lifetime specifier [E0106]
fn factory() -&gt; &amp;(Fn(i32) -&gt; i32) {
                ^~~~~~~~~~~~~~~~~
</code></pre>
<p>Right. Because we have a reference, we need to give it a lifetime. But
our <code>factory()</code> function takes no arguments, so
<a href="lifetimes.html#lifetime-elision">elision</a> doesn’t kick in here. Then what
choices do we have? Try <code>'static</code>:</p>
<pre><code class="language-rust,ignore">fn factory() -&gt; &amp;'static (Fn(i32) -&gt; i32) {
    let num = 5;

    |x| x + num
}

let f = factory();

let answer = f(1);
assert_eq!(6, answer);
</code></pre>
<p>But we get another error:</p>
<pre><code class="language-text">error: mismatched types:
 expected `&amp;'static core::ops::Fn(i32) -&gt; i32`,
    found `[closure@&lt;anon&gt;:7:9: 7:20]`
(expected &amp;-ptr,
    found closure) [E0308]
         |x| x + num
         ^~~~~~~~~~~

</code></pre>
<p>This error is letting us know that we don’t have a <code>&amp;'static Fn(i32) -&gt; i32</code>,
we have a <code>[closure@&lt;anon&gt;:7:9: 7:20]</code>. Wait, what?</p>
<p>Because each closure generates its own environment <code>struct</code> and implementation
of <code>Fn</code> and friends, these types are anonymous. They exist solely for
this closure. So Rust shows them as <code>closure@&lt;anon&gt;</code>, rather than some
autogenerated name.</p>
<p>The error also points out that the return type is expected to be a reference,
but what we are trying to return is not. Further, we cannot directly assign a
<code>'static</code> lifetime to an object. So we'll take a different approach and return
a ‘trait object’ by <code>Box</code>ing up the <code>Fn</code>. This <em>almost</em> works:</p>
<pre><code class="language-rust,ignore">fn factory() -&gt; Box&lt;Fn(i32) -&gt; i32&gt; {
    let num = 5;

    Box::new(|x| x + num)
}
# fn main() {
let f = factory();

let answer = f(1);
assert_eq!(6, answer);
# }
</code></pre>
<p>There’s just one last problem:</p>
<pre><code class="language-text">error: closure may outlive the current function, but it borrows `num`,
which is owned by the current function [E0373]
Box::new(|x| x + num)
         ^~~~~~~~~~~
</code></pre>
<p>Well, as we discussed before, closures borrow their environment. And in this
case, our environment is based on a stack-allocated <code>5</code>, the <code>num</code> variable
binding. So the borrow has a lifetime of the stack frame. So if we returned
this closure, the function call would be over, the stack frame would go away,
and our closure is capturing an environment of garbage memory! With one last
fix, we can make this work:</p>
<pre><code class="language-rust">fn factory() -&gt; Box&lt;Fn(i32) -&gt; i32&gt; {
    let num = 5;

    Box::new(move |x| x + num)
}
# fn main() {
let f = factory();

let answer = f(1);
assert_eq!(6, answer);
# }
</code></pre>
<p>By making the inner closure a <code>move Fn</code>, we create a new stack frame for our
closure. By <code>Box</code>ing it up, we’ve given it a known size, and allowing it to
escape our stack frame.</p>
<blockquote>
<p><em>commit 6ba9520</em></p>
</blockquote>
<p>% Universal Function Call Syntax</p>
<p>Sometimes, functions can have the same names. Consider this code:</p>
<pre><code class="language-rust">trait Foo {
    fn f(&amp;self);
}

trait Bar {
    fn f(&amp;self);
}

struct Baz;

impl Foo for Baz {
    fn f(&amp;self) { println!(&quot;Baz’s impl of Foo&quot;); }
}

impl Bar for Baz {
    fn f(&amp;self) { println!(&quot;Baz’s impl of Bar&quot;); }
}

let b = Baz;
</code></pre>
<p>If we were to try to call <code>b.f()</code>, we’d get an error:</p>
<pre><code class="language-text">error: multiple applicable methods in scope [E0034]
b.f();
  ^~~
note: candidate #1 is defined in an impl of the trait `main::Foo` for the type
`main::Baz`
    fn f(&amp;self) { println!(&quot;Baz’s impl of Foo&quot;); }
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
note: candidate #2 is defined in an impl of the trait `main::Bar` for the type
`main::Baz`
    fn f(&amp;self) { println!(&quot;Baz’s impl of Bar&quot;); }
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

</code></pre>
<p>We need a way to disambiguate which method we need. This feature is called
‘universal function call syntax’, and it looks like this:</p>
<pre><code class="language-rust"># trait Foo {
#     fn f(&amp;self);
# }
# trait Bar {
#     fn f(&amp;self);
# }
# struct Baz;
# impl Foo for Baz {
#     fn f(&amp;self) { println!(&quot;Baz’s impl of Foo&quot;); }
# }
# impl Bar for Baz {
#     fn f(&amp;self) { println!(&quot;Baz’s impl of Bar&quot;); }
# }
# let b = Baz;
Foo::f(&amp;b);
Bar::f(&amp;b);
</code></pre>
<p>Let’s break it down.</p>
<pre><code class="language-rust,ignore">Foo::
Bar::
</code></pre>
<p>These halves of the invocation are the types of the two traits: <code>Foo</code> and
<code>Bar</code>. This is what ends up actually doing the disambiguation between the two:
Rust calls the one from the trait name you use.</p>
<pre><code class="language-rust,ignore">f(&amp;b)
</code></pre>
<p>When we call a method like <code>b.f()</code> using <a href="method-syntax.html">method syntax</a>, Rust
will automatically borrow <code>b</code> if <code>f()</code> takes <code>&amp;self</code>. In this case, Rust will
not, and so we need to pass an explicit <code>&amp;b</code>.</p>
<h1>Angle-bracket Form</h1>
<p>The form of UFCS we just talked about:</p>
<pre><code class="language-rust,ignore">Trait::method(args);
</code></pre>
<p>Is a short-hand. There’s an expanded form of this that’s needed in some
situations:</p>
<pre><code class="language-rust,ignore">&lt;Type as Trait&gt;::method(args);
</code></pre>
<p>The <code>&lt;&gt;::</code> syntax is a means of providing a type hint. The type goes inside
the <code>&lt;&gt;</code>s. In this case, the type is <code>Type as Trait</code>, indicating that we want
<code>Trait</code>’s version of <code>method</code> to be called here. The <code>as Trait</code> part is
optional if it’s not ambiguous. Same with the angle brackets, hence the
shorter form.</p>
<p>Here’s an example of using the longer form.</p>
<pre><code class="language-rust">trait Foo {
    fn foo() -&gt; i32;
}

struct Bar;

impl Bar {
    fn foo() -&gt; i32 {
        20
    }
}

impl Foo for Bar {
    fn foo() -&gt; i32 {
        10
    }
}

fn main() {
    assert_eq!(10, &lt;Bar as Foo&gt;::foo());
    assert_eq!(20, Bar::foo());
}
</code></pre>
<p>Using the angle bracket syntax lets you call the trait method instead of the
inherent one.</p>
<blockquote>
<p><em>commit 024aa9a</em></p>
</blockquote>
<p>% Crates and Modules</p>
<p>When a project starts getting large, it’s considered good software
engineering practice to split it up into a bunch of smaller pieces, and then
fit them together. It is also important to have a well-defined interface, so
that some of your functionality is private, and some is public. To facilitate
these kinds of things, Rust has a module system.</p>
<h1>Basic terminology: Crates and Modules</h1>
<p>Rust has two distinct terms that relate to the module system: ‘crate’ and
‘module’. A crate is synonymous with a ‘library’ or ‘package’ in other
languages. Hence “Cargo” as the name of Rust’s package management tool: you
ship your crates to others with Cargo. Crates can produce an executable or a
library, depending on the project.</p>
<p>Each crate has an implicit <em>root module</em> that contains the code for that crate.
You can then define a tree of sub-modules under that root module. Modules allow
you to partition your code within the crate itself.</p>
<p>As an example, let’s make a <em>phrases</em> crate, which will give us various phrases
in different languages. To keep things simple, we’ll stick to ‘greetings’ and
‘farewells’ as two kinds of phrases, and use English and Japanese (日本語) as
two languages for those phrases to be in. We’ll use this module layout:</p>
<pre><code class="language-text">                                    +-----------+
                                +---| greetings |
                                |   +-----------+
                  +---------+   |
              +---| english |---+
              |   +---------+   |   +-----------+
              |                 +---| farewells |
+---------+   |                     +-----------+
| phrases |---+
+---------+   |                     +-----------+
              |                 +---| greetings |
              |   +----------+  |   +-----------+
              +---| japanese |--+
                  +----------+  |
                                |   +-----------+
                                +---| farewells |
                                    +-----------+
</code></pre>
<p>In this example, <code>phrases</code> is the name of our crate. All of the rest are
modules.  You can see that they form a tree, branching out from the crate
<em>root</em>, which is the root of the tree: <code>phrases</code> itself.</p>
<p>Now that we have a plan, let’s define these modules in code. To start,
generate a new crate with Cargo:</p>
<pre><code class="language-bash">$ cargo new phrases
$ cd phrases
</code></pre>
<p>If you remember, this generates a simple project for us:</p>
<pre><code class="language-bash">$ tree .
.
├── Cargo.toml
└── src
    └── lib.rs

1 directory, 2 files
</code></pre>
<p><code>src/lib.rs</code> is our crate root, corresponding to the <code>phrases</code> in our diagram
above.</p>
<h1>Defining Modules</h1>
<p>To define each of our modules, we use the <code>mod</code> keyword. Let’s make our
<code>src/lib.rs</code> look like this:</p>
<pre><code class="language-rust">mod english {
    mod greetings {
    }

    mod farewells {
    }
}

mod japanese {
    mod greetings {
    }

    mod farewells {
    }
}
</code></pre>
<p>After the <code>mod</code> keyword, you give the name of the module. Module names follow
the conventions for other Rust identifiers: <code>lower_snake_case</code>. The contents of
each module are within curly braces (<code>{}</code>).</p>
<p>Within a given <code>mod</code>, you can declare sub-<code>mod</code>s. We can refer to sub-modules
with double-colon (<code>::</code>) notation: our four nested modules are
<code>english::greetings</code>, <code>english::farewells</code>, <code>japanese::greetings</code>, and
<code>japanese::farewells</code>. Because these sub-modules are namespaced under their
parent module, the names don’t conflict: <code>english::greetings</code> and
<code>japanese::greetings</code> are distinct, even though their names are both
<code>greetings</code>.</p>
<p>Because this crate does not have a <code>main()</code> function, and is called <code>lib.rs</code>,
Cargo will build this crate as a library:</p>
<pre><code class="language-bash">$ cargo build
   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)
$ ls target/debug
build  deps  examples  libphrases-a7448e02a0468eaa.rlib  native
</code></pre>
<p><code>libphrases-hash.rlib</code> is the compiled crate. Before we see how to use this
crate from another crate, let’s break it up into multiple files.</p>
<h1>Multiple file crates</h1>
<p>If each crate were just one file, these files would get very large. It’s often
easier to split up crates into multiple files, and Rust supports this in two
ways.</p>
<p>Instead of declaring a module like this:</p>
<pre><code class="language-rust,ignore">mod english {
    // contents of our module go here
}
</code></pre>
<p>We can instead declare our module like this:</p>
<pre><code class="language-rust,ignore">mod english;
</code></pre>
<p>If we do that, Rust will expect to find either a <code>english.rs</code> file, or a
<code>english/mod.rs</code> file with the contents of our module.</p>
<p>Note that in these files, you don’t need to re-declare the module: that’s
already been done with the initial <code>mod</code> declaration.</p>
<p>Using these two techniques, we can break up our crate into two directories and
seven files:</p>
<pre><code class="language-bash">$ tree .
.
├── Cargo.lock
├── Cargo.toml
├── src
│   ├── english
│   │   ├── farewells.rs
│   │   ├── greetings.rs
│   │   └── mod.rs
│   ├── japanese
│   │   ├── farewells.rs
│   │   ├── greetings.rs
│   │   └── mod.rs
│   └── lib.rs
└── target
    └── debug
        ├── build
        ├── deps
        ├── examples
        ├── libphrases-a7448e02a0468eaa.rlib
        └── native
</code></pre>
<p><code>src/lib.rs</code> is our crate root, and looks like this:</p>
<pre><code class="language-rust,ignore">mod english;
mod japanese;
</code></pre>
<p>These two declarations tell Rust to look for either <code>src/english.rs</code> and
<code>src/japanese.rs</code>, or <code>src/english/mod.rs</code> and <code>src/japanese/mod.rs</code>, depending
on our preference. In this case, because our modules have sub-modules, we’ve
chosen the second. Both <code>src/english/mod.rs</code> and <code>src/japanese/mod.rs</code> look
like this:</p>
<pre><code class="language-rust,ignore">mod greetings;
mod farewells;
</code></pre>
<p>Again, these declarations tell Rust to look for either
<code>src/english/greetings.rs</code> and <code>src/japanese/greetings.rs</code> or
<code>src/english/farewells/mod.rs</code> and <code>src/japanese/farewells/mod.rs</code>. Because
these sub-modules don’t have their own sub-modules, we’ve chosen to make them
<code>src/english/greetings.rs</code> and <code>src/japanese/farewells.rs</code>. Whew!</p>
<p>The contents of <code>src/english/greetings.rs</code> and <code>src/japanese/farewells.rs</code> are
both empty at the moment. Let’s add some functions.</p>
<p>Put this in <code>src/english/greetings.rs</code>:</p>
<pre><code class="language-rust">fn hello() -&gt; String {
    &quot;Hello!&quot;.to_string()
}
</code></pre>
<p>Put this in <code>src/english/farewells.rs</code>:</p>
<pre><code class="language-rust">fn goodbye() -&gt; String {
    &quot;Goodbye.&quot;.to_string()
}
</code></pre>
<p>Put this in <code>src/japanese/greetings.rs</code>:</p>
<pre><code class="language-rust">fn hello() -&gt; String {
    &quot;こんにちは&quot;.to_string()
}
</code></pre>
<p>Of course, you can copy and paste this from this web page, or type
something else. It’s not important that you actually put ‘konnichiwa’ to learn
about the module system.</p>
<p>Put this in <code>src/japanese/farewells.rs</code>:</p>
<pre><code class="language-rust">fn goodbye() -&gt; String {
    &quot;さようなら&quot;.to_string()
}
</code></pre>
<p>(This is ‘Sayōnara’, if you’re curious.)</p>
<p>Now that we have some functionality in our crate, let’s try to use it from
another crate.</p>
<h1>Importing External Crates</h1>
<p>We have a library crate. Let’s make an executable crate that imports and uses
our library.</p>
<p>Make a <code>src/main.rs</code> and put this in it (it won’t quite compile yet):</p>
<pre><code class="language-rust,ignore">extern crate phrases;

fn main() {
    println!(&quot;Hello in English: {}&quot;, phrases::english::greetings::hello());
    println!(&quot;Goodbye in English: {}&quot;, phrases::english::farewells::goodbye());

    println!(&quot;Hello in Japanese: {}&quot;, phrases::japanese::greetings::hello());
    println!(&quot;Goodbye in Japanese: {}&quot;, phrases::japanese::farewells::goodbye());
}
</code></pre>
<p>The <code>extern crate</code> declaration tells Rust that we need to compile and link to
the <code>phrases</code> crate. We can then use <code>phrases</code>’ modules in this one. As we
mentioned earlier, you can use double colons to refer to sub-modules and the
functions inside of them.</p>
<p>(Note: when importing a crate that has dashes in its name &quot;like-this&quot;, which is
not a valid Rust identifier, it will be converted by changing the dashes to
underscores, so you would write <code>extern crate like_this;</code>.)</p>
<p>Also, Cargo assumes that <code>src/main.rs</code> is the crate root of a binary crate,
rather than a library crate. Our package now has two crates: <code>src/lib.rs</code> and
<code>src/main.rs</code>. This pattern is quite common for executable crates: most
functionality is in a library crate, and the executable crate uses that
library. This way, other programs can also use the library crate, and it’s also
a nice separation of concerns.</p>
<p>This doesn’t quite work yet, though. We get four errors that look similar to
this:</p>
<pre><code class="language-bash">$ cargo build
   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)
src/main.rs:4:38: 4:72 error: function `hello` is private
src/main.rs:4     println!(&quot;Hello in English: {}&quot;, phrases::english::greetings::hello());
                                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
note: in expansion of format_args!
&lt;std macros&gt;:2:25: 2:58 note: expansion site
&lt;std macros&gt;:1:1: 2:62 note: in expansion of print!
&lt;std macros&gt;:3:1: 3:54 note: expansion site
&lt;std macros&gt;:1:1: 3:58 note: in expansion of println!
phrases/src/main.rs:4:5: 4:76 note: expansion site
</code></pre>
<p>By default, everything is private in Rust. Let’s talk about this in some more
depth.</p>
<h1>Exporting a Public Interface</h1>
<p>Rust allows you to precisely control which aspects of your interface are
public, and so private is the default. To make things public, you use the <code>pub</code>
keyword. Let’s focus on the <code>english</code> module first, so let’s reduce our <code>src/main.rs</code>
to only this:</p>
<pre><code class="language-rust,ignore">extern crate phrases;

fn main() {
    println!(&quot;Hello in English: {}&quot;, phrases::english::greetings::hello());
    println!(&quot;Goodbye in English: {}&quot;, phrases::english::farewells::goodbye());
}
</code></pre>
<p>In our <code>src/lib.rs</code>, let’s add <code>pub</code> to the <code>english</code> module declaration:</p>
<pre><code class="language-rust,ignore">pub mod english;
mod japanese;
</code></pre>
<p>And in our <code>src/english/mod.rs</code>, let’s make both <code>pub</code>:</p>
<pre><code class="language-rust,ignore">pub mod greetings;
pub mod farewells;
</code></pre>
<p>In our <code>src/english/greetings.rs</code>, let’s add <code>pub</code> to our <code>fn</code> declaration:</p>
<pre><code class="language-rust,ignore">pub fn hello() -&gt; String {
    &quot;Hello!&quot;.to_string()
}
</code></pre>
<p>And also in <code>src/english/farewells.rs</code>:</p>
<pre><code class="language-rust,ignore">pub fn goodbye() -&gt; String {
    &quot;Goodbye.&quot;.to_string()
}
</code></pre>
<p>Now, our crate compiles, albeit with warnings about not using the <code>japanese</code>
functions:</p>
<pre><code class="language-bash">$ cargo run
   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)
src/japanese/greetings.rs:1:1: 3:2 warning: function is never used: `hello`, #[warn(dead_code)] on by default
src/japanese/greetings.rs:1 fn hello() -&gt; String {
src/japanese/greetings.rs:2     &quot;こんにちは&quot;.to_string()
src/japanese/greetings.rs:3 }
src/japanese/farewells.rs:1:1: 3:2 warning: function is never used: `goodbye`, #[warn(dead_code)] on by default
src/japanese/farewells.rs:1 fn goodbye() -&gt; String {
src/japanese/farewells.rs:2     &quot;さようなら&quot;.to_string()
src/japanese/farewells.rs:3 }
     Running `target/debug/phrases`
Hello in English: Hello!
Goodbye in English: Goodbye.
</code></pre>
<p><code>pub</code> also applies to <code>struct</code>s and their member fields. In keeping with Rust’s
tendency toward safety, simply making a <code>struct</code> public won't automatically
make its members public: you must mark the fields individually with <code>pub</code>.</p>
<p>Now that our functions are public, we can use them. Great! However, typing out
<code>phrases::english::greetings::hello()</code> is very long and repetitive. Rust has
another keyword for importing names into the current scope, so that you can
refer to them with shorter names. Let’s talk about <code>use</code>.</p>
<h1>Importing Modules with <code>use</code></h1>
<p>Rust has a <code>use</code> keyword, which allows us to import names into our local scope.
Let’s change our <code>src/main.rs</code> to look like this:</p>
<pre><code class="language-rust,ignore">extern crate phrases;

use phrases::english::greetings;
use phrases::english::farewells;

fn main() {
    println!(&quot;Hello in English: {}&quot;, greetings::hello());
    println!(&quot;Goodbye in English: {}&quot;, farewells::goodbye());
}
</code></pre>
<p>The two <code>use</code> lines import each module into the local scope, so we can refer to
the functions by a much shorter name. By convention, when importing functions, it’s
considered best practice to import the module, rather than the function directly. In
other words, you <em>can</em> do this:</p>
<pre><code class="language-rust,ignore">extern crate phrases;

use phrases::english::greetings::hello;
use phrases::english::farewells::goodbye;

fn main() {
    println!(&quot;Hello in English: {}&quot;, hello());
    println!(&quot;Goodbye in English: {}&quot;, goodbye());
}
</code></pre>
<p>But it is not idiomatic. This is significantly more likely to introduce a
naming conflict. In our short program, it’s not a big deal, but as it grows, it
becomes a problem. If we have conflicting names, Rust will give a compilation
error. For example, if we made the <code>japanese</code> functions public, and tried to do
this:</p>
<pre><code class="language-rust,ignore">extern crate phrases;

use phrases::english::greetings::hello;
use phrases::japanese::greetings::hello;

fn main() {
    println!(&quot;Hello in English: {}&quot;, hello());
    println!(&quot;Hello in Japanese: {}&quot;, hello());
}
</code></pre>
<p>Rust will give us a compile-time error:</p>
<pre><code class="language-text">   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)
src/main.rs:4:5: 4:40 error: a value named `hello` has already been imported in this module [E0252]
src/main.rs:4 use phrases::japanese::greetings::hello;
                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
error: aborting due to previous error
Could not compile `phrases`.
</code></pre>
<p>If we’re importing multiple names from the same module, we don’t have to type it out
twice. Instead of this:</p>
<pre><code class="language-rust,ignore">use phrases::english::greetings;
use phrases::english::farewells;
</code></pre>
<p>We can use this shortcut:</p>
<pre><code class="language-rust,ignore">use phrases::english::{greetings, farewells};
</code></pre>
<h2>Re-exporting with <code>pub use</code></h2>
<p>You don’t only use <code>use</code> to shorten identifiers. You can also use it inside of your crate
to re-export a function inside another module. This allows you to present an external
interface that may not directly map to your internal code organization.</p>
<p>Let’s look at an example. Modify your <code>src/main.rs</code> to read like this:</p>
<pre><code class="language-rust,ignore">extern crate phrases;

use phrases::english::{greetings,farewells};
use phrases::japanese;

fn main() {
    println!(&quot;Hello in English: {}&quot;, greetings::hello());
    println!(&quot;Goodbye in English: {}&quot;, farewells::goodbye());

    println!(&quot;Hello in Japanese: {}&quot;, japanese::hello());
    println!(&quot;Goodbye in Japanese: {}&quot;, japanese::goodbye());
}
</code></pre>
<p>Then, modify your <code>src/lib.rs</code> to make the <code>japanese</code> mod public:</p>
<pre><code class="language-rust,ignore">pub mod english;
pub mod japanese;
</code></pre>
<p>Next, make the two functions public, first in <code>src/japanese/greetings.rs</code>:</p>
<pre><code class="language-rust,ignore">pub fn hello() -&gt; String {
    &quot;こんにちは&quot;.to_string()
}
</code></pre>
<p>And then in <code>src/japanese/farewells.rs</code>:</p>
<pre><code class="language-rust,ignore">pub fn goodbye() -&gt; String {
    &quot;さようなら&quot;.to_string()
}
</code></pre>
<p>Finally, modify your <code>src/japanese/mod.rs</code> to read like this:</p>
<pre><code class="language-rust,ignore">pub use self::greetings::hello;
pub use self::farewells::goodbye;

mod greetings;
mod farewells;
</code></pre>
<p>The <code>pub use</code> declaration brings the function into scope at this part of our
module hierarchy. Because we’ve <code>pub use</code>d this inside of our <code>japanese</code>
module, we now have a <code>phrases::japanese::hello()</code> function and a
<code>phrases::japanese::goodbye()</code> function, even though the code for them lives in
<code>phrases::japanese::greetings::hello()</code> and
<code>phrases::japanese::farewells::goodbye()</code>. Our internal organization doesn’t
define our external interface.</p>
<p>Here we have a <code>pub use</code> for each function we want to bring into the
<code>japanese</code> scope. We could alternatively use the wildcard syntax to include
everything from <code>greetings</code> into the current scope: <code>pub use self::greetings::*</code>.</p>
<p>What about the <code>self</code>? Well, by default, <code>use</code> declarations are absolute paths,
starting from your crate root. <code>self</code> makes that path relative to your current
place in the hierarchy instead. There’s one more special form of <code>use</code>: you can
<code>use super::</code> to reach one level up the tree from your current location. Some
people like to think of <code>self</code> as <code>.</code> and <code>super</code> as <code>..</code>, from many shells’
display for the current directory and the parent directory.</p>
<p>Outside of <code>use</code>, paths are relative: <code>foo::bar()</code> refers to a function inside
of <code>foo</code> relative to where we are. If that’s prefixed with <code>::</code>, as in
<code>::foo::bar()</code>, it refers to a different <code>foo</code>, an absolute path from your
crate root.</p>
<p>This will build and run:</p>
<pre><code class="language-bash">$ cargo run
   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)
     Running `target/debug/phrases`
Hello in English: Hello!
Goodbye in English: Goodbye.
Hello in Japanese: こんにちは
Goodbye in Japanese: さようなら
</code></pre>
<h2>Complex imports</h2>
<p>Rust offers several advanced options that can add compactness and
convenience to your <code>extern crate</code> and <code>use</code> statements. Here is an example:</p>
<pre><code class="language-rust,ignore">extern crate phrases as sayings;

use sayings::japanese::greetings as ja_greetings;
use sayings::japanese::farewells::*;
use sayings::english::{self, greetings as en_greetings, farewells as en_farewells};

fn main() {
    println!(&quot;Hello in English; {}&quot;, en_greetings::hello());
    println!(&quot;And in Japanese: {}&quot;, ja_greetings::hello());
    println!(&quot;Goodbye in English: {}&quot;, english::farewells::goodbye());
    println!(&quot;Again: {}&quot;, en_farewells::goodbye());
    println!(&quot;And in Japanese: {}&quot;, goodbye());
}
</code></pre>
<p>What's going on here?</p>
<p>First, both <code>extern crate</code> and <code>use</code> allow renaming the thing that is being
imported. So the crate is still called &quot;phrases&quot;, but here we will refer
to it as &quot;sayings&quot;. Similarly, the first <code>use</code> statement pulls in the
<code>japanese::greetings</code> module from the crate, but makes it available as
<code>ja_greetings</code> as opposed to simply <code>greetings</code>. This can help to avoid
ambiguity when importing similarly-named items from different places.</p>
<p>The second <code>use</code> statement uses a star glob to bring in all public symbols from
the <code>sayings::japanese::farewells</code> module. As you can see we can later refer to
the Japanese <code>goodbye</code> function with no module qualifiers. This kind of glob
should be used sparingly. It’s worth noting that it only imports the public
symbols, even if the code doing the globbing is in the same module.</p>
<p>The third <code>use</code> statement bears more explanation. It's using &quot;brace expansion&quot;
globbing to compress three <code>use</code> statements into one (this sort of syntax
may be familiar if you've written Linux shell scripts before). The
uncompressed form of this statement would be:</p>
<pre><code class="language-rust,ignore">use sayings::english;
use sayings::english::greetings as en_greetings;
use sayings::english::farewells as en_farewells;
</code></pre>
<p>As you can see, the curly brackets compress <code>use</code> statements for several items
under the same path, and in this context <code>self</code> refers back to that path.
Note: The curly brackets cannot be nested or mixed with star globbing.</p>
<blockquote>
<p><em>commit 5c61be6</em></p>
</blockquote>
<p>% <code>const</code> and <code>static</code></p>
<p>Rust has a way of defining constants with the <code>const</code> keyword:</p>
<pre><code class="language-rust">const N: i32 = 5;
</code></pre>
<p>Unlike [<code>let</code>]<a href="variable-bindings.html">let</a> bindings, you must annotate the type of a <code>const</code>.</p>
<p>Constants live for the entire lifetime of a program. More specifically,
constants in Rust have no fixed address in memory. This is because they’re
effectively inlined to each place that they’re used. References to the same
constant are not necessarily guaranteed to refer to the same memory address for
this reason.</p>
<h1><code>static</code></h1>
<p>Rust provides a ‘global variable’ sort of facility in static items. They’re
similar to constants, but static items aren’t inlined upon use. This means that
there is only one instance for each value, and it’s at a fixed location in
memory.</p>
<p>Here’s an example:</p>
<pre><code class="language-rust">static N: i32 = 5;
</code></pre>
<p>Unlike [<code>let</code>]<a href="variable-bindings.html">let</a> bindings, you must annotate the type of a <code>static</code>.</p>
<p>Statics live for the entire lifetime of a program, and therefore any
reference stored in a constant has a <a href="lifetimes.html"><code>'static</code> lifetime</a>:</p>
<pre><code class="language-rust">static NAME: &amp;'static str = &quot;Steve&quot;;
</code></pre>
<h2>Mutability</h2>
<p>You can introduce mutability with the <code>mut</code> keyword:</p>
<pre><code class="language-rust">static mut N: i32 = 5;
</code></pre>
<p>Because this is mutable, one thread could be updating <code>N</code> while another is
reading it, causing memory unsafety. As such both accessing and mutating a
<code>static mut</code> is [<code>unsafe</code>]<a href="unsafe.html">unsafe</a>, and so must be done in an <code>unsafe</code> block:</p>
<pre><code class="language-rust"># static mut N: i32 = 5;

unsafe {
    N += 1;

    println!(&quot;N: {}&quot;, N);
}
</code></pre>
<p>Furthermore, any type stored in a <code>static</code> must be <code>Sync</code>, and may not have
a [<code>Drop</code>]<a href="drop.html">drop</a> implementation.</p>
<h1>Initializing</h1>
<p>Both <code>const</code> and <code>static</code> have requirements for giving them a value. They may
only be given a value that’s a constant expression. In other words, you cannot
use the result of a function call or anything similarly complex or at runtime.</p>
<h1>Which construct should I use?</h1>
<p>Almost always, if you can choose between the two, choose <code>const</code>. It’s pretty
rare that you actually want a memory location associated with your constant,
and using a const allows for optimizations like constant propagation not only
in your crate but downstream crates.</p>
<blockquote>
<p><em>commit 9eda98a</em></p>
</blockquote>
<p>% Attributes</p>
<p>Declarations can be annotated with ‘attributes’ in Rust. They look like this:</p>
<pre><code class="language-rust">#[test]
# fn foo() {}
</code></pre>
<p>or like this:</p>
<pre><code class="language-rust"># mod foo {
#![test]
# }
</code></pre>
<p>The difference between the two is the <code>!</code>, which changes what the attribute
applies to:</p>
<pre><code class="language-rust,ignore">#[foo]
struct Foo;

mod bar {
    #![bar]
}
</code></pre>
<p>The <code>#[foo]</code> attribute applies to the next item, which is the <code>struct</code>
declaration. The <code>#![bar]</code> attribute applies to the item enclosing it, which is
the <code>mod</code> declaration. Otherwise, they’re the same. Both change the meaning of
the item they’re attached to somehow.</p>
<p>For example, consider a function like this:</p>
<pre><code class="language-rust">#[test]
fn check() {
    assert_eq!(2, 1 + 1);
}
</code></pre>
<p>It is marked with <code>#[test]</code>. This means it’s special: when you run
<a href="testing.html">tests</a>, this function will execute. When you compile as usual, it won’t
even be included. This function is now a test function.</p>
<p>Attributes may also have additional data:</p>
<pre><code class="language-rust">#[inline(always)]
fn super_fast_fn() {
# }
</code></pre>
<p>Or even keys and values:</p>
<pre><code class="language-rust">#[cfg(target_os = &quot;macos&quot;)]
mod macos_only {
# }
</code></pre>
<p>Rust attributes are used for a number of different things. There is a full list
of attributes <a href="../reference.html#attributes">in the reference</a>. Currently, you are not allowed to
create your own attributes, the Rust compiler defines them.</p>
<blockquote>
<p><em>commit 024aa9a</em></p>
</blockquote>
<p>% <code>type</code> Aliases</p>
<p>The <code>type</code> keyword lets you declare an alias of another type:</p>
<pre><code class="language-rust">type Name = String;
</code></pre>
<p>You can then use this type as if it were a real type:</p>
<pre><code class="language-rust">type Name = String;

let x: Name = &quot;Hello&quot;.to_string();
</code></pre>
<p>Note, however, that this is an <em>alias</em>, not a new type entirely. In other
words, because Rust is strongly typed, you’d expect a comparison between two
different types to fail:</p>
<pre><code class="language-rust,ignore">let x: i32 = 5;
let y: i64 = 5;

if x == y {
   // ...
}
</code></pre>
<p>this gives</p>
<pre><code class="language-text">error: mismatched types:
 expected `i32`,
    found `i64`
(expected i32,
    found i64) [E0308]
     if x == y {
             ^
</code></pre>
<p>But, if we had an alias:</p>
<pre><code class="language-rust">type Num = i32;

let x: i32 = 5;
let y: Num = 5;

if x == y {
   // ...
}
</code></pre>
<p>This compiles without error. Values of a <code>Num</code> type are the same as a value of
type <code>i32</code>, in every way. You can use <a href="structs.html#tuple-structs">tuple struct</a> to really get a new type.</p>
<p>You can also use type aliases with generics:</p>
<pre><code class="language-rust">use std::result;

enum ConcreteError {
    Foo,
    Bar,
}

type Result&lt;T&gt; = result::Result&lt;T, ConcreteError&gt;;
</code></pre>
<p>This creates a specialized version of the <code>Result</code> type, which always has a
<code>ConcreteError</code> for the <code>E</code> part of <code>Result&lt;T, E&gt;</code>. This is commonly used
in the standard library to create custom errors for each subsection. For
example, <a href="../std/io/type.Result.html">io::Result</a>.</p>
<blockquote>
<p><em>commit 63bb3e6</em></p>
</blockquote>
<p>% Casting Between Types</p>
<p>Rust, with its focus on safety, provides two different ways of casting
different types between each other. The first, <code>as</code>, is for safe casts.
In contrast, <code>transmute</code> allows for arbitrary casting, and is one of the
most dangerous features of Rust!</p>
<h1>Coercion</h1>
<p>Coercion between types is implicit and has no syntax of its own, but can
be spelled out with [<code>as</code>](#explicit-coercions).</p>
<p>Coercion occurs in <code>let</code>, <code>const</code>, and <code>static</code> statements; in
function call arguments; in field values in struct initialization; and in a
function result.</p>
<p>The most common case of coercion is removing mutability from a reference:</p>
<ul>
<li><code>&amp;mut T</code> to <code>&amp;T</code></li>
</ul>
<p>An analogous conversion is to remove mutability from a
<a href="raw-pointers.md">raw pointer</a>:</p>
<ul>
<li><code>*mut T</code> to <code>*const T</code></li>
</ul>
<p>References can also be coerced to raw pointers:</p>
<ul>
<li>
<p><code>&amp;T</code> to <code>*const T</code></p>
</li>
<li>
<p><code>&amp;mut T</code> to <code>*mut T</code></p>
</li>
</ul>
<p>Custom coercions may be defined using [<code>Deref</code>](deref-coercions.md).</p>
<p>Coercion is transitive.</p>
<h1><code>as</code></h1>
<p>The <code>as</code> keyword does safe casting:</p>
<pre><code class="language-rust">let x: i32 = 5;

let y = x as i64;
</code></pre>
<p>There are three major categories of safe cast: explicit coercions, casts
between numeric types, and pointer casts.</p>
<p>Casting is not transitive: even if <code>e as U1 as U2</code> is a valid
expression, <code>e as U2</code> is not necessarily so (in fact it will only be valid if
<code>U1</code> coerces to <code>U2</code>).</p>
<h2>Explicit coercions</h2>
<p>A cast <code>e as U</code> is valid if <code>e</code> has type <code>T</code> and <code>T</code> <em>coerces</em> to <code>U</code>.</p>
<h2>Numeric casts</h2>
<p>A cast <code>e as U</code> is also valid in any of the following cases:</p>
<ul>
<li><code>e</code> has type <code>T</code> and <code>T</code> and <code>U</code> are any numeric types; <em>numeric-cast</em></li>
<li><code>e</code> is a C-like enum (with no data attached to the variants),
and <code>U</code> is an integer type; <em>enum-cast</em></li>
<li><code>e</code> has type <code>bool</code> or <code>char</code> and <code>U</code> is an integer type; <em>prim-int-cast</em></li>
<li><code>e</code> has type <code>u8</code> and <code>U</code> is <code>char</code>; <em>u8-char-cast</em></li>
</ul>
<p>For example</p>
<pre><code class="language-rust">let one = true as u8;
let at_sign = 64 as char;
let two_hundred = -56i8 as u8;
</code></pre>
<p>The semantics of numeric casts are:</p>
<ul>
<li>Casting between two integers of the same size (e.g. i32 -&gt; u32) is a no-op</li>
<li>Casting from a larger integer to a smaller integer (e.g. u32 -&gt; u8) will
truncate</li>
<li>Casting from a smaller integer to a larger integer (e.g. u8 -&gt; u32) will
<ul>
<li>zero-extend if the source is unsigned</li>
<li>sign-extend if the source is signed</li>
</ul>
</li>
<li>Casting from a float to an integer will round the float towards zero
<ul>
<li><strong><a href="https://github.com/rust-lang/rust/issues/10184">NOTE: currently this will cause Undefined Behavior if the rounded
value cannot be represented by the target integer type</a></strong>.
This includes Inf and NaN. This is a bug and will be fixed.</li>
</ul>
</li>
<li>Casting from an integer to float will produce the floating point
representation of the integer, rounded if necessary (rounding strategy
unspecified)</li>
<li>Casting from an f32 to an f64 is perfect and lossless</li>
<li>Casting from an f64 to an f32 will produce the closest possible value
(rounding strategy unspecified)
<ul>
<li><strong><a href="https://github.com/rust-lang/rust/issues/15536">NOTE: currently this will cause Undefined Behavior if the value
is finite but larger or smaller than the largest or smallest finite
value representable by f32</a></strong>. This is a bug and will
be fixed.</li>
</ul>
</li>
</ul>
<h2>Pointer casts</h2>
<p>Perhaps surprisingly, it is safe to cast <a href="raw-pointers.md">raw pointers</a> to and
from integers, and to cast between pointers to different types subject to
some constraints. It is only unsafe to dereference the pointer:</p>
<pre><code class="language-rust">let a = 300 as *const char; // a pointer to location 300
let b = a as u32;
</code></pre>
<p><code>e as U</code> is a valid pointer cast in any of the following cases:</p>
<ul>
<li>
<p><code>e</code> has type <code>*T</code>, <code>U</code> has type <code>*U_0</code>, and either <code>U_0: Sized</code> or
<code>unsize_kind(T) == unsize_kind(U_0)</code>; a <em>ptr-ptr-cast</em></p>
</li>
<li>
<p><code>e</code> has type <code>*T</code> and <code>U</code> is a numeric type, while <code>T: Sized</code>; <em>ptr-addr-cast</em></p>
</li>
<li>
<p><code>e</code> is an integer and <code>U</code> is <code>*U_0</code>, while <code>U_0: Sized</code>; <em>addr-ptr-cast</em></p>
</li>
<li>
<p><code>e</code> has type <code>&amp;[T; n]</code> and <code>U</code> is <code>*const T</code>; <em>array-ptr-cast</em></p>
</li>
<li>
<p><code>e</code> is a function pointer type and <code>U</code> has type <code>*T</code>,
while <code>T: Sized</code>; <em>fptr-ptr-cast</em></p>
</li>
<li>
<p><code>e</code> is a function pointer type and <code>U</code> is an integer; <em>fptr-addr-cast</em></p>
</li>
</ul>
<h1><code>transmute</code></h1>
<p><code>as</code> only allows safe casting, and will for example reject an attempt to
cast four bytes into a <code>u32</code>:</p>
<pre><code class="language-rust,ignore">let a = [0u8, 0u8, 0u8, 0u8];

let b = a as u32; // four eights makes 32
</code></pre>
<p>This errors with:</p>
<pre><code class="language-text">error: non-scalar cast: `[u8; 4]` as `u32`
let b = a as u32; // four eights makes 32
        ^~~~~~~~
</code></pre>
<p>This is a ‘non-scalar cast’ because we have multiple values here: the four
elements of the array. These kinds of casts are very dangerous, because they
make assumptions about the way that multiple underlying structures are
implemented. For this, we need something more dangerous.</p>
<p>The <code>transmute</code> function is provided by a <a href="intrinsics.html">compiler intrinsic</a>, and
what it does is very simple, but very scary. It tells Rust to treat a value of
one type as though it were another type. It does this regardless of the
typechecking system, and completely trusts you.</p>
<p>In our previous example, we know that an array of four <code>u8</code>s represents a <code>u32</code>
properly, and so we want to do the cast. Using <code>transmute</code> instead of <code>as</code>,
Rust lets us:</p>
<pre><code class="language-rust">use std::mem;

unsafe {
    let a = [0u8, 0u8, 0u8, 0u8];

    let b = mem::transmute::&lt;[u8; 4], u32&gt;(a);
}
</code></pre>
<p>We have to wrap the operation in an <code>unsafe</code> block for this to compile
successfully. Technically, only the <code>mem::transmute</code> call itself needs to be in
the block, but it's nice in this case to enclose everything related, so you
know where to look. In this case, the details about <code>a</code> are also important, and
so they're in the block. You'll see code in either style, sometimes the context
is too far away, and wrapping all of the code in <code>unsafe</code> isn't a great idea.</p>
<p>While <code>transmute</code> does very little checking, it will at least make sure that
the types are the same size. This errors:</p>
<pre><code class="language-rust,ignore">use std::mem;

unsafe {
    let a = [0u8, 0u8, 0u8, 0u8];

    let b = mem::transmute::&lt;[u8; 4], u64&gt;(a);
}
</code></pre>
<p>with:</p>
<pre><code class="language-text">error: transmute called with differently sized types: [u8; 4] (32 bits) to u64
(64 bits)
</code></pre>
<p>Other than that, you're on your own!</p>
<blockquote>
<p><em>commit 6ba9520</em></p>
</blockquote>
<p>% Associated Types</p>
<p>Associated types are a powerful part of Rust’s type system. They’re related to
the idea of a ‘type family’, in other words, grouping multiple types together. That
description is a bit abstract, so let’s dive right into an example. If you want
to write a <code>Graph</code> trait, you have two types to be generic over: the node type
and the edge type. So you might write a trait, <code>Graph&lt;N, E&gt;</code>, that looks like
this:</p>
<pre><code class="language-rust">trait Graph&lt;N, E&gt; {
    fn has_edge(&amp;self, &amp;N, &amp;N) -&gt; bool;
    fn edges(&amp;self, &amp;N) -&gt; Vec&lt;E&gt;;
    // etc
}
</code></pre>
<p>While this sort of works, it ends up being awkward. For example, any function
that wants to take a <code>Graph</code> as a parameter now <em>also</em> needs to be generic over
the <code>N</code>ode and <code>E</code>dge types too:</p>
<pre><code class="language-rust,ignore">fn distance&lt;N, E, G: Graph&lt;N, E&gt;&gt;(graph: &amp;G, start: &amp;N, end: &amp;N) -&gt; u32 { ... }
</code></pre>
<p>Our distance calculation works regardless of our <code>Edge</code> type, so the <code>E</code> stuff in
this signature is a distraction.</p>
<p>What we really want to say is that a certain <code>E</code>dge and <code>N</code>ode type come together
to form each kind of <code>Graph</code>. We can do that with associated types:</p>
<pre><code class="language-rust">trait Graph {
    type N;
    type E;

    fn has_edge(&amp;self, &amp;Self::N, &amp;Self::N) -&gt; bool;
    fn edges(&amp;self, &amp;Self::N) -&gt; Vec&lt;Self::E&gt;;
    // etc
}
</code></pre>
<p>Now, our clients can be abstract over a given <code>Graph</code>:</p>
<pre><code class="language-rust,ignore">fn distance&lt;G: Graph&gt;(graph: &amp;G, start: &amp;G::N, end: &amp;G::N) -&gt; u32 { ... }
</code></pre>
<p>No need to deal with the <code>E</code>dge type here!</p>
<p>Let’s go over all this in more detail.</p>
<h2>Defining associated types</h2>
<p>Let’s build that <code>Graph</code> trait. Here’s the definition:</p>
<pre><code class="language-rust">trait Graph {
    type N;
    type E;

    fn has_edge(&amp;self, &amp;Self::N, &amp;Self::N) -&gt; bool;
    fn edges(&amp;self, &amp;Self::N) -&gt; Vec&lt;Self::E&gt;;
}
</code></pre>
<p>Simple enough. Associated types use the <code>type</code> keyword, and go inside the body
of the trait, with the functions.</p>
<p>These <code>type</code> declarations can have all the same thing as functions do. For example,
if we wanted our <code>N</code> type to implement <code>Display</code>, so we can print the nodes out,
we could do this:</p>
<pre><code class="language-rust">use std::fmt;

trait Graph {
    type N: fmt::Display;
    type E;

    fn has_edge(&amp;self, &amp;Self::N, &amp;Self::N) -&gt; bool;
    fn edges(&amp;self, &amp;Self::N) -&gt; Vec&lt;Self::E&gt;;
}
</code></pre>
<h2>Implementing associated types</h2>
<p>Just like any trait, traits that use associated types use the <code>impl</code> keyword to
provide implementations. Here’s a simple implementation of Graph:</p>
<pre><code class="language-rust"># trait Graph {
#     type N;
#     type E;
#     fn has_edge(&amp;self, &amp;Self::N, &amp;Self::N) -&gt; bool;
#     fn edges(&amp;self, &amp;Self::N) -&gt; Vec&lt;Self::E&gt;;
# }
struct Node;

struct Edge;

struct MyGraph;

impl Graph for MyGraph {
    type N = Node;
    type E = Edge;

    fn has_edge(&amp;self, n1: &amp;Node, n2: &amp;Node) -&gt; bool {
        true
    }

    fn edges(&amp;self, n: &amp;Node) -&gt; Vec&lt;Edge&gt; {
        Vec::new()
    }
}
</code></pre>
<p>This silly implementation always returns <code>true</code> and an empty <code>Vec&lt;Edge&gt;</code>, but it
gives you an idea of how to implement this kind of thing. We first need three
<code>struct</code>s, one for the graph, one for the node, and one for the edge. If it made
more sense to use a different type, that would work as well, we’re going to
use <code>struct</code>s for all three here.</p>
<p>Next is the <code>impl</code> line, which is an implementation like any other trait.</p>
<p>From here, we use <code>=</code> to define our associated types. The name the trait uses
goes on the left of the <code>=</code>, and the concrete type we’re <code>impl</code>ementing this
for goes on the right. Finally, we use the concrete types in our function
declarations.</p>
<h2>Trait objects with associated types</h2>
<p>There’s one more bit of syntax we should talk about: trait objects. If you
try to create a trait object from an associated type, like this:</p>
<pre><code class="language-rust,ignore"># trait Graph {
#     type N;
#     type E;
#     fn has_edge(&amp;self, &amp;Self::N, &amp;Self::N) -&gt; bool;
#     fn edges(&amp;self, &amp;Self::N) -&gt; Vec&lt;Self::E&gt;;
# }
# struct Node;
# struct Edge;
# struct MyGraph;
# impl Graph for MyGraph {
#     type N = Node;
#     type E = Edge;
#     fn has_edge(&amp;self, n1: &amp;Node, n2: &amp;Node) -&gt; bool {
#         true
#     }
#     fn edges(&amp;self, n: &amp;Node) -&gt; Vec&lt;Edge&gt; {
#         Vec::new()
#     }
# }
let graph = MyGraph;
let obj = Box::new(graph) as Box&lt;Graph&gt;;
</code></pre>
<p>You’ll get two errors:</p>
<pre><code class="language-text">error: the value of the associated type `E` (from the trait `main::Graph`) must
be specified [E0191]
let obj = Box::new(graph) as Box&lt;Graph&gt;;
          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
24:44 error: the value of the associated type `N` (from the trait
`main::Graph`) must be specified [E0191]
let obj = Box::new(graph) as Box&lt;Graph&gt;;
          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</code></pre>
<p>We can’t create a trait object like this, because we don’t know the associated
types. Instead, we can write this:</p>
<pre><code class="language-rust"># trait Graph {
#     type N;
#     type E;
#     fn has_edge(&amp;self, &amp;Self::N, &amp;Self::N) -&gt; bool;
#     fn edges(&amp;self, &amp;Self::N) -&gt; Vec&lt;Self::E&gt;;
# }
# struct Node;
# struct Edge;
# struct MyGraph;
# impl Graph for MyGraph {
#     type N = Node;
#     type E = Edge;
#     fn has_edge(&amp;self, n1: &amp;Node, n2: &amp;Node) -&gt; bool {
#         true
#     }
#     fn edges(&amp;self, n: &amp;Node) -&gt; Vec&lt;Edge&gt; {
#         Vec::new()
#     }
# }
let graph = MyGraph;
let obj = Box::new(graph) as Box&lt;Graph&lt;N=Node, E=Edge&gt;&gt;;
</code></pre>
<p>The <code>N=Node</code> syntax allows us to provide a concrete type, <code>Node</code>, for the <code>N</code>
type parameter. Same with <code>E=Edge</code>. If we didn’t provide this constraint, we
couldn’t be sure which <code>impl</code> to match this trait object to.</p>
<blockquote>
<p><em>commit 6ba9520</em></p>
</blockquote>
<p>% Unsized Types</p>
<p>Most types have a particular size, in bytes, that is knowable at compile time.
For example, an <code>i32</code> is thirty-two bits big, or four bytes. However, there are
some types which are useful to express, but do not have a defined size. These are
called ‘unsized’ or ‘dynamically sized’ types. One example is <code>[T]</code>. This type
represents a certain number of <code>T</code> in sequence. But we don’t know how many
there are, so the size is not known.</p>
<p>Rust understands a few of these types, but they have some restrictions. There
are three:</p>
<ol>
<li>We can only manipulate an instance of an unsized type via a pointer. An
<code>&amp;[T]</code> works fine, but a <code>[T]</code> does not.</li>
<li>Variables and arguments cannot have dynamically sized types.</li>
<li>Only the last field in a <code>struct</code> may have a dynamically sized type; the
other fields must not. Enum variants must not have dynamically sized types as
data.</li>
</ol>
<p>So why bother? Well, because <code>[T]</code> can only be used behind a pointer, if we
didn’t have language support for unsized types, it would be impossible to write
this:</p>
<pre><code class="language-rust,ignore">impl Foo for str {
</code></pre>
<p>or</p>
<pre><code class="language-rust,ignore">impl&lt;T&gt; Foo for [T] {
</code></pre>
<p>Instead, you would have to write:</p>
<pre><code class="language-rust,ignore">impl Foo for &amp;str {
</code></pre>
<p>Meaning, this implementation would only work for <a href="references-and-borrowing.html">references</a>, and not
other types of pointers. With the <code>impl for str</code>, all pointers, including (at
some point, there are some bugs to fix first) user-defined custom smart
pointers, can use this <code>impl</code>.</p>
<h1>?Sized</h1>
<p>If you want to write a function that accepts a dynamically sized type, you
can use the special bound, <code>?Sized</code>:</p>
<pre><code class="language-rust">struct Foo&lt;T: ?Sized&gt; {
    f: T,
}
</code></pre>
<p>This <code>?</code>, read as “T may be <code>Sized</code>”,  means that this bound is special: it
lets us match more kinds, not less. It’s almost like every <code>T</code> implicitly has
<code>T: Sized</code>, and the <code>?</code> undoes this default.</p>
<blockquote>
<p><em>commit 6ba9520</em></p>
</blockquote>
<p>% Operators and Overloading</p>
<p>Rust allows for a limited form of operator overloading. There are certain
operators that are able to be overloaded. To support a particular operator
between types, there’s a specific trait that you can implement, which then
overloads the operator.</p>
<p>For example, the <code>+</code> operator can be overloaded with the <code>Add</code> trait:</p>
<pre><code class="language-rust">use std::ops::Add;

#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point { x: self.x + other.x, y: self.y + other.y }
    }
}

fn main() {
    let p1 = Point { x: 1, y: 0 };
    let p2 = Point { x: 2, y: 3 };

    let p3 = p1 + p2;

    println!(&quot;{:?}&quot;, p3);
}
</code></pre>
<p>In <code>main</code>, we can use <code>+</code> on our two <code>Point</code>s, since we’ve implemented
<code>Add&lt;Output=Point&gt;</code> for <code>Point</code>.</p>
<p>There are a number of operators that can be overloaded this way, and all of
their associated traits live in the [<code>std::ops</code>]<a href="../std/ops/index.html">stdops</a> module. Check out its
documentation for the full list.</p>
<p>Implementing these traits follows a pattern. Let’s look at [<code>Add</code>]<a href="../std/ops/trait.Add.html">add</a> in more
detail:</p>
<pre><code class="language-rust"># mod foo {
pub trait Add&lt;RHS = Self&gt; {
    type Output;

    fn add(self, rhs: RHS) -&gt; Self::Output;
}
# }
</code></pre>
<p>There’s three types in total involved here: the type you <code>impl Add</code> for, <code>RHS</code>,
which defaults to <code>Self</code>, and <code>Output</code>. For an expression <code>let z = x + y</code>, <code>x</code>
is the <code>Self</code> type, <code>y</code> is the RHS, and <code>z</code> is the <code>Self::Output</code> type.</p>
<pre><code class="language-rust"># struct Point;
# use std::ops::Add;
impl Add&lt;i32&gt; for Point {
    type Output = f64;

    fn add(self, rhs: i32) -&gt; f64 {
        // add an i32 to a Point and get an f64
# 1.0
    }
}
</code></pre>
<p>will let you do this:</p>
<pre><code class="language-rust,ignore">let p: Point = // ...
let x: f64 = p + 2i32;
</code></pre>
<h1>Using operator traits in generic structs</h1>
<p>Now that we know how operator traits are defined, we can define our <code>HasArea</code>
trait and <code>Square</code> struct from the <a href="traits.html">traits chapter</a> more generically:</p>
<pre><code class="language-rust">use std::ops::Mul;

trait HasArea&lt;T&gt; {
    fn area(&amp;self) -&gt; T;
}

struct Square&lt;T&gt; {
    x: T,
    y: T,
    side: T,
}

impl&lt;T&gt; HasArea&lt;T&gt; for Square&lt;T&gt;
        where T: Mul&lt;Output=T&gt; + Copy {
    fn area(&amp;self) -&gt; T {
        self.side * self.side
    }
}

fn main() {
    let s = Square {
        x: 0.0f64,
        y: 0.0f64,
        side: 12.0f64,
    };

    println!(&quot;Area of s: {}&quot;, s.area());
}
</code></pre>
<p>For <code>HasArea</code> and <code>Square</code>, we declare a type parameter <code>T</code> and replace
<code>f64</code> with it. The <code>impl</code> needs more involved modifications:</p>
<pre><code class="language-ignore">impl&lt;T&gt; HasArea&lt;T&gt; for Square&lt;T&gt;
        where T: Mul&lt;Output=T&gt; + Copy { ... }
</code></pre>
<p>The <code>area</code> method requires that we can multiply the sides, so we declare that
type <code>T</code> must implement <code>std::ops::Mul</code>. Like <code>Add</code>, mentioned above, <code>Mul</code>
itself takes an <code>Output</code> parameter: since we know that numbers don't change
type when multiplied, we also set it to <code>T</code>. <code>T</code> must also support copying, so
Rust doesn't try to move <code>self.side</code> into the return value.</p>
<blockquote>
<p><em>commit 6ba9520</em></p>
</blockquote>
<p>% <code>Deref</code> coercions</p>
<p>The standard library provides a special trait, [<code>Deref</code>]<a href="../std/ops/trait.Deref.html">deref</a>. It’s normally
used to overload <code>*</code>, the dereference operator:</p>
<pre><code class="language-rust">use std::ops::Deref;

struct DerefExample&lt;T&gt; {
    value: T,
}

impl&lt;T&gt; Deref for DerefExample&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        &amp;self.value
    }
}

fn main() {
    let x = DerefExample { value: 'a' };
    assert_eq!('a', *x);
}
</code></pre>
<p>This is useful for writing custom pointer types. However, there’s a language
feature related to <code>Deref</code>: ‘deref coercions’. Here’s the rule: If you have a
type <code>U</code>, and it implements <code>Deref&lt;Target=T&gt;</code>, values of <code>&amp;U</code> will
automatically coerce to a <code>&amp;T</code>. Here’s an example:</p>
<pre><code class="language-rust">fn foo(s: &amp;str) {
    // borrow a string for a second
}

// String implements Deref&lt;Target=str&gt;
let owned = &quot;Hello&quot;.to_string();

// therefore, this works:
foo(&amp;owned);
</code></pre>
<p>Using an ampersand in front of a value takes a reference to it. So <code>owned</code> is a
<code>String</code>, <code>&amp;owned</code> is an <code>&amp;String</code>, and since <code>impl Deref&lt;Target=str&gt; for String</code>, <code>&amp;String</code> will deref to <code>&amp;str</code>, which <code>foo()</code> takes.</p>
<p>That’s it. This rule is one of the only places in which Rust does an automatic
conversion for you, but it adds a lot of flexibility. For example, the <code>Rc&lt;T&gt;</code>
type implements <code>Deref&lt;Target=T&gt;</code>, so this works:</p>
<pre><code class="language-rust">use std::rc::Rc;

fn foo(s: &amp;str) {
    // borrow a string for a second
}

// String implements Deref&lt;Target=str&gt;
let owned = &quot;Hello&quot;.to_string();
let counted = Rc::new(owned);

// therefore, this works:
foo(&amp;counted);
</code></pre>
<p>All we’ve done is wrap our <code>String</code> in an <code>Rc&lt;T&gt;</code>. But we can now pass the
<code>Rc&lt;String&gt;</code> around anywhere we’d have a <code>String</code>. The signature of <code>foo</code>
didn’t change, but works just as well with either type. This example has two
conversions: <code>Rc&lt;String&gt;</code> to <code>String</code> and then <code>String</code> to <code>&amp;str</code>. Rust will do
this as many times as possible until the types match.</p>
<p>Another very common implementation provided by the standard library is:</p>
<pre><code class="language-rust">fn foo(s: &amp;[i32]) {
    // borrow a slice for a second
}

// Vec&lt;T&gt; implements Deref&lt;Target=[T]&gt;
let owned = vec![1, 2, 3];

foo(&amp;owned);
</code></pre>
<p>Vectors can <code>Deref</code> to a slice.</p>
<h2>Deref and method calls</h2>
<p><code>Deref</code> will also kick in when calling a method. Consider the following
example.</p>
<pre><code class="language-rust">struct Foo;

impl Foo {
    fn foo(&amp;self) { println!(&quot;Foo&quot;); }
}

let f = &amp;&amp;Foo;

f.foo();
</code></pre>
<p>Even though <code>f</code> is a <code>&amp;&amp;Foo</code> and <code>foo</code> takes <code>&amp;self</code>, this works. That’s
because these things are the same:</p>
<pre><code class="language-rust,ignore">f.foo();
(&amp;f).foo();
(&amp;&amp;f).foo();
(&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;f).foo();
</code></pre>
<p>A value of type <code>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;Foo</code> can still have methods defined on <code>Foo</code>
called, because the compiler will insert as many * operations as necessary to
get it right. And since it’s inserting <code>*</code>s, that uses <code>Deref</code>.</p>
<blockquote>
<p><em>commit 024aa9a</em></p>
</blockquote>
<p>% Macros</p>
<p>By now you’ve learned about many of the tools Rust provides for abstracting and
reusing code. These units of code reuse have a rich semantic structure. For
example, functions have a type signature, type parameters have trait bounds,
and overloaded functions must belong to a particular trait.</p>
<p>This structure means that Rust’s core abstractions have powerful compile-time
correctness checking. But this comes at the price of reduced flexibility. If
you visually identify a pattern of repeated code, you may find it’s difficult
or cumbersome to express that pattern as a generic function, a trait, or
anything else within Rust’s semantics.</p>
<p>Macros allow us to abstract at a syntactic level. A macro invocation is
shorthand for an &quot;expanded&quot; syntactic form. This expansion happens early in
compilation, before any static checking. As a result, macros can capture many
patterns of code reuse that Rust’s core abstractions cannot.</p>
<p>The drawback is that macro-based code can be harder to understand, because
fewer of the built-in rules apply. Like an ordinary function, a well-behaved
macro can be used without understanding its implementation. However, it can be
difficult to design a well-behaved macro!  Additionally, compiler errors in
macro code are harder to interpret, because they describe problems in the
expanded code, not the source-level form that developers use.</p>
<p>These drawbacks make macros something of a &quot;feature of last resort&quot;. That’s not
to say that macros are bad; they are part of Rust because sometimes they’re
needed for truly concise, well-abstracted code. Just keep this tradeoff in
mind.</p>
<h1>Defining a macro</h1>
<p>You may have seen the <code>vec!</code> macro, used to initialize a <a href="vectors.html">vector</a> with
any number of elements.</p>
<pre><code class="language-rust">let x: Vec&lt;u32&gt; = vec![1, 2, 3];
# assert_eq!(x, [1, 2, 3]);
</code></pre>
<p>This can’t be an ordinary function, because it takes any number of arguments.
But we can imagine it as syntactic shorthand for</p>
<pre><code class="language-rust">let x: Vec&lt;u32&gt; = {
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
};
# assert_eq!(x, [1, 2, 3]);
</code></pre>
<p>We can implement this shorthand, using a macro: <sup class="footnote-reference"><a href="#actual">1</a></sup></p>
<div class="footnote-definition" id="actual"><sup class="footnote-definition-label">1</sup>
<p>The actual definition of <code>vec!</code> in libcollections differs from the
one presented here, for reasons of efficiency and reusability.</p>
<pre><code class="language-rust">macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
# fn main() {
#     assert_eq!(vec![1,2,3], [1, 2, 3]);
# }
</code></pre>
<p>Whoa, that’s a lot of new syntax! Let’s break it down.</p>
<pre><code class="language-ignore">macro_rules! vec { ... }
</code></pre>
<p>This says we’re defining a macro named <code>vec</code>, much as <code>fn vec</code> would define a
function named <code>vec</code>. In prose, we informally write a macro’s name with an
exclamation point, e.g. <code>vec!</code>. The exclamation point is part of the invocation
syntax and serves to distinguish a macro from an ordinary function.</p>
<h2>Matching</h2>
<p>The macro is defined through a series of rules, which are pattern-matching
cases. Above, we had</p>
<pre><code class="language-ignore">( $( $x:expr ),* ) =&gt; { ... };
</code></pre>
<p>This is like a <code>match</code> expression arm, but the matching happens on Rust syntax
trees, at compile time. The semicolon is optional on the last (here, only)
case. The &quot;pattern&quot; on the left-hand side of <code>=&gt;</code> is known as a ‘matcher’.
These have <a href="../reference.html#macros">their own little grammar</a> within the language.</p>
<p>The matcher <code>$x:expr</code> will match any Rust expression, binding that syntax tree
to the ‘metavariable’ <code>$x</code>. The identifier <code>expr</code> is a ‘fragment specifier’;
the full possibilities are enumerated later in this chapter.
Surrounding the matcher with <code>$(...),*</code> will match zero or more expressions,
separated by commas.</p>
<p>Aside from the special matcher syntax, any Rust tokens that appear in a matcher
must match exactly. For example,</p>
<pre><code class="language-rust">macro_rules! foo {
    (x =&gt; $e:expr) =&gt; (println!(&quot;mode X: {}&quot;, $e));
    (y =&gt; $e:expr) =&gt; (println!(&quot;mode Y: {}&quot;, $e));
}

fn main() {
    foo!(y =&gt; 3);
}
</code></pre>
<p>will print</p>
<pre><code class="language-text">mode Y: 3
</code></pre>
<p>With</p>
<pre><code class="language-rust,ignore">foo!(z =&gt; 3);
</code></pre>
<p>we get the compiler error</p>
<pre><code class="language-text">error: no rules expected the token `z`
</code></pre>
<h2>Expansion</h2>
<p>The right-hand side of a macro rule is ordinary Rust syntax, for the most part.
But we can splice in bits of syntax captured by the matcher. From the original
example:</p>
<pre><code class="language-ignore">$(
    temp_vec.push($x);
)*
</code></pre>
<p>Each matched expression <code>$x</code> will produce a single <code>push</code> statement in the
macro expansion. The repetition in the expansion proceeds in &quot;lockstep&quot; with
repetition in the matcher (more on this in a moment).</p>
<p>Because <code>$x</code> was already declared as matching an expression, we don’t repeat
<code>:expr</code> on the right-hand side. Also, we don’t include a separating comma as
part of the repetition operator. Instead, we have a terminating semicolon
within the repeated block.</p>
<p>Another detail: the <code>vec!</code> macro has <em>two</em> pairs of braces on the right-hand
side. They are often combined like so:</p>
<pre><code class="language-ignore">macro_rules! foo {
    () =&gt; {{
        ...
    }}
}
</code></pre>
<p>The outer braces are part of the syntax of <code>macro_rules!</code>. In fact, you can use
<code>()</code> or <code>[]</code> instead. They simply delimit the right-hand side as a whole.</p>
<p>The inner braces are part of the expanded syntax. Remember, the <code>vec!</code> macro is
used in an expression context. To write an expression with multiple statements,
including <code>let</code>-bindings, we use a block. If your macro expands to a single
expression, you don’t need this extra layer of braces.</p>
<p>Note that we never <em>declared</em> that the macro produces an expression. In fact,
this is not determined until we use the macro as an expression. With care, you
can write a macro whose expansion works in several contexts. For example,
shorthand for a data type could be valid as either an expression or a pattern.</p>
<h2>Repetition</h2>
<p>The repetition operator follows two principal rules:</p>
<ol>
<li><code>$(...)*</code> walks through one &quot;layer&quot; of repetitions, for all of the <code>$name</code>s
it contains, in lockstep, and</li>
<li>each <code>$name</code> must be under at least as many <code>$(...)*</code>s as it was matched
against. If it is under more, it’ll be duplicated, as appropriate.</li>
</ol>
<p>This baroque macro illustrates the duplication of variables from outer
repetition levels.</p>
<pre><code class="language-rust">macro_rules! o_O {
    (
        $(
            $x:expr; [ $( $y:expr ),* ]
        );*
    ) =&gt; {
        &amp;[ $($( $x + $y ),*),* ]
    }
}

fn main() {
    let a: &amp;[i32]
        = o_O!(10; [1, 2, 3];
               20; [4, 5, 6]);

    assert_eq!(a, [11, 12, 13, 24, 25, 26]);
}
</code></pre>
<p>That’s most of the matcher syntax. These examples use <code>$(...)*</code>, which is a
&quot;zero or more&quot; match. Alternatively you can write <code>$(...)+</code> for a &quot;one or
more&quot; match. Both forms optionally include a separator, which can be any token
except <code>+</code> or <code>*</code>.</p>
<p>This system is based on
&quot;<a href="https://www.cs.indiana.edu/ftp/techreports/TR206.pdf">Macro-by-Example</a>&quot;
(PDF link).</p>
<h1>Hygiene</h1>
<p>Some languages implement macros using simple text substitution, which leads to
various problems. For example, this C program prints <code>13</code> instead of the
expected <code>25</code>.</p>
<pre><code class="language-text">#define FIVE_TIMES(x) 5 * x

int main() {
    printf(&quot;%d\n&quot;, FIVE_TIMES(2 + 3));
    return 0;
}
</code></pre>
<p>After expansion we have <code>5 * 2 + 3</code>, and multiplication has greater precedence
than addition. If you’ve used C macros a lot, you probably know the standard
idioms for avoiding this problem, as well as five or six others. In Rust, we
don’t have to worry about it.</p>
<pre><code class="language-rust">macro_rules! five_times {
    ($x:expr) =&gt; (5 * $x);
}

fn main() {
    assert_eq!(25, five_times!(2 + 3));
}
</code></pre>
<p>The metavariable <code>$x</code> is parsed as a single expression node, and keeps its
place in the syntax tree even after substitution.</p>
<p>Another common problem in macro systems is ‘variable capture’. Here’s a C
macro, using <a href="https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html">a GNU C extension</a> to emulate Rust’s expression blocks.</p>
<pre><code class="language-text">#define LOG(msg) ({ \
    int state = get_log_state(); \
    if (state &gt; 0) { \
        printf(&quot;log(%d): %s\n&quot;, state, msg); \
    } \
})
</code></pre>
<p>Here’s a simple use case that goes terribly wrong:</p>
<pre><code class="language-text">const char *state = &quot;reticulating splines&quot;;
LOG(state)
</code></pre>
<p>This expands to</p>
<pre><code class="language-text">const char *state = &quot;reticulating splines&quot;;
{
    int state = get_log_state();
    if (state &gt; 0) {
        printf(&quot;log(%d): %s\n&quot;, state, state);
    }
}
</code></pre>
<p>The second variable named <code>state</code> shadows the first one.  This is a problem
because the print statement should refer to both of them.</p>
<p>The equivalent Rust macro has the desired behavior.</p>
<pre><code class="language-rust"># fn get_log_state() -&gt; i32 { 3 }
macro_rules! log {
    ($msg:expr) =&gt; {{
        let state: i32 = get_log_state();
        if state &gt; 0 {
            println!(&quot;log({}): {}&quot;, state, $msg);
        }
    }};
}

fn main() {
    let state: &amp;str = &quot;reticulating splines&quot;;
    log!(state);
}
</code></pre>
<p>This works because Rust has a <a href="https://en.wikipedia.org/wiki/Hygienic_macro">hygienic macro system</a>. Each macro expansion
happens in a distinct ‘syntax context’, and each variable is tagged with the
syntax context where it was introduced. It’s as though the variable <code>state</code>
inside <code>main</code> is painted a different &quot;color&quot; from the variable <code>state</code> inside
the macro, and therefore they don’t conflict.</p>
<p>This also restricts the ability of macros to introduce new bindings at the
invocation site. Code such as the following will not work:</p>
<pre><code class="language-rust,ignore">macro_rules! foo {
    () =&gt; (let x = 3);
}

fn main() {
    foo!();
    println!(&quot;{}&quot;, x);
}
</code></pre>
<p>Instead you need to pass the variable name into the invocation, so it’s tagged
with the right syntax context.</p>
<pre><code class="language-rust">macro_rules! foo {
    ($v:ident) =&gt; (let $v = 3);
}

fn main() {
    foo!(x);
    println!(&quot;{}&quot;, x);
}
</code></pre>
<p>This holds for <code>let</code> bindings and loop labels, but not for <a href="../reference.html#items">items</a>.
So the following code does compile:</p>
<pre><code class="language-rust">macro_rules! foo {
    () =&gt; (fn x() { });
}

fn main() {
    foo!();
    x();
}
</code></pre>
<h1>Recursive macros</h1>
<p>A macro’s expansion can include more macro invocations, including invocations
of the very same macro being expanded.  These recursive macros are useful for
processing tree-structured input, as illustrated by this (simplistic) HTML
shorthand:</p>
<pre><code class="language-rust"># #![allow(unused_must_use)]
macro_rules! write_html {
    ($w:expr, ) =&gt; (());

    ($w:expr, $e:tt) =&gt; (write!($w, &quot;{}&quot;, $e));

    ($w:expr, $tag:ident [ $($inner:tt)* ] $($rest:tt)*) =&gt; {{
        write!($w, &quot;&lt;{}&gt;&quot;, stringify!($tag));
        write_html!($w, $($inner)*);
        write!($w, &quot;&lt;/{}&gt;&quot;, stringify!($tag));
        write_html!($w, $($rest)*);
    }};
}

fn main() {
#   // FIXME(#21826)
    use std::fmt::Write;
    let mut out = String::new();

    write_html!(&amp;mut out,
        html[
            head[title[&quot;Macros guide&quot;]]
            body[h1[&quot;Macros are the best!&quot;]]
        ]);

    assert_eq!(out,
        &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Macros guide&lt;/title&gt;&lt;/head&gt;\
         &lt;body&gt;&lt;h1&gt;Macros are the best!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;);
}
</code></pre>
<h1>Debugging macro code</h1>
<p>To see the results of expanding macros, run <code>rustc --pretty expanded</code>. The
output represents a whole crate, so you can also feed it back in to <code>rustc</code>,
which will sometimes produce better error messages than the original
compilation. Note that the <code>--pretty expanded</code> output may have a different
meaning if multiple variables of the same name (but different syntax contexts)
are in play in the same scope. In this case <code>--pretty expanded,hygiene</code> will
tell you about the syntax contexts.</p>
<p><code>rustc</code> provides two syntax extensions that help with macro debugging. For now,
they are unstable and require feature gates.</p>
<ul>
<li>
<p><code>log_syntax!(...)</code> will print its arguments to standard output, at compile
time, and &quot;expand&quot; to nothing.</p>
</li>
<li>
<p><code>trace_macros!(true)</code> will enable a compiler message every time a macro is
expanded. Use <code>trace_macros!(false)</code> later in expansion to turn it off.</p>
</li>
</ul>
<h1>Syntactic requirements</h1>
<p>Even when Rust code contains un-expanded macros, it can be parsed as a full
<a href="glossary.html#abstract-syntax-tree">syntax tree</a>. This property can be very useful for editors and other
tools that process code. It also has a few consequences for the design of
Rust’s macro system.</p>
<p>One consequence is that Rust must determine, when it parses a macro invocation,
whether the macro stands in for</p>
<ul>
<li>zero or more items,</li>
<li>zero or more methods,</li>
<li>an expression,</li>
<li>a statement, or</li>
<li>a pattern.</li>
</ul>
<p>A macro invocation within a block could stand for some items, or for an
expression / statement. Rust uses a simple rule to resolve this ambiguity. A
macro invocation that stands for items must be either</p>
<ul>
<li>delimited by curly braces, e.g. <code>foo! { ... }</code>, or</li>
<li>terminated by a semicolon, e.g. <code>foo!(...);</code></li>
</ul>
<p>Another consequence of pre-expansion parsing is that the macro invocation must
consist of valid Rust tokens. Furthermore, parentheses, brackets, and braces
must be balanced within a macro invocation. For example, <code>foo!([)</code> is
forbidden. This allows Rust to know where the macro invocation ends.</p>
<p>More formally, the macro invocation body must be a sequence of ‘token trees’.
A token tree is defined recursively as either</p>
<ul>
<li>a sequence of token trees surrounded by matching <code>()</code>, <code>[]</code>, or <code>{}</code>, or</li>
<li>any other single token.</li>
</ul>
<p>Within a matcher, each metavariable has a ‘fragment specifier’, identifying
which syntactic form it matches.</p>
<ul>
<li><code>ident</code>: an identifier. Examples: <code>x</code>; <code>foo</code>.</li>
<li><code>path</code>: a qualified name. Example: <code>T::SpecialA</code>.</li>
<li><code>expr</code>: an expression. Examples: <code>2 + 2</code>; <code>if true { 1 } else { 2 }</code>; <code>f(42)</code>.</li>
<li><code>ty</code>: a type. Examples: <code>i32</code>; <code>Vec&lt;(char, String)&gt;</code>; <code>&amp;T</code>.</li>
<li><code>pat</code>: a pattern. Examples: <code>Some(t)</code>; <code>(17, 'a')</code>; <code>_</code>.</li>
<li><code>stmt</code>: a single statement. Example: <code>let x = 3</code>.</li>
<li><code>block</code>: a brace-delimited sequence of statements. Example:
<code>{ log(error, &quot;hi&quot;); return 12; }</code>.</li>
<li><code>item</code>: an <a href="../reference.html#items">item</a>. Examples: <code>fn foo() { }</code>; <code>struct Bar;</code>.</li>
<li><code>meta</code>: a &quot;meta item&quot;, as found in attributes. Example: <code>cfg(target_os = &quot;windows&quot;)</code>.</li>
<li><code>tt</code>: a single token tree.</li>
</ul>
<p>There are additional rules regarding the next token after a metavariable:</p>
<ul>
<li><code>expr</code> and <code>stmt</code> variables may only be followed by one of: <code>=&gt; , ;</code></li>
<li><code>ty</code> and <code>path</code> variables may only be followed by one of: <code>=&gt; , = | ; : &gt; [ { as where</code></li>
<li><code>pat</code> variables may only be followed by one of: <code>=&gt; , = | if in</code></li>
<li>Other variables may be followed by any token.</li>
</ul>
<p>These rules provide some flexibility for Rust’s syntax to evolve without
breaking existing macros.</p>
<p>The macro system does not deal with parse ambiguity at all. For example, the
grammar <code>$($i:ident)* $e:expr</code> will always fail to parse, because the parser would
be forced to choose between parsing <code>$i</code> and parsing <code>$e</code>. Changing the
invocation syntax to put a distinctive token in front can solve the problem. In
this case, you can write <code>$(I $i:ident)* E $e:expr</code>.</p>
<h1>Scoping and macro import/export</h1>
<p>Macros are expanded at an early stage in compilation, before name resolution.
One downside is that scoping works differently for macros, compared to other
constructs in the language.</p>
<p>Definition and expansion of macros both happen in a single depth-first,
lexical-order traversal of a crate’s source. So a macro defined at module scope
is visible to any subsequent code in the same module, which includes the body
of any subsequent child <code>mod</code> items.</p>
<p>A macro defined within the body of a single <code>fn</code>, or anywhere else not at
module scope, is visible only within that item.</p>
<p>If a module has the <code>macro_use</code> attribute, its macros are also visible in its
parent module after the child’s <code>mod</code> item. If the parent also has <code>macro_use</code>
then the macros will be visible in the grandparent after the parent’s <code>mod</code>
item, and so forth.</p>
<p>The <code>macro_use</code> attribute can also appear on <code>extern crate</code>. In this context
it controls which macros are loaded from the external crate, e.g.</p>
<pre><code class="language-rust,ignore">#[macro_use(foo, bar)]
extern crate baz;
</code></pre>
<p>If the attribute is given simply as <code>#[macro_use]</code>, all macros are loaded. If
there is no <code>#[macro_use]</code> attribute then no macros are loaded. Only macros
defined with the <code>#[macro_export]</code> attribute may be loaded.</p>
<p>To load a crate’s macros without linking it into the output, use <code>#[no_link]</code>
as well.</p>
<p>An example:</p>
<pre><code class="language-rust">macro_rules! m1 { () =&gt; (()) }

// visible here: m1

mod foo {
    // visible here: m1

    #[macro_export]
    macro_rules! m2 { () =&gt; (()) }

    // visible here: m1, m2
}

// visible here: m1

macro_rules! m3 { () =&gt; (()) }

// visible here: m1, m3

#[macro_use]
mod bar {
    // visible here: m1, m3

    macro_rules! m4 { () =&gt; (()) }

    // visible here: m1, m3, m4
}

// visible here: m1, m3, m4
# fn main() { }
</code></pre>
<p>When this library is loaded with <code>#[macro_use] extern crate</code>, only <code>m2</code> will
be imported.</p>
<p>The Rust Reference has a <a href="../reference.html#macro-related-attributes">listing of macro-related
attributes</a>.</p>
<h1>The variable <code>$crate</code></h1>
<p>A further difficulty occurs when a macro is used in multiple crates. Say that
<code>mylib</code> defines</p>
<pre><code class="language-rust">pub fn increment(x: u32) -&gt; u32 {
    x + 1
}

#[macro_export]
macro_rules! inc_a {
    ($x:expr) =&gt; ( ::increment($x) )
}

#[macro_export]
macro_rules! inc_b {
    ($x:expr) =&gt; ( ::mylib::increment($x) )
}
# fn main() { }
</code></pre>
<p><code>inc_a</code> only works within <code>mylib</code>, while <code>inc_b</code> only works outside the
library. Furthermore, <code>inc_b</code> will break if the user imports <code>mylib</code> under
another name.</p>
<p>Rust does not (yet) have a hygiene system for crate references, but it does
provide a simple workaround for this problem. Within a macro imported from a
crate named <code>foo</code>, the special macro variable <code>$crate</code> will expand to <code>::foo</code>.
By contrast, when a macro is defined and then used in the same crate, <code>$crate</code>
will expand to nothing. This means we can write</p>
<pre><code class="language-rust">#[macro_export]
macro_rules! inc {
    ($x:expr) =&gt; ( $crate::increment($x) )
}
# fn main() { }
</code></pre>
<p>to define a single macro that works both inside and outside our library. The
function name will expand to either <code>::increment</code> or <code>::mylib::increment</code>.</p>
<p>To keep this system simple and correct, <code>#[macro_use] extern crate ...</code> may
only appear at the root of your crate, not inside <code>mod</code>.</p>
<h1>The deep end</h1>
<p>The introductory chapter mentioned recursive macros, but it did not give the
full story. Recursive macros are useful for another reason: Each recursive
invocation gives you another opportunity to pattern-match the macro’s
arguments.</p>
<p>As an extreme example, it is possible, though hardly advisable, to implement
the <a href="https://esolangs.org/wiki/Bitwise_Cyclic_Tag">Bitwise Cyclic Tag</a> automaton
within Rust’s macro system.</p>
<pre><code class="language-rust">macro_rules! bct {
    // cmd 0:  d ... =&gt; ...
    (0, $($ps:tt),* ; $_d:tt)
        =&gt; (bct!($($ps),*, 0 ; ));
    (0, $($ps:tt),* ; $_d:tt, $($ds:tt),*)
        =&gt; (bct!($($ps),*, 0 ; $($ds),*));

    // cmd 1p:  1 ... =&gt; 1 ... p
    (1, $p:tt, $($ps:tt),* ; 1)
        =&gt; (bct!($($ps),*, 1, $p ; 1, $p));
    (1, $p:tt, $($ps:tt),* ; 1, $($ds:tt),*)
        =&gt; (bct!($($ps),*, 1, $p ; 1, $($ds),*, $p));

    // cmd 1p:  0 ... =&gt; 0 ...
    (1, $p:tt, $($ps:tt),* ; $($ds:tt),*)
        =&gt; (bct!($($ps),*, 1, $p ; $($ds),*));

    // halt on empty data string
    ( $($ps:tt),* ; )
        =&gt; (());
}
</code></pre>
<p>Exercise: use macros to reduce duplication in the above definition of the
<code>bct!</code> macro.</p>
<h1>Common macros</h1>
<p>Here are some common macros you’ll see in Rust code.</p>
<h2>panic!</h2>
<p>This macro causes the current thread to panic. You can give it a message
to panic with:</p>
<pre><code class="language-rust,no_run">panic!(&quot;oh no!&quot;);
</code></pre>
<h2>vec!</h2>
<p>The <code>vec!</code> macro is used throughout the book, so you’ve probably seen it
already. It creates <code>Vec&lt;T&gt;</code>s with ease:</p>
<pre><code class="language-rust">let v = vec![1, 2, 3, 4, 5];
</code></pre>
<p>It also lets you make vectors with repeating values. For example, a hundred
zeroes:</p>
<pre><code class="language-rust">let v = vec![0; 100];
</code></pre>
<h2>assert! and assert_eq!</h2>
<p>These two macros are used in tests. <code>assert!</code> takes a boolean. <code>assert_eq!</code>
takes two values and checks them for equality. <code>true</code> passes, <code>false</code> <code>panic!</code>s.
Like this:</p>
<pre><code class="language-rust,no_run">// A-ok!

assert!(true);
assert_eq!(5, 3 + 2);

// nope :(

assert!(5 &lt; 3);
assert_eq!(5, 3);
</code></pre>
<h2>try!</h2>
<p><code>try!</code> is used for error handling. It takes something that can return a
<code>Result&lt;T, E&gt;</code>, and gives <code>T</code> if it’s a <code>Ok&lt;T&gt;</code>, and <code>return</code>s with the
<code>Err(E)</code> if it’s that. Like this:</p>
<pre><code class="language-rust,no_run">use std::fs::File;

fn foo() -&gt; std::io::Result&lt;()&gt; {
    let f = try!(File::create(&quot;foo.txt&quot;));

    Ok(())
}
</code></pre>
<p>This is cleaner than doing this:</p>
<pre><code class="language-rust,no_run">use std::fs::File;

fn foo() -&gt; std::io::Result&lt;()&gt; {
    let f = File::create(&quot;foo.txt&quot;);

    let f = match f {
        Ok(t) =&gt; t,
        Err(e) =&gt; return Err(e),
    };

    Ok(())
}
</code></pre>
<h2>unreachable!</h2>
<p>This macro is used when you think some code should never execute:</p>
<pre><code class="language-rust">if false {
    unreachable!();
}
</code></pre>
<p>Sometimes, the compiler may make you have a different branch that you know
will never, ever run. In these cases, use this macro, so that if you end
up wrong, you’ll get a <code>panic!</code> about it.</p>
<pre><code class="language-rust">let x: Option&lt;i32&gt; = None;

match x {
    Some(_) =&gt; unreachable!(),
    None =&gt; println!(&quot;I know x is None!&quot;),
}
</code></pre>
<h2>unimplemented!</h2>
<p>The <code>unimplemented!</code> macro can be used when you’re trying to get your functions
to typecheck, and don’t want to worry about writing out the body of the
function. One example of this situation is implementing a trait with multiple
required methods, where you want to tackle one at a time. Define the others
as <code>unimplemented!</code> until you’re ready to write them.</p>
<h1>Procedural macros</h1>
<p>If Rust’s macro system can’t do what you need, you may want to write a
<a href="compiler-plugins.html">compiler plugin</a> instead. Compared to <code>macro_rules!</code>
macros, this is significantly more work, the interfaces are much less stable,
and bugs can be much harder to track down. In exchange you get the
flexibility of running arbitrary Rust code within the compiler. Syntax
extension plugins are sometimes called ‘procedural macros’ for this reason.</p>
</div>
<blockquote>
<p><em>commit fd4d013</em></p>
</blockquote>
<p>% Raw Pointers</p>
<p>Rust has a number of different smart pointer types in its standard library, but
there are two types that are extra-special. Much of Rust’s safety comes from
compile-time checks, but raw pointers don’t have such guarantees, and are
<a href="unsafe.html">unsafe</a> to use.</p>
<p><code>*const T</code> and <code>*mut T</code> are called ‘raw pointers’ in Rust. Sometimes, when
writing certain kinds of libraries, you’ll need to get around Rust’s safety
guarantees for some reason. In this case, you can use raw pointers to implement
your library, while exposing a safe interface for your users. For example, <code>*</code>
pointers are allowed to alias, allowing them to be used to write
shared-ownership types, and even thread-safe shared memory types (the <code>Rc&lt;T&gt;</code>
and <code>Arc&lt;T&gt;</code> types are both implemented entirely in Rust).</p>
<p>Here are some things to remember about raw pointers that are different than
other pointer types. They:</p>
<ul>
<li>are not guaranteed to point to valid memory and are not even
guaranteed to be non-null (unlike both <code>Box</code> and <code>&amp;</code>);</li>
<li>do not have any automatic clean-up, unlike <code>Box</code>, and so require
manual resource management;</li>
<li>are plain-old-data, that is, they don't move ownership, again unlike
<code>Box</code>, hence the Rust compiler cannot protect against bugs like
use-after-free;</li>
<li>lack any form of lifetimes, unlike <code>&amp;</code>, and so the compiler cannot
reason about dangling pointers; and</li>
<li>have no guarantees about aliasing or mutability other than mutation
not being allowed directly through a <code>*const T</code>.</li>
</ul>
<h1>Basics</h1>
<p>Creating a raw pointer is perfectly safe:</p>
<pre><code class="language-rust">let x = 5;
let raw = &amp;x as *const i32;

let mut y = 10;
let raw_mut = &amp;mut y as *mut i32;
</code></pre>
<p>However, dereferencing one is not. This won’t work:</p>
<pre><code class="language-rust,ignore">let x = 5;
let raw = &amp;x as *const i32;

println!(&quot;raw points at {}&quot;, *raw);
</code></pre>
<p>It gives this error:</p>
<pre><code class="language-text">error: dereference of raw pointer requires unsafe function or block [E0133]
     println!(&quot;raw points at {}&quot;, *raw);
                                  ^~~~
</code></pre>
<p>When you dereference a raw pointer, you’re taking responsibility that it’s not
pointing somewhere that would be incorrect. As such, you need <code>unsafe</code>:</p>
<pre><code class="language-rust">let x = 5;
let raw = &amp;x as *const i32;

let points_at = unsafe { *raw };

println!(&quot;raw points at {}&quot;, points_at);
</code></pre>
<p>For more operations on raw pointers, see <a href="../std/primitive.pointer.html">their API documentation</a>.</p>
<h1>FFI</h1>
<p>Raw pointers are useful for FFI: Rust’s <code>*const T</code> and <code>*mut T</code> are similar to
C’s <code>const T*</code> and <code>T*</code>, respectively. For more about this use, consult the
<a href="ffi.html">FFI chapter</a>.</p>
<h1>References and raw pointers</h1>
<p>At runtime, a raw pointer <code>*</code> and a reference pointing to the same piece of
data have an identical representation. In fact, an <code>&amp;T</code> reference will
implicitly coerce to an <code>*const T</code> raw pointer in safe code and similarly for
the <code>mut</code> variants (both coercions can be performed explicitly with,
respectively, <code>value as *const T</code> and <code>value as *mut T</code>).</p>
<p>Going the opposite direction, from <code>*const</code> to a reference <code>&amp;</code>, is not safe. A
<code>&amp;T</code> is always valid, and so, at a minimum, the raw pointer <code>*const T</code> has to
point to a valid instance of type <code>T</code>. Furthermore, the resulting pointer must
satisfy the aliasing and mutability laws of references. The compiler assumes
these properties are true for any references, no matter how they are created,
and so any conversion from raw pointers is asserting that they hold. The
programmer <em>must</em> guarantee this.</p>
<p>The recommended method for the conversion is:</p>
<pre><code class="language-rust">// explicit cast
let i: u32 = 1;
let p_imm: *const u32 = &amp;i as *const u32;

// implicit coercion
let mut m: u32 = 2;
let p_mut: *mut u32 = &amp;mut m;

unsafe {
    let ref_imm: &amp;u32 = &amp;*p_imm;
    let ref_mut: &amp;mut u32 = &amp;mut *p_mut;
}
</code></pre>
<p>The <code>&amp;*x</code> dereferencing style is preferred to using a <code>transmute</code>. The latter
is far more powerful than necessary, and the more restricted operation is
harder to use incorrectly; for example, it requires that <code>x</code> is a pointer
(unlike <code>transmute</code>).</p>
<blockquote>
<p><em>commit 024aa9a</em></p>
</blockquote>
<p>% Unsafe</p>
<p>Rust’s main draw is its powerful static guarantees about behavior. But safety
checks are conservative by nature: there are some programs that are actually
safe, but the compiler is not able to verify this is true. To write these kinds
of programs, we need to tell the compiler to relax its restrictions a bit. For
this, Rust has a keyword, <code>unsafe</code>. Code using <code>unsafe</code> has less restrictions
than normal code does.</p>
<p>Let’s go over the syntax, and then we’ll talk semantics. <code>unsafe</code> is used in
four contexts. The first one is to mark a function as unsafe:</p>
<pre><code class="language-rust">unsafe fn danger_will_robinson() {
    // scary stuff
}
</code></pre>
<p>All functions called from <a href="ffi.html">FFI</a> must be marked as <code>unsafe</code>, for example.
The second use of <code>unsafe</code> is an unsafe block:</p>
<pre><code class="language-rust">unsafe {
    // scary stuff
}
</code></pre>
<p>The third is for unsafe traits:</p>
<pre><code class="language-rust">unsafe trait Scary { }
</code></pre>
<p>And the fourth is for <code>impl</code>ementing one of those traits:</p>
<pre><code class="language-rust"># unsafe trait Scary { }
unsafe impl Scary for i32 {}
</code></pre>
<p>It’s important to be able to explicitly delineate code that may have bugs that
cause big problems. If a Rust program segfaults, you can be sure the cause is
related to something marked <code>unsafe</code>.</p>
<h1>What does ‘safe’ mean?</h1>
<p>Safe, in the context of Rust, means ‘doesn’t do anything unsafe’. It’s also
important to know that there are certain behaviors that are probably not
desirable in your code, but are expressly <em>not</em> unsafe:</p>
<ul>
<li>Deadlocks</li>
<li>Leaks of memory or other resources</li>
<li>Exiting without calling destructors</li>
<li>Integer overflow</li>
</ul>
<p>Rust cannot prevent all kinds of software problems. Buggy code can and will be
written in Rust. These things aren’t great, but they don’t qualify as <code>unsafe</code>
specifically.</p>
<p>In addition, the following are all undefined behaviors in Rust, and must be
avoided, even when writing <code>unsafe</code> code:</p>
<ul>
<li>Data races</li>
<li>Dereferencing a null/dangling raw pointer</li>
<li>Reads of <a href="http://llvm.org/docs/LangRef.html#undefined-values">undef</a> (uninitialized) memory</li>
<li>Breaking the <a href="http://llvm.org/docs/LangRef.html#pointer-aliasing-rules">pointer aliasing rules</a> with raw pointers.</li>
<li><code>&amp;mut T</code> and <code>&amp;T</code> follow LLVM’s scoped <a href="http://llvm.org/docs/LangRef.html#noalias">noalias</a> model, except if
the <code>&amp;T</code> contains an <code>UnsafeCell&lt;U&gt;</code>. Unsafe code must not violate these
aliasing guarantees.</li>
<li>Mutating an immutable value/reference without <code>UnsafeCell&lt;U&gt;</code></li>
<li>Invoking undefined behavior via compiler intrinsics:
<ul>
<li>Indexing outside of the bounds of an object with <code>std::ptr::offset</code>
(<code>offset</code> intrinsic), with
the exception of one byte past the end which is permitted.</li>
<li>Using <code>std::ptr::copy_nonoverlapping_memory</code> (<code>memcpy32</code>/<code>memcpy64</code>
intrinsics) on overlapping buffers</li>
</ul>
</li>
<li>Invalid values in primitive types, even in private fields/locals:
<ul>
<li>Null/dangling references or boxes</li>
<li>A value other than <code>false</code> (0) or <code>true</code> (1) in a <code>bool</code></li>
<li>A discriminant in an <code>enum</code> not included in its type definition</li>
<li>A value in a <code>char</code> which is a surrogate or above <code>char::MAX</code></li>
<li>Non-UTF-8 byte sequences in a <code>str</code></li>
</ul>
</li>
<li>Unwinding into Rust from foreign code or unwinding from Rust into foreign
code.</li>
</ul>
<h1>Unsafe Superpowers</h1>
<p>In both unsafe functions and unsafe blocks, Rust will let you do three things
that you normally can not do. Just three. Here they are:</p>
<ol>
<li>Access or update a <a href="const-and-static.html#static">static mutable variable</a>.</li>
<li>Dereference a raw pointer.</li>
<li>Call unsafe functions. This is the most powerful ability.</li>
</ol>
<p>That’s it. It’s important that <code>unsafe</code> does not, for example, ‘turn off the
borrow checker’. Adding <code>unsafe</code> to some random Rust code doesn’t change its
semantics, it won’t start accepting anything. But it will let you write
things that <em>do</em> break some of the rules.</p>
<p>You will also encounter the <code>unsafe</code> keyword when writing bindings to foreign
(non-Rust) interfaces. You're encouraged to write a safe, native Rust interface
around the methods provided by the library.</p>
<p>Let’s go over the basic three abilities listed, in order.</p>
<h2>Access or update a <code>static mut</code></h2>
<p>Rust has a feature called ‘<code>static mut</code>’ which allows for mutable global state.
Doing so can cause a data race, and as such is inherently not safe. For more
details, see the <a href="const-and-static.html#static">static</a> section of the book.</p>
<h2>Dereference a raw pointer</h2>
<p>Raw pointers let you do arbitrary pointer arithmetic, and can cause a number of
different memory safety and security issues. In some senses, the ability to
dereference an arbitrary pointer is one of the most dangerous things you can
do. For more on raw pointers, see <a href="raw-pointers.html">their section of the book</a>.</p>
<h2>Call unsafe functions</h2>
<p>This last ability works with both aspects of <code>unsafe</code>: you can only call
functions marked <code>unsafe</code> from inside an unsafe block.</p>
<p>This ability is powerful and varied. Rust exposes some <a href="intrinsics.html">compiler
intrinsics</a> as unsafe functions, and some unsafe functions bypass
safety checks, trading safety for speed.</p>
<p>I’ll repeat again: even though you <em>can</em> do arbitrary things in unsafe blocks
and functions doesn’t mean you should. The compiler will act as though you’re
upholding its invariants, so be careful!</p>
<blockquote>
<p><em>commit 07aaca3</em></p>
</blockquote>
<p>% Effective Rust</p>
<p>So you’ve learned how to write some Rust code. But there’s a difference between
writing <em>any</em> Rust code and writing <em>good</em> Rust code.</p>
<p>This chapter consists of relatively independent tutorials which show you how to
take your Rust to the next level. Common patterns and standard library features
will be introduced. Read these sections in any order of your choosing.</p>
<blockquote>
<p><em>commit 3a6dbb3</em></p>
</blockquote>
<p>% The Stack and the Heap</p>
<p>As a systems language, Rust operates at a low level. If you’re coming from a
high-level language, there are some aspects of systems programming that you may
not be familiar with. The most important one is how memory works, with a stack
and a heap. If you’re familiar with how C-like languages use stack allocation,
this chapter will be a refresher. If you’re not, you’ll learn about this more
general concept, but with a Rust-y focus.</p>
<p>As with most things, when learning about them, we’ll use a simplified model to
start. This lets you get a handle on the basics, without getting bogged down
with details which are, for now, irrelevant. The examples we’ll use aren’t 100%
accurate, but are representative for the level we’re trying to learn at right
now. Once you have the basics down, learning more about how allocators are
implemented, virtual memory, and other advanced topics will reveal the leaks in
this particular abstraction.</p>
<h1>Memory management</h1>
<p>These two terms are about memory management. The stack and the heap are
abstractions that help you determine when to allocate and deallocate memory.</p>
<p>Here’s a high-level comparison:</p>
<p>The stack is very fast, and is where memory is allocated in Rust by default.
But the allocation is local to a function call, and is limited in size. The
heap, on the other hand, is slower, and is explicitly allocated by your
program. But it’s effectively unlimited in size, and is globally accessible.</p>
<h1>The Stack</h1>
<p>Let’s talk about this Rust program:</p>
<pre><code class="language-rust">fn main() {
    let x = 42;
}
</code></pre>
<p>This program has one variable binding, <code>x</code>. This memory needs to be allocated
from somewhere. Rust ‘stack allocates’ by default, which means that basic
values ‘go on the stack’. What does that mean?</p>
<p>Well, when a function gets called, some memory gets allocated for all of its
local variables and some other information. This is called a ‘stack frame’, and
for the purpose of this tutorial, we’re going to ignore the extra information
and only consider the local variables we’re allocating. So in this case, when
<code>main()</code> is run, we’ll allocate a single 32-bit integer for our stack frame.
This is automatically handled for you, as you can see; we didn’t have to write
any special Rust code or anything.</p>
<p>When the function exits, its stack frame gets deallocated. This happens
automatically as well.</p>
<p>That’s all there is for this simple program. The key thing to understand here
is that stack allocation is very, very fast. Since we know all the local
variables we have ahead of time, we can grab the memory all at once. And since
we’ll throw them all away at the same time as well, we can get rid of it very
fast too.</p>
<p>The downside is that we can’t keep values around if we need them for longer
than a single function. We also haven’t talked about what the word, ‘stack’,
means. To do that, we need a slightly more complicated example:</p>
<pre><code class="language-rust">fn foo() {
    let y = 5;
    let z = 100;
}

fn main() {
    let x = 42;

    foo();
}
</code></pre>
<p>This program has three variables total: two in <code>foo()</code>, one in <code>main()</code>. Just
as before, when <code>main()</code> is called, a single integer is allocated for its stack
frame. But before we can show what happens when <code>foo()</code> is called, we need to
visualize what’s going on with memory. Your operating system presents a view of
memory to your program that’s pretty simple: a huge list of addresses, from 0
to a large number, representing how much RAM your computer has. For example, if
you have a gigabyte of RAM, your addresses go from <code>0</code> to <code>1,073,741,823</code>. That
number comes from 2<sup>30</sup>, the number of bytes in a gigabyte. <sup class="footnote-reference"><a href="#gigabyte">1</a></sup></p>
<div class="footnote-definition" id="gigabyte"><sup class="footnote-definition-label">1</sup>
<p>‘Gigabyte’ can mean two things: 10^9, or 2^30. The SI standard resolved this by stating that ‘gigabyte’ is 10^9, and ‘gibibyte’ is 2^30. However, very few people use this terminology, and rely on context to differentiate. We follow in that tradition here.</p>
<p>This memory is kind of like a giant array: addresses start at zero and go
up to the final number. So here’s a diagram of our first stack frame:</p>
<table><thead><tr><td> Address </td><td> Name </td><td> Value </td></tr></thead>
<tr><td> 0       </td><td> x    </td><td> 42    </td></tr>
</table>
<p>We’ve got <code>x</code> located at address <code>0</code>, with the value <code>42</code>.</p>
<p>When <code>foo()</code> is called, a new stack frame is allocated:</p>
<table><thead><tr><td> Address </td><td> Name </td><td> Value </td></tr></thead>
<tr><td> 2       </td><td> z    </td><td> 100   </td></tr>
<tr><td> 1       </td><td> y    </td><td> 5     </td></tr>
<tr><td> 0       </td><td> x    </td><td> 42    </td></tr>
</table>
<p>Because <code>0</code> was taken by the first frame, <code>1</code> and <code>2</code> are used for <code>foo()</code>’s
stack frame. It grows upward, the more functions we call.</p>
</div>
<p>There are some important things we have to take note of here. The numbers 0, 1,
and 2 are all solely for illustrative purposes, and bear no relationship to the
address values the computer will use in reality. In particular, the series of
addresses are in reality going to be separated by some number of bytes that
separate each address, and that separation may even exceed the size of the
value being stored.</p>
<p>After <code>foo()</code> is over, its frame is deallocated:</p>
<table><thead><tr><td> Address </td><td> Name </td><td> Value </td></tr></thead>
<tr><td> 0       </td><td> x    </td><td> 42    </td></tr>
</table>
<p>And then, after <code>main()</code>, even this last value goes away. Easy!</p>
<p>It’s called a ‘stack’ because it works like a stack of dinner plates: the first
plate you put down is the last plate to pick back up. Stacks are sometimes
called ‘last in, first out queues’ for this reason, as the last value you put
on the stack is the first one you retrieve from it.</p>
<p>Let’s try a three-deep example:</p>
<pre><code class="language-rust">fn italic() {
    let i = 6;
}

fn bold() {
    let a = 5;
    let b = 100;
    let c = 1;

    italic();
}

fn main() {
    let x = 42;

    bold();
}
</code></pre>
<p>We have some kooky function names to make the diagrams clearer.</p>
<p>Okay, first, we call <code>main()</code>:</p>
<table><thead><tr><td> Address </td><td> Name </td><td> Value </td></tr></thead>
<tr><td> 0       </td><td> x    </td><td> 42    </td></tr>
</table>
<p>Next up, <code>main()</code> calls <code>bold()</code>:</p>
<table><thead><tr><td> Address </td><td> Name </td><td> Value </td></tr></thead>
<tr><td> <strong>3</strong>   </td><td> <strong>c</strong></td><td><strong>1</strong>  </td></tr>
<tr><td> <strong>2</strong>   </td><td> <strong>b</strong></td><td><strong>100</strong></td></tr>
<tr><td> <strong>1</strong>   </td><td> <strong>a</strong></td><td> <strong>5</strong> </td></tr>
<tr><td> 0       </td><td> x    </td><td> 42    </td></tr>
</table>
<p>And then <code>bold()</code> calls <code>italic()</code>:</p>
<table><thead><tr><td> Address </td><td> Name </td><td> Value </td></tr></thead>
<tr><td> <em>4</em>     </td><td> <em>i</em>  </td><td> <em>6</em>   </td></tr>
<tr><td> <strong>3</strong>   </td><td> <strong>c</strong></td><td><strong>1</strong>  </td></tr>
<tr><td> <strong>2</strong>   </td><td> <strong>b</strong></td><td><strong>100</strong></td></tr>
<tr><td> <strong>1</strong>   </td><td> <strong>a</strong></td><td> <strong>5</strong> </td></tr>
<tr><td> 0       </td><td> x    </td><td> 42    </td></tr>
<tr><td>Whew! Our stack is growing tall.</td></tr>
</table>
<p>After <code>italic()</code> is over, its frame is deallocated, leaving only <code>bold()</code> and
<code>main()</code>:</p>
<table><thead><tr><td> Address </td><td> Name </td><td> Value </td></tr></thead>
<tr><td> <strong>3</strong>   </td><td> <strong>c</strong></td><td><strong>1</strong>  </td></tr>
<tr><td> <strong>2</strong>   </td><td> <strong>b</strong></td><td><strong>100</strong></td></tr>
<tr><td> <strong>1</strong>   </td><td> <strong>a</strong></td><td> <strong>5</strong> </td></tr>
<tr><td> 0       </td><td> x    </td><td> 42    </td></tr>
</table>
<p>And then <code>bold()</code> ends, leaving only <code>main()</code>:</p>
<table><thead><tr><td> Address </td><td> Name </td><td> Value </td></tr></thead>
<tr><td> 0       </td><td> x    </td><td> 42    </td></tr>
</table>
<p>And then we’re done. Getting the hang of it? It’s like piling up dishes: you
add to the top, you take away from the top.</p>
<h1>The Heap</h1>
<p>Now, this works pretty well, but not everything can work like this. Sometimes,
you need to pass some memory between different functions, or keep it alive for
longer than a single function’s execution. For this, we can use the heap.</p>
<p>In Rust, you can allocate memory on the heap with the <a href="../std/boxed/index.html"><code>Box&lt;T&gt;</code> type</a>.
Here’s an example:</p>
<pre><code class="language-rust">fn main() {
    let x = Box::new(5);
    let y = 42;
}
</code></pre>
<p>Here’s what happens in memory when <code>main()</code> is called:</p>
<table><thead><tr><td> Address </td><td> Name </td><td> Value  </td></tr></thead>
<tr><td> 1       </td><td> y    </td><td> 42     </td></tr>
<tr><td> 0       </td><td> x    </td><td> ?????? </td></tr>
</table>
<p>We allocate space for two variables on the stack. <code>y</code> is <code>42</code>, as it always has
been, but what about <code>x</code>? Well, <code>x</code> is a <code>Box&lt;i32&gt;</code>, and boxes allocate memory
on the heap. The actual value of the box is a structure which has a pointer to
‘the heap’. When we start executing the function, and <code>Box::new()</code> is called,
it allocates some memory for the heap, and puts <code>5</code> there. The memory now looks
like this:</p>
<table><thead><tr><td> Address              </td><td> Name </td><td> Value                  </td></tr></thead>
<tr><td> (2<sup>30</sup>) - 1 </td><td>      </td><td> 5                      </td></tr>
<tr><td> ...                  </td><td> ...  </td><td> ...                    </td></tr>
<tr><td> 1                    </td><td> y    </td><td> 42                     </td></tr>
<tr><td> 0                    </td><td> x    </td><td> → (2<sup>30</sup>) - 1 </td></tr>
</table>
<p>We have (2<sup>30</sup>) - 1 addresses in our hypothetical computer with 1GB of RAM. And since
our stack grows from zero, the easiest place to allocate memory is from the
other end. So our first value is at the highest place in memory. And the value
of the struct at <code>x</code> has a <a href="raw-pointers.html">raw pointer</a> to the place we’ve
allocated on the heap, so the value of <code>x</code> is (2<sup>30</sup>) - 1, the memory
location we’ve asked for.</p>
<p>We haven’t really talked too much about what it actually means to allocate and
deallocate memory in these contexts. Getting into very deep detail is out of
the scope of this tutorial, but what’s important to point out here is that
the heap isn’t a stack that grows from the opposite end. We’ll have an
example of this later in the book, but because the heap can be allocated and
freed in any order, it can end up with ‘holes’. Here’s a diagram of the memory
layout of a program which has been running for a while now:</p>
<table><thead><tr><td> Address              </td><td> Name </td><td> Value                  </td></tr></thead>
<tr><td> (2<sup>30</sup>) - 1 </td><td>      </td><td> 5                      </td></tr>
<tr><td> (2<sup>30</sup>) - 2 </td><td>      </td><td>                        </td></tr>
<tr><td> (2<sup>30</sup>) - 3 </td><td>      </td><td>                        </td></tr>
<tr><td> (2<sup>30</sup>) - 4 </td><td>      </td><td> 42                     </td></tr>
<tr><td> ...                  </td><td> ...  </td><td> ...                    </td></tr>
<tr><td> 3                    </td><td> y    </td><td> → (2<sup>30</sup>) - 4 </td></tr>
<tr><td> 2                    </td><td> y    </td><td> 42                     </td></tr>
<tr><td> 1                    </td><td> y    </td><td> 42                     </td></tr>
<tr><td> 0                    </td><td> x    </td><td> → (2<sup>30</sup>) - 1 </td></tr>
</table>
<p>In this case, we’ve allocated four things on the heap, but deallocated two of
them. There’s a gap between (2<sup>30</sup>) - 1 and (2<sup>30</sup>) - 4 which isn’t
currently being used. The specific details of how and why this happens depends
on what kind of strategy you use to manage the heap. Different programs can use
different ‘memory allocators’, which are libraries that manage this for you.
Rust programs use <a href="http://www.canonware.com/jemalloc/">jemalloc</a> for this purpose.</p>
<p>Anyway, back to our example. Since this memory is on the heap, it can stay
alive longer than the function which allocates the box. In this case, however,
it doesn’t.<sup class="footnote-reference"><a href="#moving">2</a></sup> When the function is over, we need to free the stack frame
for <code>main()</code>. <code>Box&lt;T&gt;</code>, though, has a trick up its sleeve: <a href="drop.html">Drop</a>. The
implementation of <code>Drop</code> for <code>Box</code> deallocates the memory that was allocated
when it was created. Great! So when <code>x</code> goes away, it first frees the memory
allocated on the heap:</p>
<table><thead><tr><td> Address </td><td> Name </td><td> Value  </td></tr></thead>
<tr><td> 1       </td><td> y    </td><td> 42     </td></tr>
<tr><td> 0       </td><td> x    </td><td> ?????? </td></tr>
</table>
<div class="footnote-definition" id="moving"><sup class="footnote-definition-label">2</sup>
<p>We can make the memory live longer by transferring ownership,
sometimes called ‘moving out of the box’. More complex examples will
be covered later.</p>
</div>
<p>And then the stack frame goes away, freeing all of our memory.</p>
<h1>Arguments and borrowing</h1>
<p>We’ve got some basic examples with the stack and the heap going, but what about
function arguments and borrowing? Here’s a small Rust program:</p>
<pre><code class="language-rust">fn foo(i: &amp;i32) {
    let z = 42;
}

fn main() {
    let x = 5;
    let y = &amp;x;

    foo(y);
}
</code></pre>
<p>When we enter <code>main()</code>, memory looks like this:</p>
<table><thead><tr><td> Address </td><td> Name </td><td> Value  </td></tr></thead>
<tr><td> 1       </td><td> y    </td><td> → 0    </td></tr>
<tr><td> 0       </td><td> x    </td><td> 5      </td></tr>
</table>
<p><code>x</code> is a plain old <code>5</code>, and <code>y</code> is a reference to <code>x</code>. So its value is the
memory location that <code>x</code> lives at, which in this case is <code>0</code>.</p>
<p>What about when we call <code>foo()</code>, passing <code>y</code> as an argument?</p>
<table><thead><tr><td> Address </td><td> Name </td><td> Value  </td></tr></thead>
<tr><td> 3       </td><td> z    </td><td> 42     </td></tr>
<tr><td> 2       </td><td> i    </td><td> → 0    </td></tr>
<tr><td> 1       </td><td> y    </td><td> → 0    </td></tr>
<tr><td> 0       </td><td> x    </td><td> 5      </td></tr>
</table>
<p>Stack frames aren’t only for local bindings, they’re for arguments too. So in
this case, we need to have both <code>i</code>, our argument, and <code>z</code>, our local variable
binding. <code>i</code> is a copy of the argument, <code>y</code>. Since <code>y</code>’s value is <code>0</code>, so is
<code>i</code>’s.</p>
<p>This is one reason why borrowing a variable doesn’t deallocate any memory: the
value of a reference is a pointer to a memory location. If we got rid of
the underlying memory, things wouldn’t work very well.</p>
<h1>A complex example</h1>
<p>Okay, let’s go through this complex program step-by-step:</p>
<pre><code class="language-rust">fn foo(x: &amp;i32) {
    let y = 10;
    let z = &amp;y;

    baz(z);
    bar(x, z);
}

fn bar(a: &amp;i32, b: &amp;i32) {
    let c = 5;
    let d = Box::new(5);
    let e = &amp;d;

    baz(e);
}

fn baz(f: &amp;i32) {
    let g = 100;
}

fn main() {
    let h = 3;
    let i = Box::new(20);
    let j = &amp;h;

    foo(j);
}
</code></pre>
<p>First, we call <code>main()</code>:</p>
<table><thead><tr><td> Address              </td><td> Name </td><td> Value                  </td></tr></thead>
<tr><td> (2<sup>30</sup>) - 1 </td><td>      </td><td> 20                     </td></tr>
<tr><td> ...                  </td><td> ...  </td><td> ...                    </td></tr>
<tr><td> 2                    </td><td> j    </td><td> → 0                    </td></tr>
<tr><td> 1                    </td><td> i    </td><td> → (2<sup>30</sup>) - 1 </td></tr>
<tr><td> 0                    </td><td> h    </td><td> 3                      </td></tr>
</table>
<p>We allocate memory for <code>j</code>, <code>i</code>, and <code>h</code>. <code>i</code> is on the heap, and so has a
value pointing there.</p>
<p>Next, at the end of <code>main()</code>, <code>foo()</code> gets called:</p>
<table><thead><tr><td> Address              </td><td> Name </td><td> Value                  </td></tr></thead>
<tr><td> (2<sup>30</sup>) - 1 </td><td>      </td><td> 20                     </td></tr>
<tr><td> ...                  </td><td> ...  </td><td> ...                    </td></tr>
<tr><td> 5                    </td><td> z    </td><td> → 4                    </td></tr>
<tr><td> 4                    </td><td> y    </td><td> 10                     </td></tr>
<tr><td> 3                    </td><td> x    </td><td> → 0                    </td></tr>
<tr><td> 2                    </td><td> j    </td><td> → 0                    </td></tr>
<tr><td> 1                    </td><td> i    </td><td> → (2<sup>30</sup>) - 1 </td></tr>
<tr><td> 0                    </td><td> h    </td><td> 3                      </td></tr>
</table>
<p>Space gets allocated for <code>x</code>, <code>y</code>, and <code>z</code>. The argument <code>x</code> has the same value
as <code>j</code>, since that’s what we passed it in. It’s a pointer to the <code>0</code> address,
since <code>j</code> points at <code>h</code>.</p>
<p>Next, <code>foo()</code> calls <code>baz()</code>, passing <code>z</code>:</p>
<table><thead><tr><td> Address              </td><td> Name </td><td> Value                  </td></tr></thead>
<tr><td> (2<sup>30</sup>) - 1 </td><td>      </td><td> 20                     </td></tr>
<tr><td> ...                  </td><td> ...  </td><td> ...                    </td></tr>
<tr><td> 7                    </td><td> g    </td><td> 100                    </td></tr>
<tr><td> 6                    </td><td> f    </td><td> → 4                    </td></tr>
<tr><td> 5                    </td><td> z    </td><td> → 4                    </td></tr>
<tr><td> 4                    </td><td> y    </td><td> 10                     </td></tr>
<tr><td> 3                    </td><td> x    </td><td> → 0                    </td></tr>
<tr><td> 2                    </td><td> j    </td><td> → 0                    </td></tr>
<tr><td> 1                    </td><td> i    </td><td> → (2<sup>30</sup>) - 1 </td></tr>
<tr><td> 0                    </td><td> h    </td><td> 3                      </td></tr>
</table>
<p>We’ve allocated memory for <code>f</code> and <code>g</code>. <code>baz()</code> is very short, so when it’s
over, we get rid of its stack frame:</p>
<table><thead><tr><td> Address              </td><td> Name </td><td> Value                  </td></tr></thead>
<tr><td> (2<sup>30</sup>) - 1 </td><td>      </td><td> 20                     </td></tr>
<tr><td> ...                  </td><td> ...  </td><td> ...                    </td></tr>
<tr><td> 5                    </td><td> z    </td><td> → 4                    </td></tr>
<tr><td> 4                    </td><td> y    </td><td> 10                     </td></tr>
<tr><td> 3                    </td><td> x    </td><td> → 0                    </td></tr>
<tr><td> 2                    </td><td> j    </td><td> → 0                    </td></tr>
<tr><td> 1                    </td><td> i    </td><td> → (2<sup>30</sup>) - 1 </td></tr>
<tr><td> 0                    </td><td> h    </td><td> 3                      </td></tr>
</table>
<p>Next, <code>foo()</code> calls <code>bar()</code> with <code>x</code> and <code>z</code>:</p>
<table><thead><tr><td> Address              </td><td> Name </td><td> Value                  </td></tr></thead>
<tr><td> (2<sup>30</sup>) - 1 </td><td>      </td><td> 20                     </td></tr>
<tr><td> (2<sup>30</sup>) - 2 </td><td>      </td><td> 5                      </td></tr>
<tr><td> ...                  </td><td> ...  </td><td> ...                    </td></tr>
<tr><td> 10                   </td><td> e    </td><td> → 9                    </td></tr>
<tr><td> 9                    </td><td> d    </td><td> → (2<sup>30</sup>) - 2 </td></tr>
<tr><td> 8                    </td><td> c    </td><td> 5                      </td></tr>
<tr><td> 7                    </td><td> b    </td><td> → 4                    </td></tr>
<tr><td> 6                    </td><td> a    </td><td> → 0                    </td></tr>
<tr><td> 5                    </td><td> z    </td><td> → 4                    </td></tr>
<tr><td> 4                    </td><td> y    </td><td> 10                     </td></tr>
<tr><td> 3                    </td><td> x    </td><td> → 0                    </td></tr>
<tr><td> 2                    </td><td> j    </td><td> → 0                    </td></tr>
<tr><td> 1                    </td><td> i    </td><td> → (2<sup>30</sup>) - 1 </td></tr>
<tr><td> 0                    </td><td> h    </td><td> 3                      </td></tr>
</table>
<p>We end up allocating another value on the heap, and so we have to subtract one
from (2<sup>30</sup>) - 1. It’s easier to write that than <code>1,073,741,822</code>. In any
case, we set up the variables as usual.</p>
<p>At the end of <code>bar()</code>, it calls <code>baz()</code>:</p>
<table><thead><tr><td> Address              </td><td> Name </td><td> Value                  </td></tr></thead>
<tr><td> (2<sup>30</sup>) - 1 </td><td>      </td><td> 20                     </td></tr>
<tr><td> (2<sup>30</sup>) - 2 </td><td>      </td><td> 5                      </td></tr>
<tr><td> ...                  </td><td> ...  </td><td> ...                    </td></tr>
<tr><td> 12                   </td><td> g    </td><td> 100                    </td></tr>
<tr><td> 11                   </td><td> f    </td><td> → (2<sup>30</sup>) - 2 </td></tr>
<tr><td> 10                   </td><td> e    </td><td> → 9                    </td></tr>
<tr><td> 9                    </td><td> d    </td><td> → (2<sup>30</sup>) - 2 </td></tr>
<tr><td> 8                    </td><td> c    </td><td> 5                      </td></tr>
<tr><td> 7                    </td><td> b    </td><td> → 4                    </td></tr>
<tr><td> 6                    </td><td> a    </td><td> → 0                    </td></tr>
<tr><td> 5                    </td><td> z    </td><td> → 4                    </td></tr>
<tr><td> 4                    </td><td> y    </td><td> 10                     </td></tr>
<tr><td> 3                    </td><td> x    </td><td> → 0                    </td></tr>
<tr><td> 2                    </td><td> j    </td><td> → 0                    </td></tr>
<tr><td> 1                    </td><td> i    </td><td> → (2<sup>30</sup>) - 1 </td></tr>
<tr><td> 0                    </td><td> h    </td><td> 3                      </td></tr>
</table>
<p>With this, we’re at our deepest point! Whew! Congrats for following along this
far.</p>
<p>After <code>baz()</code> is over, we get rid of <code>f</code> and <code>g</code>:</p>
<table><thead><tr><td> Address              </td><td> Name </td><td> Value                  </td></tr></thead>
<tr><td> (2<sup>30</sup>) - 1 </td><td>      </td><td> 20                     </td></tr>
<tr><td> (2<sup>30</sup>) - 2 </td><td>      </td><td> 5                      </td></tr>
<tr><td> ...                  </td><td> ...  </td><td> ...                    </td></tr>
<tr><td> 10                   </td><td> e    </td><td> → 9                    </td></tr>
<tr><td> 9                    </td><td> d    </td><td> → (2<sup>30</sup>) - 2 </td></tr>
<tr><td> 8                    </td><td> c    </td><td> 5                      </td></tr>
<tr><td> 7                    </td><td> b    </td><td> → 4                    </td></tr>
<tr><td> 6                    </td><td> a    </td><td> → 0                    </td></tr>
<tr><td> 5                    </td><td> z    </td><td> → 4                    </td></tr>
<tr><td> 4                    </td><td> y    </td><td> 10                     </td></tr>
<tr><td> 3                    </td><td> x    </td><td> → 0                    </td></tr>
<tr><td> 2                    </td><td> j    </td><td> → 0                    </td></tr>
<tr><td> 1                    </td><td> i    </td><td> → (2<sup>30</sup>) - 1 </td></tr>
<tr><td> 0                    </td><td> h    </td><td> 3                      </td></tr>
</table>
<p>Next, we return from <code>bar()</code>. <code>d</code> in this case is a <code>Box&lt;T&gt;</code>, so it also frees
what it points to: (2<sup>30</sup>) - 2.</p>
<table><thead><tr><td> Address              </td><td> Name </td><td> Value                  </td></tr></thead>
<tr><td> (2<sup>30</sup>) - 1 </td><td>      </td><td> 20                     </td></tr>
<tr><td> ...                  </td><td> ...  </td><td> ...                    </td></tr>
<tr><td> 5                    </td><td> z    </td><td> → 4                    </td></tr>
<tr><td> 4                    </td><td> y    </td><td> 10                     </td></tr>
<tr><td> 3                    </td><td> x    </td><td> → 0                    </td></tr>
<tr><td> 2                    </td><td> j    </td><td> → 0                    </td></tr>
<tr><td> 1                    </td><td> i    </td><td> → (2<sup>30</sup>) - 1 </td></tr>
<tr><td> 0                    </td><td> h    </td><td> 3                      </td></tr>
</table>
<p>And after that, <code>foo()</code> returns:</p>
<table><thead><tr><td> Address              </td><td> Name </td><td> Value                  </td></tr></thead>
<tr><td> (2<sup>30</sup>) - 1 </td><td>      </td><td> 20                     </td></tr>
<tr><td> ...                  </td><td> ...  </td><td> ...                    </td></tr>
<tr><td> 2                    </td><td> j    </td><td> → 0                    </td></tr>
<tr><td> 1                    </td><td> i    </td><td> → (2<sup>30</sup>) - 1 </td></tr>
<tr><td> 0                    </td><td> h    </td><td> 3                      </td></tr>
</table>
<p>And then, finally, <code>main()</code>, which cleans the rest up. When <code>i</code> is <code>Drop</code>ped,
it will clean up the last of the heap too.</p>
<h1>What do other languages do?</h1>
<p>Most languages with a garbage collector heap-allocate by default. This means
that every value is boxed. There are a number of reasons why this is done, but
they’re out of scope for this tutorial. There are some possible optimizations
that don’t make it true 100% of the time, too. Rather than relying on the stack
and <code>Drop</code> to clean up memory, the garbage collector deals with the heap
instead.</p>
<h1>Which to use?</h1>
<p>So if the stack is faster and easier to manage, why do we need the heap? A big
reason is that Stack-allocation alone means you only have 'Last In First Out (LIFO)' semantics for
reclaiming storage. Heap-allocation is strictly more general, allowing storage
to be taken from and returned to the pool in arbitrary order, but at a
complexity cost.</p>
<p>Generally, you should prefer stack allocation, and so, Rust stack-allocates by
default. The LIFO model of the stack is simpler, at a fundamental level. This
has two big impacts: runtime efficiency and semantic impact.</p>
<h2>Runtime Efficiency</h2>
<p>Managing the memory for the stack is trivial: The machine
increments or decrements a single value, the so-called “stack pointer”.
Managing memory for the heap is non-trivial: heap-allocated memory is freed at
arbitrary points, and each block of heap-allocated memory can be of arbitrary
size, so the memory manager must generally work much harder to
identify memory for reuse.</p>
<p>If you’d like to dive into this topic in greater detail, <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.143.4688">this paper</a>
is a great introduction.</p>
<h2>Semantic impact</h2>
<p>Stack-allocation impacts the Rust language itself, and thus the developer’s
mental model. The LIFO semantics is what drives how the Rust language handles
automatic memory management. Even the deallocation of a uniquely-owned
heap-allocated box can be driven by the stack-based LIFO semantics, as
discussed throughout this chapter. The flexibility (i.e. expressiveness) of non
LIFO-semantics means that in general the compiler cannot automatically infer at
compile-time where memory should be freed; it has to rely on dynamic protocols,
potentially from outside the language itself, to drive deallocation (reference
counting, as used by <code>Rc&lt;T&gt;</code> and <code>Arc&lt;T&gt;</code>, is one example of this).</p>
<p>When taken to the extreme, the increased expressive power of heap allocation
comes at the cost of either significant runtime support (e.g. in the form of a
garbage collector) or significant programmer effort (in the form of explicit
memory management calls that require verification not provided by the Rust
compiler).</p>
<blockquote>
<p><em>commit 049b9e4</em></p>
</blockquote>
<p>% Testing</p>
<blockquote>
<p>Program testing can be a very effective way to show the presence of bugs, but
it is hopelessly inadequate for showing their absence.</p>
<p>Edsger W. Dijkstra, &quot;The Humble Programmer&quot; (1972)</p>
</blockquote>
<p>Let's talk about how to test Rust code. What we will not be talking about is
the right way to test Rust code. There are many schools of thought regarding
the right and wrong way to write tests. All of these approaches use the same
basic tools, and so we'll show you the syntax for using them.</p>
<h1>The <code>test</code> attribute</h1>
<p>At its simplest, a test in Rust is a function that's annotated with the <code>test</code>
attribute. Let's make a new project with Cargo called <code>adder</code>:</p>
<pre><code class="language-bash">$ cargo new adder
$ cd adder
</code></pre>
<p>Cargo will automatically generate a simple test when you make a new project.
Here's the contents of <code>src/lib.rs</code>:</p>
<pre><code class="language-rust"># fn main() {}
#[test]
fn it_works() {
}
</code></pre>
<p>Note the <code>#[test]</code>. This attribute indicates that this is a test function. It
currently has no body. That's good enough to pass! We can run the tests with
<code>cargo test</code>:</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Cargo compiled and ran our tests. There are two sets of output here: one
for the test we wrote, and another for documentation tests. We'll talk about
those later. For now, see this line:</p>
<pre><code class="language-text">test it_works ... ok
</code></pre>
<p>Note the <code>it_works</code>. This comes from the name of our function:</p>
<pre><code class="language-rust">fn it_works() {
# }
</code></pre>
<p>We also get a summary line:</p>
<pre><code class="language-text">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>So why does our do-nothing test pass? Any test which doesn't <code>panic!</code> passes,
and any test that does <code>panic!</code> fails. Let's make our test fail:</p>
<pre><code class="language-rust"># fn main() {}
#[test]
fn it_works() {
    assert!(false);
}
</code></pre>
<p><code>assert!</code> is a macro provided by Rust which takes one argument: if the argument
is <code>true</code>, nothing happens. If the argument is <code>false</code>, it <code>panic!</code>s. Let's run
our tests again:</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test it_works ... FAILED

failures:

---- it_works stdout ----
        thread 'it_works' panicked at 'assertion failed: false', /home/steve/tmp/adder/src/lib.rs:3



failures:
    it_works

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured

thread '&lt;main&gt;' panicked at 'Some tests failed', /home/steve/src/rust/src/libtest/lib.rs:247
</code></pre>
<p>Rust indicates that our test failed:</p>
<pre><code class="language-text">test it_works ... FAILED
</code></pre>
<p>And that's reflected in the summary line:</p>
<pre><code class="language-text">test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured
</code></pre>
<p>We also get a non-zero status code. We can use <code>$?</code> on OS X and Linux:</p>
<pre><code class="language-bash">$ echo $?
101
</code></pre>
<p>On Windows, if you’re using <code>cmd</code>:</p>
<pre><code class="language-bash">&gt; echo %ERRORLEVEL%
</code></pre>
<p>And if you’re using PowerShell:</p>
<pre><code class="language-bash">&gt; echo $LASTEXITCODE # the code itself
&gt; echo $? # a boolean, fail or succeed
</code></pre>
<p>This is useful if you want to integrate <code>cargo test</code> into other tooling.</p>
<p>We can invert our test's failure with another attribute: <code>should_panic</code>:</p>
<pre><code class="language-rust"># fn main() {}
#[test]
#[should_panic]
fn it_works() {
    assert!(false);
}
</code></pre>
<p>This test will now succeed if we <code>panic!</code> and fail if we complete. Let's try it:</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Rust provides another macro, <code>assert_eq!</code>, that compares two arguments for
equality:</p>
<pre><code class="language-rust"># fn main() {}
#[test]
#[should_panic]
fn it_works() {
    assert_eq!(&quot;Hello&quot;, &quot;world&quot;);
}
</code></pre>
<p>Does this test pass or fail? Because of the <code>should_panic</code> attribute, it
passes:</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p><code>should_panic</code> tests can be fragile, as it's hard to guarantee that the test
didn't fail for an unexpected reason. To help with this, an optional <code>expected</code>
parameter can be added to the <code>should_panic</code> attribute. The test harness will
make sure that the failure message contains the provided text. A safer version
of the example above would be:</p>
<pre><code class="language-rust"># fn main() {}
#[test]
#[should_panic(expected = &quot;assertion failed&quot;)]
fn it_works() {
    assert_eq!(&quot;Hello&quot;, &quot;world&quot;);
}
</code></pre>
<p>That's all there is to the basics! Let's write one 'real' test:</p>
<pre><code class="language-rust,ignore"># fn main() {}
pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[test]
fn it_works() {
    assert_eq!(4, add_two(2));
}
</code></pre>
<p>This is a very common use of <code>assert_eq!</code>: call some function with
some known arguments and compare it to the expected output.</p>
<h1>The <code>ignore</code> attribute</h1>
<p>Sometimes a few specific tests can be very time-consuming to execute. These
can be disabled by default by using the <code>ignore</code> attribute:</p>
<pre><code class="language-rust"># fn main() {}
#[test]
fn it_works() {
    assert_eq!(4, add_two(2));
}

#[test]
#[ignore]
fn expensive_test() {
    // code that takes an hour to run
}
</code></pre>
<p>Now we run our tests and see that <code>it_works</code> is run, but <code>expensive_test</code> is
not:</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 2 tests
test expensive_test ... ignored
test it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>The expensive tests can be run explicitly using <code>cargo test -- --ignored</code>:</p>
<pre><code class="language-bash">$ cargo test -- --ignored
     Running target/adder-91b3e234d4ed382a

running 1 test
test expensive_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>The <code>--ignored</code> argument is an argument to the test binary, and not to Cargo,
which is why the command is <code>cargo test -- --ignored</code>.</p>
<h1>The <code>tests</code> module</h1>
<p>There is one way in which our existing example is not idiomatic: it's
missing the <code>tests</code> module. The idiomatic way of writing our example
looks like this:</p>
<pre><code class="language-rust,ignore"># fn main() {}
pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::add_two;

    #[test]
    fn it_works() {
        assert_eq!(4, add_two(2));
    }
}
</code></pre>
<p>There's a few changes here. The first is the introduction of a <code>mod tests</code> with
a <code>cfg</code> attribute. The module allows us to group all of our tests together, and
to also define helper functions if needed, that don't become a part of the rest
of our crate. The <code>cfg</code> attribute only compiles our test code if we're
currently trying to run the tests. This can save compile time, and also ensures
that our tests are entirely left out of a normal build.</p>
<p>The second change is the <code>use</code> declaration. Because we're in an inner module,
we need to bring our test function into scope. This can be annoying if you have
a large module, and so this is a common use of globs. Let's change our
<code>src/lib.rs</code> to make use of it:</p>
<pre><code class="language-rust,ignore"># fn main() {}
pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(4, add_two(2));
    }
}
</code></pre>
<p>Note the different <code>use</code> line. Now we run our tests:</p>
<pre><code class="language-bash">$ cargo test
    Updating registry `https://github.com/rust-lang/crates.io-index`
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>It works!</p>
<p>The current convention is to use the <code>tests</code> module to hold your &quot;unit-style&quot;
tests. Anything that tests one small bit of functionality makes sense to
go here. But what about &quot;integration-style&quot; tests instead? For that, we have
the <code>tests</code> directory.</p>
<h1>The <code>tests</code> directory</h1>
<p>To write an integration test, let's make a <code>tests</code> directory, and
put a <code>tests/lib.rs</code> file inside, with this as its contents:</p>
<pre><code class="language-rust,ignore">extern crate adder;

# fn main() {}
#[test]
fn it_works() {
    assert_eq!(4, adder::add_two(2));
}
</code></pre>
<p>This looks similar to our previous tests, but slightly different. We now have
an <code>extern crate adder</code> at the top. This is because the tests in the <code>tests</code>
directory are an entirely separate crate, and so we need to import our library.
This is also why <code>tests</code> is a suitable place to write integration-style tests:
they use the library like any other consumer of it would.</p>
<p>Let's run them:</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

     Running target/lib-c18e7d3494509e74

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Now we have three sections: our previous test is also run, as well as our new
one.</p>
<p>That's all there is to the <code>tests</code> directory. The <code>tests</code> module isn't needed
here, since the whole thing is focused on tests.</p>
<p>Let's finally check out that third section: documentation tests.</p>
<h1>Documentation tests</h1>
<p>Nothing is better than documentation with examples. Nothing is worse than
examples that don't actually work, because the code has changed since the
documentation has been written. To this end, Rust supports automatically
running examples in your documentation (<strong>note:</strong> this only works in library
crates, not binary crates). Here's a fleshed-out <code>src/lib.rs</code> with examples:</p>
<pre><code class="language-rust,ignore"># fn main() {}
//! The `adder` crate provides functions that add numbers to other numbers.
//!
//! # Examples
//!
//! ```
//! assert_eq!(4, adder::add_two(2));
//! ```

/// This function adds two to its argument.
///
/// # Examples
///
/// ```
/// use adder::add_two;
///
/// assert_eq!(4, add_two(2));
/// ```
pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(4, add_two(2));
    }
}
</code></pre>
<p>Note the module-level documentation with <code>//!</code> and the function-level
documentation with <code>///</code>. Rust's documentation supports Markdown in comments,
and so triple graves mark code blocks. It is conventional to include the
<code># Examples</code> section, exactly like that, with examples following.</p>
<p>Let's run the tests again:</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/steve/tmp/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

     Running target/lib-c18e7d3494509e74

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 2 tests
test add_two_0 ... ok
test _0 ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Now we have all three kinds of tests running! Note the names of the
documentation tests: the <code>_0</code> is generated for the module test, and <code>add_two_0</code>
for the function test. These will auto increment with names like <code>add_two_1</code> as
you add more examples.</p>
<p>We haven’t covered all of the details with writing documentation tests. For more,
please see the <a href="documentation.html">Documentation chapter</a>.</p>
<p>One final note: documentation tests <em>cannot</em> be run on binary crates.
To see more on file arrangement see the <a href="crates-and-modules.html">Crates and
Modules</a> section.</p>
<blockquote>
<p><em>commit 919ea47</em></p>
</blockquote>
<p>% Conditional Compilation</p>
<p>Rust has a special attribute, <code>#[cfg]</code>, which allows you to compile code
based on a flag passed to the compiler. It has two forms:</p>
<pre><code class="language-rust">#[cfg(foo)]
# fn foo() {}

#[cfg(bar = &quot;baz&quot;)]
# fn bar() {}
</code></pre>
<p>They also have some helpers:</p>
<pre><code class="language-rust">#[cfg(any(unix, windows))]
# fn foo() {}

#[cfg(all(unix, target_pointer_width = &quot;32&quot;))]
# fn bar() {}

#[cfg(not(foo))]
# fn not_foo() {}
</code></pre>
<p>These can nest arbitrarily:</p>
<pre><code class="language-rust">#[cfg(any(not(unix), all(target_os=&quot;macos&quot;, target_arch = &quot;powerpc&quot;)))]
# fn foo() {}
</code></pre>
<p>As for how to enable or disable these switches, if you’re using Cargo,
they get set in the <a href="http://doc.crates.io/manifest.html#the-features-section"><code>[features]</code> section</a> of your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[features]
# no features by default
default = []

# The “secure-password” feature depends on the bcrypt package.
secure-password = [&quot;bcrypt&quot;]
</code></pre>
<p>When you do this, Cargo passes along a flag to <code>rustc</code>:</p>
<pre><code class="language-text">--cfg feature=&quot;${feature_name}&quot;
</code></pre>
<p>The sum of these <code>cfg</code> flags will determine which ones get activated, and
therefore, which code gets compiled. Let’s take this code:</p>
<pre><code class="language-rust">#[cfg(feature = &quot;foo&quot;)]
mod foo {
}
</code></pre>
<p>If we compile it with <code>cargo build --features &quot;foo&quot;</code>, it will send the <code>--cfg feature=&quot;foo&quot;</code> flag to <code>rustc</code>, and the output will have the <code>mod foo</code> in it.
If we compile it with a regular <code>cargo build</code>, no extra flags get passed on,
and so, no <code>foo</code> module will exist.</p>
<h1>cfg_attr</h1>
<p>You can also set another attribute based on a <code>cfg</code> variable with <code>cfg_attr</code>:</p>
<pre><code class="language-rust">#[cfg_attr(a, b)]
# fn foo() {}
</code></pre>
<p>Will be the same as <code>#[b]</code> if <code>a</code> is set by <code>cfg</code> attribute, and nothing otherwise.</p>
<h1>cfg!</h1>
<p>The <code>cfg!</code> <a href="compiler-plugins.html">syntax extension</a> lets you use these kinds of flags
elsewhere in your code, too:</p>
<pre><code class="language-rust">if cfg!(target_os = &quot;macos&quot;) || cfg!(target_os = &quot;ios&quot;) {
    println!(&quot;Think Different!&quot;);
}
</code></pre>
<p>These will be replaced by a <code>true</code> or <code>false</code> at compile-time, depending on the
configuration settings.</p>
<blockquote>
<p><em>commit 024aa9a</em></p>
</blockquote>
<p>% Documentation</p>
<p>Documentation is an important part of any software project, and it's
first-class in Rust. Let's talk about the tooling Rust gives you to
document your project.</p>
<h2>About <code>rustdoc</code></h2>
<p>The Rust distribution includes a tool, <code>rustdoc</code>, that generates documentation.
<code>rustdoc</code> is also used by Cargo through <code>cargo doc</code>.</p>
<p>Documentation can be generated in two ways: from source code, and from
standalone Markdown files.</p>
<h2>Documenting source code</h2>
<p>The primary way of documenting a Rust project is through annotating the source
code. You can use documentation comments for this purpose:</p>
<pre><code class="language-rust,ignore">/// Constructs a new `Rc&lt;T&gt;`.
///
/// # Examples
///
/// ```
/// use std::rc::Rc;
///
/// let five = Rc::new(5);
/// ```
pub fn new(value: T) -&gt; Rc&lt;T&gt; {
    // implementation goes here
}
</code></pre>
<p>This code generates documentation that looks <a href="https://doc.rust-lang.org/nightly/std/rc/struct.Rc.html#method.new">like this</a>. I've left the
implementation out, with a regular comment in its place.</p>
<p>The first thing to notice about this annotation is that it uses
<code>///</code> instead of <code>//</code>. The triple slash
indicates a documentation comment.</p>
<p>Documentation comments are written in Markdown.</p>
<p>Rust keeps track of these comments, and uses them when generating
documentation. This is important when documenting things like enums:</p>
<pre><code class="language-rust">/// The `Option` type. See [the module level documentation](index.html) for more.
enum Option&lt;T&gt; {
    /// No value
    None,
    /// Some value `T`
    Some(T),
}
</code></pre>
<p>The above works, but this does not:</p>
<pre><code class="language-rust,ignore">/// The `Option` type. See [the module level documentation](index.html) for more.
enum Option&lt;T&gt; {
    None, /// No value
    Some(T), /// Some value `T`
}
</code></pre>
<p>You'll get an error:</p>
<pre><code class="language-text">hello.rs:4:1: 4:2 error: expected ident, found `}`
hello.rs:4 }
           ^
</code></pre>
<p>This <a href="https://github.com/rust-lang/rust/issues/22547">unfortunate error</a> is
correct; documentation comments apply to the thing after them, and there's
nothing after that last comment.</p>
<h3>Writing documentation comments</h3>
<p>Anyway, let's cover each part of this comment in detail:</p>
<pre><code class="language-rust">/// Constructs a new `Rc&lt;T&gt;`.
# fn foo() {}
</code></pre>
<p>The first line of a documentation comment should be a short summary of its
functionality. One sentence. Just the basics. High level.</p>
<pre><code class="language-rust">///
/// Other details about constructing `Rc&lt;T&gt;`s, maybe describing complicated
/// semantics, maybe additional options, all kinds of stuff.
///
# fn foo() {}
</code></pre>
<p>Our original example had just a summary line, but if we had more things to say,
we could have added more explanation in a new paragraph.</p>
<h4>Special sections</h4>
<p>Next, are special sections. These are indicated with a header, <code>#</code>. There
are four kinds of headers that are commonly used. They aren't special syntax,
just convention, for now.</p>
<pre><code class="language-rust">/// # Panics
# fn foo() {}
</code></pre>
<p>Unrecoverable misuses of a function (i.e. programming errors) in Rust are
usually indicated by panics, which kill the whole current thread at the very
least. If your function has a non-trivial contract like this, that is
detected/enforced by panics, documenting it is very important.</p>
<pre><code class="language-rust">/// # Errors
# fn foo() {}
</code></pre>
<p>If your function or method returns a <code>Result&lt;T, E&gt;</code>, then describing the
conditions under which it returns <code>Err(E)</code> is a nice thing to do. This is
slightly less important than <code>Panics</code>, because failure is encoded into the type
system, but it's still a good thing to do.</p>
<pre><code class="language-rust">/// # Safety
# fn foo() {}
</code></pre>
<p>If your function is <code>unsafe</code>, you should explain which invariants the caller is
responsible for upholding.</p>
<pre><code class="language-rust">/// # Examples
///
/// ```
/// use std::rc::Rc;
///
/// let five = Rc::new(5);
/// ```
# fn foo() {}
</code></pre>
<p>Fourth, <code>Examples</code>. Include one or more examples of using your function or
method, and your users will love you for it. These examples go inside of
code block annotations, which we'll talk about in a moment, and can have
more than one section:</p>
<pre><code class="language-rust">/// # Examples
///
/// Simple `&amp;str` patterns:
///
/// ```
/// let v: Vec&lt;&amp;str&gt; = &quot;Mary had a little lamb&quot;.split(' ').collect();
/// assert_eq!(v, vec![&quot;Mary&quot;, &quot;had&quot;, &quot;a&quot;, &quot;little&quot;, &quot;lamb&quot;]);
/// ```
///
/// More complex patterns with a lambda:
///
/// ```
/// let v: Vec&lt;&amp;str&gt; = &quot;abc1def2ghi&quot;.split(|c: char| c.is_numeric()).collect();
/// assert_eq!(v, vec![&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;]);
/// ```
# fn foo() {}
</code></pre>
<p>Let's discuss the details of these code blocks.</p>
<h4>Code block annotations</h4>
<p>To write some Rust code in a comment, use the triple graves:</p>
<pre><code class="language-rust">/// ```
/// println!(&quot;Hello, world&quot;);
/// ```
# fn foo() {}
</code></pre>
<p>If you want something that's not Rust code, you can add an annotation:</p>
<pre><code class="language-rust">/// ```c
/// printf(&quot;Hello, world\n&quot;);
/// ```
# fn foo() {}
</code></pre>
<p>This will highlight according to whatever language you're showing off.
If you're only showing plain text, choose <code>text</code>.</p>
<p>It's important to choose the correct annotation here, because <code>rustdoc</code> uses it
in an interesting way: It can be used to actually test your examples in a
library crate, so that they don't get out of date. If you have some C code but
<code>rustdoc</code> thinks it's Rust because you left off the annotation, <code>rustdoc</code> will
complain when trying to generate the documentation.</p>
<h2>Documentation as tests</h2>
<p>Let's discuss our sample example documentation:</p>
<pre><code class="language-rust">/// ```
/// println!(&quot;Hello, world&quot;);
/// ```
# fn foo() {}
</code></pre>
<p>You'll notice that you don't need a <code>fn main()</code> or anything here. <code>rustdoc</code> will
automatically add a <code>main()</code> wrapper around your code, using heuristics to attempt
to put it in the right place. For example:</p>
<pre><code class="language-rust">/// ```
/// use std::rc::Rc;
///
/// let five = Rc::new(5);
/// ```
# fn foo() {}
</code></pre>
<p>This will end up testing:</p>
<pre><code class="language-rust">fn main() {
    use std::rc::Rc;
    let five = Rc::new(5);
}
</code></pre>
<p>Here's the full algorithm rustdoc uses to preprocess examples:</p>
<ol>
<li>Any leading <code>#![foo]</code> attributes are left intact as crate attributes.</li>
<li>Some common <code>allow</code> attributes are inserted, including
<code>unused_variables</code>, <code>unused_assignments</code>, <code>unused_mut</code>,
<code>unused_attributes</code>, and <code>dead_code</code>. Small examples often trigger
these lints.</li>
<li>If the example does not contain <code>extern crate</code>, then <code>extern crate &lt;mycrate&gt;;</code> is inserted (note the lack of <code>#[macro_use]</code>).</li>
<li>Finally, if the example does not contain <code>fn main</code>, the remainder of the
text is wrapped in <code>fn main() { your_code }</code>.</li>
</ol>
<p>This generated <code>fn main</code> can be a problem! If you have <code>extern crate</code> or a <code>mod</code>
statements in the example code that are referred to by <code>use</code> statements, they will
fail to resolve unless you include at least <code>fn main() {}</code> to inhibit step 4.
<code>#[macro_use] extern crate</code> also does not work except at the crate root, so when
testing macros an explicit <code>main</code> is always required. It doesn't have to clutter
up your docs, though -- keep reading!</p>
<p>Sometimes this algorithm isn't enough, though. For example, all of these code samples
with <code>///</code> we've been talking about? The raw text:</p>
<pre><code class="language-text">/// Some documentation.
# fn foo() {}
</code></pre>
<p>looks different than the output:</p>
<pre><code class="language-rust">/// Some documentation.
# fn foo() {}
</code></pre>
<p>Yes, that's right: you can add lines that start with <code>#</code>, and they will
be hidden from the output, but will be used when compiling your code. You
can use this to your advantage. In this case, documentation comments need
to apply to some kind of function, so if I want to show you just a
documentation comment, I need to add a little function definition below
it. At the same time, it's only there to satisfy the compiler, so hiding
it makes the example more clear. You can use this technique to explain
longer examples in detail, while still preserving the testability of your
documentation.</p>
<p>For example, imagine that we wanted to document this code:</p>
<pre><code class="language-rust">let x = 5;
let y = 6;
println!(&quot;{}&quot;, x + y);
</code></pre>
<p>We might want the documentation to end up looking like this:</p>
<blockquote>
<p>First, we set <code>x</code> to five:</p>
<pre><code class="language-rust">let x = 5;
# let y = 6;
# println!(&quot;{}&quot;, x + y);
</code></pre>
<p>Next, we set <code>y</code> to six:</p>
<pre><code class="language-rust"># let x = 5;
let y = 6;
# println!(&quot;{}&quot;, x + y);
</code></pre>
<p>Finally, we print the sum of <code>x</code> and <code>y</code>:</p>
<pre><code class="language-rust"># let x = 5;
# let y = 6;
println!(&quot;{}&quot;, x + y);
</code></pre>
</blockquote>
<p>To keep each code block testable, we want the whole program in each block, but
we don't want the reader to see every line every time.  Here's what we put in
our source code:</p>
<pre><code class="language-text">    First, we set `x` to five:

    ```rust
    let x = 5;
    # let y = 6;
    # println!(&quot;{}&quot;, x + y);
    ```

    Next, we set `y` to six:

    ```rust
    # let x = 5;
    let y = 6;
    # println!(&quot;{}&quot;, x + y);
    ```

    Finally, we print the sum of `x` and `y`:

    ```rust
    # let x = 5;
    # let y = 6;
    println!(&quot;{}&quot;, x + y);
    ```
</code></pre>
<p>By repeating all parts of the example, you can ensure that your example still
compiles, while only showing the parts that are relevant to that part of your
explanation.</p>
<h3>Documenting macros</h3>
<p>Here’s an example of documenting a macro:</p>
<pre><code class="language-rust">/// Panic with a given message unless an expression evaluates to true.
///
/// # Examples
///
/// ```
/// # #[macro_use] extern crate foo;
/// # fn main() {
/// panic_unless!(1 + 1 == 2, “Math is broken.”);
/// # }
/// ```
///
/// ```should_panic
/// # #[macro_use] extern crate foo;
/// # fn main() {
/// panic_unless!(true == false, “I’m broken.”);
/// # }
/// ```
#[macro_export]
macro_rules! panic_unless {
    ($condition:expr, $($rest:expr),+) =&gt; ({ if ! $condition { panic!($($rest),+); } });
}
# fn main() {}
</code></pre>
<p>You’ll note three things: we need to add our own <code>extern crate</code> line, so that
we can add the <code>#[macro_use]</code> attribute. Second, we’ll need to add our own
<code>main()</code> as well (for reasons discussed above). Finally, a judicious use of
<code>#</code> to comment out those two things, so they don’t show up in the output.</p>
<p>Another case where the use of <code>#</code> is handy is when you want to ignore
error handling. Lets say you want the following,</p>
<pre><code class="language-rust,ignore">/// use std::io;
/// let mut input = String::new();
/// try!(io::stdin().read_line(&amp;mut input));
</code></pre>
<p>The problem is that <code>try!</code> returns a <code>Result&lt;T, E&gt;</code> and test functions
don't return anything so this will give a mismatched types error.</p>
<pre><code class="language-rust,ignore">/// A doc test using try!
///
/// ```
/// use std::io;
/// # fn foo() -&gt; io::Result&lt;()&gt; {
/// let mut input = String::new();
/// try!(io::stdin().read_line(&amp;mut input));
/// # Ok(())
/// # }
/// ```
# fn foo() {}
</code></pre>
<p>You can get around this by wrapping the code in a function. This catches
and swallows the <code>Result&lt;T, E&gt;</code> when running tests on the docs. This
pattern appears regularly in the standard library.</p>
<h3>Running documentation tests</h3>
<p>To run the tests, either:</p>
<pre><code class="language-bash">$ rustdoc --test path/to/my/crate/root.rs
# or
$ cargo test
</code></pre>
<p>That's right, <code>cargo test</code> tests embedded documentation too. <strong>However,
<code>cargo test</code> will not test binary crates, only library ones.</strong> This is
due to the way <code>rustdoc</code> works: it links against the library to be tested,
but with a binary, there’s nothing to link to.</p>
<p>There are a few more annotations that are useful to help <code>rustdoc</code> do the right
thing when testing your code:</p>
<pre><code class="language-rust">/// ```ignore
/// fn foo() {
/// ```
# fn foo() {}
</code></pre>
<p>The <code>ignore</code> directive tells Rust to ignore your code. This is almost never
what you want, as it's the most generic. Instead, consider annotating it
with <code>text</code> if it's not code, or using <code>#</code>s to get a working example that
only shows the part you care about.</p>
<pre><code class="language-rust">/// ```should_panic
/// assert!(false);
/// ```
# fn foo() {}
</code></pre>
<p><code>should_panic</code> tells <code>rustdoc</code> that the code should compile correctly, but
not actually pass as a test.</p>
<pre><code class="language-rust">/// ```no_run
/// loop {
///     println!(&quot;Hello, world&quot;);
/// }
/// ```
# fn foo() {}
</code></pre>
<p>The <code>no_run</code> attribute will compile your code, but not run it. This is
important for examples such as &quot;Here's how to start up a network service,&quot;
which you would want to make sure compile, but might run in an infinite loop!</p>
<h3>Documenting modules</h3>
<p>Rust has another kind of doc comment, <code>//!</code>. This comment doesn't document the next item, but the enclosing item. In other words:</p>
<pre><code class="language-rust">mod foo {
    //! This is documentation for the `foo` module.
    //!
    //! # Examples

    // ...
}
</code></pre>
<p>This is where you'll see <code>//!</code> used most often: for module documentation. If
you have a module in <code>foo.rs</code>, you'll often open its code and see this:</p>
<pre><code class="language-rust">//! A module for using `foo`s.
//!
//! The `foo` module contains a lot of useful functionality blah blah blah
</code></pre>
<h3>Documentation comment style</h3>
<p>Check out <a href="https://github.com/rust-lang/rfcs/blob/master/text/0505-api-comment-conventions.md">RFC 505</a> for full conventions around the style and format of
documentation.</p>
<h2>Other documentation</h2>
<p>All of this behavior works in non-Rust source files too. Because comments
are written in Markdown, they're often <code>.md</code> files.</p>
<p>When you write documentation in Markdown files, you don't need to prefix
the documentation with comments. For example:</p>
<pre><code class="language-rust">/// # Examples
///
/// ```
/// use std::rc::Rc;
///
/// let five = Rc::new(5);
/// ```
# fn foo() {}
</code></pre>
<p>is:</p>
<pre><code class="language-markdown"># Examples

```
use std::rc::Rc;

let five = Rc::new(5);
```
</code></pre>
<p>when it's in a Markdown file. There is one wrinkle though: Markdown files need
to have a title like this:</p>
<pre><code class="language-markdown">% The title

This is the example documentation.
</code></pre>
<p>This <code>%</code> line needs to be the very first line of the file.</p>
<h2><code>doc</code> attributes</h2>
<p>At a deeper level, documentation comments are syntactic sugar for documentation
attributes:</p>
<pre><code class="language-rust">/// this
# fn foo() {}

#[doc=&quot;this&quot;]
# fn bar() {}
</code></pre>
<p>are the same, as are these:</p>
<pre><code class="language-rust">//! this

#![doc=&quot;this&quot;]
</code></pre>
<p>You won't often see this attribute used for writing documentation, but it
can be useful when changing some options, or when writing a macro.</p>
<h3>Re-exports</h3>
<p><code>rustdoc</code> will show the documentation for a public re-export in both places:</p>
<pre><code class="language-ignore">extern crate foo;

pub use foo::bar;
</code></pre>
<p>This will create documentation for <code>bar</code> both inside the documentation for the
crate <code>foo</code>, as well as the documentation for your crate. It will use the same
documentation in both places.</p>
<p>This behavior can be suppressed with <code>no_inline</code>:</p>
<pre><code class="language-ignore">extern crate foo;

#[doc(no_inline)]
pub use foo::bar;
</code></pre>
<h2>Missing documentation</h2>
<p>Sometimes you want to make sure that every single public thing in your project
is documented, especially when you are working on a library. Rust allows you to
to generate warnings or errors, when an item is missing documentation.
To generate warnings you use <code>warn</code>:</p>
<pre><code class="language-rust">#![warn(missing_docs)]
</code></pre>
<p>And to generate errors you use <code>deny</code>:</p>
<pre><code class="language-rust,ignore">#![deny(missing_docs)]
</code></pre>
<p>There are cases where you want to disable these warnings/errors to explicitly
leave something undocumented. This is done by using <code>allow</code>:</p>
<pre><code class="language-rust">#[allow(missing_docs)]
struct Undocumented;
</code></pre>
<p>You might even want to hide items from the documentation completely:</p>
<pre><code class="language-rust">#[doc(hidden)]
struct Hidden;
</code></pre>
<h3>Controlling HTML</h3>
<p>You can control a few aspects of the HTML that <code>rustdoc</code> generates through the
<code>#![doc]</code> version of the attribute:</p>
<pre><code class="language-rust">#![doc(html_logo_url = &quot;https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png&quot;,
       html_favicon_url = &quot;https://www.rust-lang.org/favicon.ico&quot;,
       html_root_url = &quot;https://doc.rust-lang.org/&quot;)]
</code></pre>
<p>This sets a few different options, with a logo, favicon, and a root URL.</p>
<h3>Configuring documentation tests</h3>
<p>You can also configure the way that <code>rustdoc</code> tests your documentation examples
through the <code>#![doc(test(..))]</code> attribute.</p>
<pre><code class="language-rust">#![doc(test(attr(allow(unused_variables), deny(warnings))))]
</code></pre>
<p>This allows unused variables within the examples, but will fail the test for any
other lint warning thrown.</p>
<h2>Generation options</h2>
<p><code>rustdoc</code> also contains a few other options on the command line, for further customization:</p>
<ul>
<li><code>--html-in-header FILE</code>: includes the contents of FILE at the end of the
<code>&lt;head&gt;...&lt;/head&gt;</code> section.</li>
<li><code>--html-before-content FILE</code>: includes the contents of FILE directly after
<code>&lt;body&gt;</code>, before the rendered content (including the search bar).</li>
<li><code>--html-after-content FILE</code>: includes the contents of FILE after all the rendered content.</li>
</ul>
<h2>Security note</h2>
<p>The Markdown in documentation comments is placed without processing into
the final webpage. Be careful with literal HTML:</p>
<pre><code class="language-rust">/// &lt;script&gt;alert(document.cookie)&lt;/script&gt;
# fn foo() {}
</code></pre>
<blockquote>
<p><em>commit cff81d7</em></p>
</blockquote>
<p>% Iterators</p>
<p>Let's talk about loops.</p>
<p>Remember Rust's <code>for</code> loop? Here's an example:</p>
<pre><code class="language-rust">for x in 0..10 {
    println!(&quot;{}&quot;, x);
}
</code></pre>
<p>Now that you know more Rust, we can talk in detail about how this works.
Ranges (the <code>0..10</code>) are 'iterators'. An iterator is something that we can
call the <code>.next()</code> method on repeatedly, and it gives us a sequence of things.</p>
<p>Like this:</p>
<pre><code class="language-rust">let mut range = 0..10;

loop {
    match range.next() {
        Some(x) =&gt; {
            println!(&quot;{}&quot;, x);
        },
        None =&gt; { break }
    }
}
</code></pre>
<p>We make a mutable binding to the range, which is our iterator. We then <code>loop</code>,
with an inner <code>match</code>. This <code>match</code> is used on the result of <code>range.next()</code>,
which gives us a reference to the next value of the iterator. <code>next</code> returns an
<code>Option&lt;i32&gt;</code>, in this case, which will be <code>Some(i32)</code> when we have a value and
<code>None</code> once we run out. If we get <code>Some(i32)</code>, we print it out, and if we get
<code>None</code>, we <code>break</code> out of the loop.</p>
<p>This code sample is basically the same as our <code>for</code> loop version. The <code>for</code>
loop is a handy way to write this <code>loop</code>/<code>match</code>/<code>break</code> construct.</p>
<p><code>for</code> loops aren't the only thing that uses iterators, however. Writing your
own iterator involves implementing the <code>Iterator</code> trait. While doing that is
outside of the scope of this guide, Rust provides a number of useful iterators
to accomplish various tasks. But first, a few notes about limitations of ranges.</p>
<p>Ranges are very primitive, and we often can use better alternatives. Consider the
following Rust anti-pattern: using ranges to emulate a C-style <code>for</code> loop. Let’s
suppose you needed to iterate over the contents of a vector. You may be tempted
to write this:</p>
<pre><code class="language-rust">let nums = vec![1, 2, 3];

for i in 0..nums.len() {
    println!(&quot;{}&quot;, nums[i]);
}
</code></pre>
<p>This is strictly worse than using an actual iterator. You can iterate over vectors
directly, so write this:</p>
<pre><code class="language-rust">let nums = vec![1, 2, 3];

for num in &amp;nums {
    println!(&quot;{}&quot;, num);
}
</code></pre>
<p>There are two reasons for this. First, this more directly expresses what we
mean. We iterate through the entire vector, rather than iterating through
indexes, and then indexing the vector. Second, this version is more efficient:
the first version will have extra bounds checking because it used indexing,
<code>nums[i]</code>. But since we yield a reference to each element of the vector in turn
with the iterator, there's no bounds checking in the second example. This is
very common with iterators: we can ignore unnecessary bounds checks, but still
know that we're safe.</p>
<p>There's another detail here that's not 100% clear because of how <code>println!</code>
works. <code>num</code> is actually of type <code>&amp;i32</code>. That is, it's a reference to an <code>i32</code>,
not an <code>i32</code> itself. <code>println!</code> handles the dereferencing for us, so we don't
see it. This code works fine too:</p>
<pre><code class="language-rust">let nums = vec![1, 2, 3];

for num in &amp;nums {
    println!(&quot;{}&quot;, *num);
}
</code></pre>
<p>Now we're explicitly dereferencing <code>num</code>. Why does <code>&amp;nums</code> give us
references?  Firstly, because we explicitly asked it to with
<code>&amp;</code>. Secondly, if it gave us the data itself, we would have to be its
owner, which would involve making a copy of the data and giving us the
copy. With references, we're only borrowing a reference to the data,
and so it's only passing a reference, without needing to do the move.</p>
<p>So, now that we've established that ranges are often not what you want, let's
talk about what you do want instead.</p>
<p>There are three broad classes of things that are relevant here: iterators,
<em>iterator adaptors</em>, and <em>consumers</em>. Here's some definitions:</p>
<ul>
<li><em>iterators</em> give you a sequence of values.</li>
<li><em>iterator adaptors</em> operate on an iterator, producing a new iterator with a
different output sequence.</li>
<li><em>consumers</em> operate on an iterator, producing some final set of values.</li>
</ul>
<p>Let's talk about consumers first, since you've already seen an iterator, ranges.</p>
<h2>Consumers</h2>
<p>A <em>consumer</em> operates on an iterator, returning some kind of value or values.
The most common consumer is <code>collect()</code>. This code doesn't quite compile,
but it shows the intention:</p>
<pre><code class="language-rust,ignore">let one_to_one_hundred = (1..101).collect();
</code></pre>
<p>As you can see, we call <code>collect()</code> on our iterator. <code>collect()</code> takes
as many values as the iterator will give it, and returns a collection
of the results. So why won't this compile? Rust can't determine what
type of things you want to collect, and so you need to let it know.
Here's the version that does compile:</p>
<pre><code class="language-rust">let one_to_one_hundred = (1..101).collect::&lt;Vec&lt;i32&gt;&gt;();
</code></pre>
<p>If you remember, the <code>::&lt;&gt;</code> syntax allows us to give a type hint,
and so we tell it that we want a vector of integers. You don't always
need to use the whole type, though. Using a <code>_</code> will let you provide
a partial hint:</p>
<pre><code class="language-rust">let one_to_one_hundred = (1..101).collect::&lt;Vec&lt;_&gt;&gt;();
</code></pre>
<p>This says &quot;Collect into a <code>Vec&lt;T&gt;</code>, please, but infer what the <code>T</code> is for me.&quot;
<code>_</code> is sometimes called a &quot;type placeholder&quot; for this reason.</p>
<p><code>collect()</code> is the most common consumer, but there are others too. <code>find()</code>
is one:</p>
<pre><code class="language-rust">let greater_than_forty_two = (0..100)
                             .find(|x| *x &gt; 42);

match greater_than_forty_two {
    Some(_) =&gt; println!(&quot;Found a match!&quot;),
    None =&gt; println!(&quot;No match found :(&quot;),
}
</code></pre>
<p><code>find</code> takes a closure, and works on a reference to each element of an
iterator. This closure returns <code>true</code> if the element is the element we're
looking for, and <code>false</code> otherwise. <code>find</code> returns the first element satisfying
the specified predicate. Because we might not find a matching element, <code>find</code>
returns an <code>Option</code> rather than the element itself.</p>
<p>Another important consumer is <code>fold</code>. Here's what it looks like:</p>
<pre><code class="language-rust">let sum = (1..4).fold(0, |sum, x| sum + x);
</code></pre>
<p><code>fold()</code> is a consumer that looks like this:
<code>fold(base, |accumulator, element| ...)</code>. It takes two arguments: the first
is an element called the <em>base</em>. The second is a closure that itself takes two
arguments: the first is called the <em>accumulator</em>, and the second is an
<em>element</em>. Upon each iteration, the closure is called, and the result is the
value of the accumulator on the next iteration. On the first iteration, the
base is the value of the accumulator.</p>
<p>Okay, that's a bit confusing. Let's examine the values of all of these things
in this iterator:</p>
<table><thead><tr><td> base </td><td> accumulator </td><td> element </td><td> closure result </td></tr></thead>
<tr><td> 0    </td><td> 0           </td><td> 1       </td><td> 1              </td></tr>
<tr><td> 0    </td><td> 1           </td><td> 2       </td><td> 3              </td></tr>
<tr><td> 0    </td><td> 3           </td><td> 3       </td><td> 6              </td></tr>
</table>
<p>We called <code>fold()</code> with these arguments:</p>
<pre><code class="language-rust"># (1..4)
.fold(0, |sum, x| sum + x);
</code></pre>
<p>So, <code>0</code> is our base, <code>sum</code> is our accumulator, and <code>x</code> is our element.  On the
first iteration, we set <code>sum</code> to <code>0</code>, and <code>x</code> is the first element of <code>nums</code>,
<code>1</code>. We then add <code>sum</code> and <code>x</code>, which gives us <code>0 + 1 = 1</code>. On the second
iteration, that value becomes our accumulator, <code>sum</code>, and the element is
the second element of the array, <code>2</code>. <code>1 + 2 = 3</code>, and so that becomes
the value of the accumulator for the last iteration. On that iteration,
<code>x</code> is the last element, <code>3</code>, and <code>3 + 3 = 6</code>, which is our final
result for our sum. <code>1 + 2 + 3 = 6</code>, and that's the result we got.</p>
<p>Whew. <code>fold</code> can be a bit strange the first few times you see it, but once it
clicks, you can use it all over the place. Any time you have a list of things,
and you want a single result, <code>fold</code> is appropriate.</p>
<p>Consumers are important due to one additional property of iterators we haven't
talked about yet: laziness. Let's talk some more about iterators, and you'll
see why consumers matter.</p>
<h2>Iterators</h2>
<p>As we've said before, an iterator is something that we can call the
<code>.next()</code> method on repeatedly, and it gives us a sequence of things.
Because you need to call the method, this means that iterators
can be <em>lazy</em> and not generate all of the values upfront. This code,
for example, does not actually generate the numbers <code>1-99</code>, instead
creating a value that merely represents the sequence:</p>
<pre><code class="language-rust">let nums = 1..100;
</code></pre>
<p>Since we didn't do anything with the range, it didn't generate the sequence.
Let's add the consumer:</p>
<pre><code class="language-rust">let nums = (1..100).collect::&lt;Vec&lt;i32&gt;&gt;();
</code></pre>
<p>Now, <code>collect()</code> will require that the range gives it some numbers, and so
it will do the work of generating the sequence.</p>
<p>Ranges are one of two basic iterators that you'll see. The other is <code>iter()</code>.
<code>iter()</code> can turn a vector into a simple iterator that gives you each element
in turn:</p>
<pre><code class="language-rust">let nums = vec![1, 2, 3];

for num in nums.iter() {
   println!(&quot;{}&quot;, num);
}
</code></pre>
<p>These two basic iterators should serve you well. There are some more
advanced iterators, including ones that are infinite.</p>
<p>That's enough about iterators. Iterator adaptors are the last concept
we need to talk about with regards to iterators. Let's get to it!</p>
<h2>Iterator adaptors</h2>
<p><em>Iterator adaptors</em> take an iterator and modify it somehow, producing
a new iterator. The simplest one is called <code>map</code>:</p>
<pre><code class="language-rust,ignore">(1..100).map(|x| x + 1);
</code></pre>
<p><code>map</code> is called upon another iterator, and produces a new iterator where each
element reference has the closure it's been given as an argument called on it.
So this would give us the numbers from <code>2-100</code>. Well, almost! If you
compile the example, you'll get a warning:</p>
<pre><code class="language-text">warning: unused result which must be used: iterator adaptors are lazy and
         do nothing unless consumed, #[warn(unused_must_use)] on by default
(1..100).map(|x| x + 1);
 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</code></pre>
<p>Laziness strikes again! That closure will never execute. This example
doesn't print any numbers:</p>
<pre><code class="language-rust,ignore">(1..100).map(|x| println!(&quot;{}&quot;, x));
</code></pre>
<p>If you are trying to execute a closure on an iterator for its side effects,
use <code>for</code> instead.</p>
<p>There are tons of interesting iterator adaptors. <code>take(n)</code> will return an
iterator over the next <code>n</code> elements of the original iterator. Let's try it out
with an infinite iterator:</p>
<pre><code class="language-rust">for i in (1..).take(5) {
    println!(&quot;{}&quot;, i);
}
</code></pre>
<p>This will print</p>
<pre><code class="language-text">1
2
3
4
5
</code></pre>
<p><code>filter()</code> is an adapter that takes a closure as an argument. This closure
returns <code>true</code> or <code>false</code>. The new iterator <code>filter()</code> produces
only the elements that the closure returns <code>true</code> for:</p>
<pre><code class="language-rust">for i in (1..100).filter(|&amp;x| x % 2 == 0) {
    println!(&quot;{}&quot;, i);
}
</code></pre>
<p>This will print all of the even numbers between one and a hundred.
(Note that, unlike <code>map</code>, the closure passed to <code>filter</code> is passed a reference
to the element instead of the element itself. The filter predicate here uses
the <code>&amp;x</code> pattern to extract the integer. The filter closure is passed a
reference because it returns <code>true</code> or <code>false</code> instead of the element,
so the <code>filter</code> implementation must retain ownership to put the elements
into the newly constructed iterator.)</p>
<p>You can chain all three things together: start with an iterator, adapt it
a few times, and then consume the result. Check it out:</p>
<pre><code class="language-rust">(1..)
    .filter(|&amp;x| x % 2 == 0)
    .filter(|&amp;x| x % 3 == 0)
    .take(5)
    .collect::&lt;Vec&lt;i32&gt;&gt;();
</code></pre>
<p>This will give you a vector containing <code>6</code>, <code>12</code>, <code>18</code>, <code>24</code>, and <code>30</code>.</p>
<p>This is just a small taste of what iterators, iterator adaptors, and consumers
can help you with. There are a number of really useful iterators, and you can
write your own as well. Iterators provide a safe, efficient way to manipulate
all kinds of lists. They're a little unusual at first, but if you play with
them, you'll get hooked. For a full list of the different iterators and
consumers, check out the <a href="../std/iter/index.html">iterator module documentation</a>.</p>
<blockquote>
<p><em>commit 7042c8e</em></p>
</blockquote>
<p>% Concurrency</p>
<p>Concurrency and parallelism are incredibly important topics in computer
science, and are also a hot topic in industry today. Computers are gaining more
and more cores, yet many programmers aren't prepared to fully utilize them.</p>
<p>Rust's memory safety features also apply to its concurrency story too. Even
concurrent Rust programs must be memory safe, having no data races. Rust's type
system is up to the task, and gives you powerful ways to reason about
concurrent code at compile time.</p>
<p>Before we talk about the concurrency features that come with Rust, it's important
to understand something: Rust is low-level enough that the vast majority of
this is provided by the standard library, not by the language. This means that
if you don't like some aspect of the way Rust handles concurrency, you can
implement an alternative way of doing things.
<a href="https://github.com/carllerche/mio">mio</a> is a real-world example of this
principle in action.</p>
<h2>Background: <code>Send</code> and <code>Sync</code></h2>
<p>Concurrency is difficult to reason about. In Rust, we have a strong, static
type system to help us reason about our code. As such, Rust gives us two traits
to help us make sense of code that can possibly be concurrent.</p>
<h3><code>Send</code></h3>
<p>The first trait we're going to talk about is
[<code>Send</code>](../std/marker/trait.Send.html). When a type <code>T</code> implements <code>Send</code>, it
indicates that something of this type is able to have ownership transferred
safely between threads.</p>
<p>This is important to enforce certain restrictions. For example, if we have a
channel connecting two threads, we would want to be able to send some data
down the channel and to the other thread. Therefore, we'd ensure that <code>Send</code> was
implemented for that type.</p>
<p>In the opposite way, if we were wrapping a library with <a href="ffi.html">FFI</a> that isn't
threadsafe, we wouldn't want to implement <code>Send</code>, and so the compiler will help
us enforce that it can't leave the current thread.</p>
<h3><code>Sync</code></h3>
<p>The second of these traits is called [<code>Sync</code>](../std/marker/trait.Sync.html).
When a type <code>T</code> implements <code>Sync</code>, it indicates that something
of this type has no possibility of introducing memory unsafety when used from
multiple threads concurrently through shared references. This implies that
types which don't have <a href="mutability.html">interior mutability</a> are inherently
<code>Sync</code>, which includes simple primitive types (like <code>u8</code>) and aggregate types
containing them.</p>
<p>For sharing references across threads, Rust provides a wrapper type called
<code>Arc&lt;T&gt;</code>. <code>Arc&lt;T&gt;</code> implements <code>Send</code> and <code>Sync</code> if and only if <code>T</code> implements
both <code>Send</code> and <code>Sync</code>. For example, an object of type <code>Arc&lt;RefCell&lt;U&gt;&gt;</code> cannot
be transferred across threads because
[<code>RefCell</code>](choosing-your-guarantees.html#refcellt) does not implement
<code>Sync</code>, consequently <code>Arc&lt;RefCell&lt;U&gt;&gt;</code> would not implement <code>Send</code>.</p>
<p>These two traits allow you to use the type system to make strong guarantees
about the properties of your code under concurrency. Before we demonstrate
why, we need to learn how to create a concurrent Rust program in the first
place!</p>
<h2>Threads</h2>
<p>Rust's standard library provides a library for threads, which allow you to
run Rust code in parallel. Here's a basic example of using <code>std::thread</code>:</p>
<pre><code class="language-rust">use std::thread;

fn main() {
    thread::spawn(|| {
        println!(&quot;Hello from a thread!&quot;);
    });
}
</code></pre>
<p>The <code>thread::spawn()</code> method accepts a <a href="closures.html">closure</a>, which is executed in a
new thread. It returns a handle to the thread, that can be used to
wait for the child thread to finish and extract its result:</p>
<pre><code class="language-rust">use std::thread;

fn main() {
    let handle = thread::spawn(|| {
        &quot;Hello from a thread!&quot;
    });

    println!(&quot;{}&quot;, handle.join().unwrap());
}
</code></pre>
<p>Many languages have the ability to execute threads, but it's wildly unsafe.
There are entire books about how to prevent errors that occur from shared
mutable state. Rust helps out with its type system here as well, by preventing
data races at compile time. Let's talk about how you actually share things
between threads.</p>
<h2>Safe Shared Mutable State</h2>
<p>Due to Rust's type system, we have a concept that sounds like a lie: &quot;safe
shared mutable state.&quot; Many programmers agree that shared mutable state is
very, very bad.</p>
<p>Someone once said this:</p>
<blockquote>
<p>Shared mutable state is the root of all evil. Most languages attempt to deal
with this problem through the 'mutable' part, but Rust deals with it by
solving the 'shared' part.</p>
</blockquote>
<p>The same <a href="ownership.html">ownership system</a> that helps prevent using pointers
incorrectly also helps rule out data races, one of the worst kinds of
concurrency bugs.</p>
<p>As an example, here is a Rust program that would have a data race in many
languages. It will not compile:</p>
<pre><code class="language-ignore">use std::thread;
use std::time::Duration;

fn main() {
    let mut data = vec![1, 2, 3];

    for i in 0..3 {
        thread::spawn(move || {
            data[i] += 1;
        });
    }

    thread::sleep(Duration::from_millis(50));
}
</code></pre>
<p>This gives us an error:</p>
<pre><code class="language-text">8:17 error: capture of moved value: `data`
        data[i] += 1;
        ^~~~
</code></pre>
<p>Rust knows this wouldn't be safe! If we had a reference to <code>data</code> in each
thread, and the thread takes ownership of the reference, we'd have three
owners!</p>
<p>So, we need some type that lets us have more than one reference to a value and
that we can share between threads, that is it must implement <code>Sync</code>.</p>
<p>We'll use <code>Arc&lt;T&gt;</code>, Rust's standard atomic reference count type, which
wraps a value up with some extra runtime bookkeeping which allows us to
share the ownership of the value between multiple references at the same time.</p>
<p>The bookkeeping consists of a count of how many of these references exist to
the value, hence the reference count part of the name.</p>
<p>The Atomic part means <code>Arc&lt;T&gt;</code> can safely be accessed from multiple threads.
To do this the compiler guarantees that mutations of the internal count use
indivisible operations which can't have data races.</p>
<pre><code class="language-ignore">use std::thread;
use std::sync::Arc;
use std::time::Duration;

fn main() {
    let mut data = Arc::new(vec![1, 2, 3]);

    for i in 0..3 {
        let data = data.clone();
        thread::spawn(move || {
            data[i] += 1;
        });
    }

    thread::sleep(Duration::from_millis(50));
}
</code></pre>
<p>We now call <code>clone()</code> on our <code>Arc&lt;T&gt;</code>, which increases the internal count.
This handle is then moved into the new thread.</p>
<p>And... still gives us an error.</p>
<pre><code class="language-text">&lt;anon&gt;:11:24 error: cannot borrow immutable borrowed content as mutable
&lt;anon&gt;:11                    data[i] += 1;
                             ^~~~
</code></pre>
<p><code>Arc&lt;T&gt;</code> assumes one more property about its contents to ensure that it is safe
to share across threads: it assumes its contents are <code>Sync</code>. This is true for
our value if it's immutable, but we want to be able to mutate it, so we need
something else to persuade the borrow checker we know what we're doing.</p>
<p>It looks like we need some type that allows us to safely mutate a shared value,
for example a type that can ensure only one thread at a time is able to
mutate the value inside it at any one time.</p>
<p>For that, we can use the <code>Mutex&lt;T&gt;</code> type!</p>
<p>Here's the working version:</p>
<pre><code class="language-rust">use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;

fn main() {
    let data = Arc::new(Mutex::new(vec![1, 2, 3]));

    for i in 0..3 {
        let data = data.clone();
        thread::spawn(move || {
            let mut data = data.lock().unwrap();
            data[i] += 1;
        });
    }

    thread::sleep(Duration::from_millis(50));
}
</code></pre>
<p>Note that the value of <code>i</code> is bound (copied) to the closure and not shared
among the threads.</p>
<p>Also note that [<code>lock</code>](../std/sync/struct.Mutex.html#method.lock) method of
[<code>Mutex</code>](../std/sync/struct.Mutex.html) has this signature:</p>
<pre><code class="language-ignore">fn lock(&amp;self) -&gt; LockResult&lt;MutexGuard&lt;T&gt;&gt;
</code></pre>
<p>and because <code>Send</code> is not implemented for <code>MutexGuard&lt;T&gt;</code>, the guard cannot
cross thread boundaries, ensuring thread-locality of lock acquire and release.</p>
<p>Let's examine the body of the thread more closely:</p>
<pre><code class="language-rust"># use std::sync::{Arc, Mutex};
# use std::thread;
# use std::time::Duration;
# fn main() {
#     let data = Arc::new(Mutex::new(vec![1, 2, 3]));
#     for i in 0..3 {
#         let data = data.clone();
thread::spawn(move || {
    let mut data = data.lock().unwrap();
    data[i] += 1;
});
#     }
#     thread::sleep(Duration::from_millis(50));
# }
</code></pre>
<p>First, we call <code>lock()</code>, which acquires the mutex's lock. Because this may fail,
it returns an <code>Result&lt;T, E&gt;</code>, and because this is just an example, we <code>unwrap()</code>
it to get a reference to the data. Real code would have more robust error handling
here. We're then free to mutate it, since we have the lock.</p>
<p>Lastly, while the threads are running, we wait on a short timer. But
this is not ideal: we may have picked a reasonable amount of time to
wait but it's more likely we'll either be waiting longer than
necessary or not long enough, depending on just how much time the
threads actually take to finish computing when the program runs.</p>
<p>A more precise alternative to the timer would be to use one of the
mechanisms provided by the Rust standard library for synchronizing
threads with each other. Let's talk about one of them: channels.</p>
<h2>Channels</h2>
<p>Here's a version of our code that uses channels for synchronization, rather
than waiting for a specific time:</p>
<pre><code class="language-rust">use std::sync::{Arc, Mutex};
use std::thread;
use std::sync::mpsc;

fn main() {
    let data = Arc::new(Mutex::new(0));

    // `tx` is the &quot;transmitter&quot; or &quot;sender&quot;
    // `rx` is the &quot;receiver&quot;
    let (tx, rx) = mpsc::channel();

    for _ in 0..10 {
        let (data, tx) = (data.clone(), tx.clone());

        thread::spawn(move || {
            let mut data = data.lock().unwrap();
            *data += 1;

            tx.send(()).unwrap();
        });
    }

    for _ in 0..10 {
        rx.recv().unwrap();
    }
}
</code></pre>
<p>We use the <code>mpsc::channel()</code> method to construct a new channel. We <code>send</code>
a simple <code>()</code> down the channel, and then wait for ten of them to come back.</p>
<p>While this channel is sending a generic signal, we can send any data that
is <code>Send</code> over the channel!</p>
<pre><code class="language-rust">use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    for i in 0..10 {
        let tx = tx.clone();

        thread::spawn(move || {
            let answer = i * i;

            tx.send(answer).unwrap();
        });
    }

    for _ in 0..10 {
        println!(&quot;{}&quot;, rx.recv().unwrap());
    }
}
</code></pre>
<p>Here we create 10 threads, asking each to calculate the square of a number (<code>i</code>
at the time of <code>spawn()</code>), and then <code>send()</code> back the answer over the channel.</p>
<h2>Panics</h2>
<p>A <code>panic!</code> will crash the currently executing thread. You can use Rust's
threads as a simple isolation mechanism:</p>
<pre><code class="language-rust">use std::thread;

let handle = thread::spawn(move || {
    panic!(&quot;oops!&quot;);
});

let result = handle.join();

assert!(result.is_err());
</code></pre>
<p><code>Thread.join()</code> gives us a <code>Result</code> back, which allows us to check if the thread
has panicked or not.</p>
<blockquote>
<p><em>commit 7f59e06</em></p>
</blockquote>
<p>% Error Handling</p>
<p>Like most programming languages, Rust encourages the programmer to handle
errors in a particular way. Generally speaking, error handling is divided into
two broad categories: exceptions and return values. Rust opts for return
values.</p>
<p>In this section, we intend to provide a comprehensive treatment of how to deal
with errors in Rust. More than that, we will attempt to introduce error handling
one piece at a time so that you'll come away with a solid working knowledge of
how everything fits together.</p>
<p>When done naïvely, error handling in Rust can be verbose and annoying. This
section will explore those stumbling blocks and demonstrate how to use the
standard library to make error handling concise and ergonomic.</p>
<h1>Table of Contents</h1>
<p>This section is very long, mostly because we start at the very beginning with
sum types and combinators, and try to motivate the way Rust does error handling
incrementally. As such, programmers with experience in other expressive type
systems may want to jump around.</p>
<ul>
<li><a href="#the-basics">The Basics</a>
<ul>
<li><a href="#unwrapping-explained">Unwrapping explained</a></li>
<li><a href="#the-option-type">The <code>Option</code> type</a>
<ul>
<li><a href="#composing-optiont-values">Composing <code>Option&lt;T&gt;</code> values</a></li>
</ul>
</li>
<li><a href="#the-result-type">The <code>Result</code> type</a>
<ul>
<li><a href="#parsing-integers">Parsing integers</a></li>
<li><a href="#the-result-type-alias-idiom">The <code>Result</code> type alias idiom</a></li>
</ul>
</li>
<li><a href="#a-brief-interlude-unwrapping-isnt-evil">A brief interlude: unwrapping isn't evil</a></li>
</ul>
</li>
<li><a href="#working-with-multiple-error-types">Working with multiple error types</a>
<ul>
<li>[Composing <code>Option</code> and <code>Result</code>](#composing-option-and-result)</li>
<li><a href="#the-limits-of-combinators">The limits of combinators</a></li>
<li><a href="#early-returns">Early returns</a></li>
<li><a href="#the-try-macro">The <code>try!</code> macro</a></li>
<li><a href="#defining-your-own-error-type">Defining your own error type</a></li>
</ul>
</li>
<li><a href="#standard-library-traits-used-for-error-handling">Standard library traits used for error handling</a>
<ul>
<li><a href="#the-error-trait">The <code>Error</code> trait</a></li>
<li><a href="#the-from-trait">The <code>From</code> trait</a></li>
<li><a href="#the-real-try-macro">The real <code>try!</code> macro</a></li>
<li><a href="#composing-custom-error-types">Composing custom error types</a></li>
<li><a href="#advice-for-library-writers">Advice for library writers</a></li>
</ul>
</li>
<li><a href="#case-study-a-program-to-read-population-data">Case study: A program to read population data</a>
<ul>
<li><a href="#initial-setup">Initial setup</a></li>
<li><a href="#argument-parsing">Argument parsing</a></li>
<li><a href="#writing-the-logic">Writing the logic</a></li>
<li>[Error handling with <code>Box&lt;Error&gt;</code>](#error-handling-with-boxerror)</li>
<li><a href="#reading-from-stdin">Reading from stdin</a></li>
<li><a href="#error-handling-with-a-custom-type">Error handling with a custom type</a></li>
<li><a href="#adding-functionality">Adding functionality</a></li>
</ul>
</li>
<li><a href="#the-short-story">The short story</a></li>
</ul>
<h1>The Basics</h1>
<p>You can think of error handling as using <em>case analysis</em> to determine whether
a computation was successful or not. As you will see, the key to ergonomic error
handling is reducing the amount of explicit case analysis the programmer has to
do while keeping code composable.</p>
<p>Keeping code composable is important, because without that requirement, we
could [<code>panic</code>](../std/macro.panic!.html) whenever we
come across something unexpected. (<code>panic</code> causes the current task to unwind,
and in most cases, the entire program aborts.) Here's an example:</p>
<pre><code class="language-rust,should_panic">// Guess a number between 1 and 10.
// If it matches the number we had in mind, return true. Else, return false.
fn guess(n: i32) -&gt; bool {
    if n &lt; 1 || n &gt; 10 {
        panic!(&quot;Invalid number: {}&quot;, n);
    }
    n == 5
}

fn main() {
    guess(11);
}
</code></pre>
<p>If you try running this code, the program will crash with a message like this:</p>
<pre><code class="language-text">thread '&lt;main&gt;' panicked at 'Invalid number: 11', src/bin/panic-simple.rs:5
</code></pre>
<p>Here's another example that is slightly less contrived. A program that accepts
an integer as an argument, doubles it and prints it.</p>
<p><span id="code-unwrap-double"></span></p>
<pre><code class="language-rust,should_panic">use std::env;

fn main() {
    let mut argv = env::args();
    let arg: String = argv.nth(1).unwrap(); // error 1
    let n: i32 = arg.parse().unwrap(); // error 2
    println!(&quot;{}&quot;, 2 * n);
}
</code></pre>
<p>If you give this program zero arguments (error 1) or if the first argument
isn't an integer (error 2), the program will panic just like in the first
example.</p>
<p>You can think of this style of error handling as similar to a bull running
through a china shop. The bull will get to where it wants to go, but it will
trample everything in the process.</p>
<h2>Unwrapping explained</h2>
<p>In the previous example, we claimed
that the program would simply panic if it reached one of the two error
conditions, yet, the program does not include an explicit call to <code>panic</code> like
the first example. This is because the
panic is embedded in the calls to <code>unwrap</code>.</p>
<p>To “unwrap” something in Rust is to say, “Give me the result of the
computation, and if there was an error, panic and stop the program.”
It would be better if we showed the code for unwrapping because it is so
simple, but to do that, we will first need to explore the <code>Option</code> and <code>Result</code>
types. Both of these types have a method called <code>unwrap</code> defined on them.</p>
<h3>The <code>Option</code> type</h3>
<p>The <code>Option</code> type is <a href="../std/option/enum.Option.html">defined in the standard library</a>:</p>
<pre><code class="language-rust">enum Option&lt;T&gt; {
    None,
    Some(T),
}
</code></pre>
<p>The <code>Option</code> type is a way to use Rust's type system to express the
<em>possibility of absence</em>. Encoding the possibility of absence into the type
system is an important concept because it will cause the compiler to force the
programmer to handle that absence. Let's take a look at an example that tries
to find a character in a string:</p>
<p><span id="code-option-ex-string-find"></span></p>
<pre><code class="language-rust">// Searches `haystack` for the Unicode character `needle`. If one is found, the
// byte offset of the character is returned. Otherwise, `None` is returned.
fn find(haystack: &amp;str, needle: char) -&gt; Option&lt;usize&gt; {
    for (offset, c) in haystack.char_indices() {
        if c == needle {
            return Some(offset);
        }
    }
    None
}
</code></pre>
<p>Notice that when this function finds a matching character, it doesn't only
return the <code>offset</code>. Instead, it returns <code>Some(offset)</code>. <code>Some</code> is a variant or
a <em>value constructor</em> for the <code>Option</code> type. You can think of it as a function
with the type <code>fn&lt;T&gt;(value: T) -&gt; Option&lt;T&gt;</code>. Correspondingly, <code>None</code> is also a
value constructor, except it has no arguments. You can think of <code>None</code> as a
function with the type <code>fn&lt;T&gt;() -&gt; Option&lt;T&gt;</code>.</p>
<p>This might seem like much ado about nothing, but this is only half of the
story. The other half is <em>using</em> the <code>find</code> function we've written. Let's try
to use it to find the extension in a file name.</p>
<pre><code class="language-rust"># fn find(_: &amp;str, _: char) -&gt; Option&lt;usize&gt; { None }
fn main() {
    let file_name = &quot;foobar.rs&quot;;
    match find(file_name, '.') {
        None =&gt; println!(&quot;No file extension found.&quot;),
        Some(i) =&gt; println!(&quot;File extension: {}&quot;, &amp;file_name[i+1..]),
    }
}
</code></pre>
<p>This code uses <a href="../book/patterns.html">pattern matching</a> to do <em>case
analysis</em> on the <code>Option&lt;usize&gt;</code> returned by the <code>find</code> function. In fact, case
analysis is the only way to get at the value stored inside an <code>Option&lt;T&gt;</code>. This
means that you, as the programmer, must handle the case when an <code>Option&lt;T&gt;</code> is
<code>None</code> instead of <code>Some(t)</code>.</p>
<p>But wait, what about <code>unwrap</code>, which we used <a href="#code-unwrap-double">previously</a>?
There was no case analysis there! Instead, the case analysis was put inside the
<code>unwrap</code> method for you. You could define it yourself if you want:</p>
<p><span id="code-option-def-unwrap"></span></p>
<pre><code class="language-rust">enum Option&lt;T&gt; {
    None,
    Some(T),
}

impl&lt;T&gt; Option&lt;T&gt; {
    fn unwrap(self) -&gt; T {
        match self {
            Option::Some(val) =&gt; val,
            Option::None =&gt;
              panic!(&quot;called `Option::unwrap()` on a `None` value&quot;),
        }
    }
}
</code></pre>
<p>The <code>unwrap</code> method <em>abstracts away the case analysis</em>. This is precisely the thing
that makes <code>unwrap</code> ergonomic to use. Unfortunately, that <code>panic!</code> means that
<code>unwrap</code> is not composable: it is the bull in the china shop.</p>
<h3>Composing <code>Option&lt;T&gt;</code> values</h3>
<p>In an <a href="#code-option-ex-string-find">example from before</a>,
we saw how to use <code>find</code> to discover the extension in a file name. Of course,
not all file names have a <code>.</code> in them, so it's possible that the file name has
no extension. This <em>possibility of absence</em> is encoded into the types using
<code>Option&lt;T&gt;</code>. In other words, the compiler will force us to address the
possibility that an extension does not exist. In our case, we only print out a
message saying as such.</p>
<p>Getting the extension of a file name is a pretty common operation, so it makes
sense to put it into a function:</p>
<pre><code class="language-rust"># fn find(_: &amp;str, _: char) -&gt; Option&lt;usize&gt; { None }
// Returns the extension of the given file name, where the extension is defined
// as all characters proceeding the first `.`.
// If `file_name` has no `.`, then `None` is returned.
fn extension_explicit(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; {
    match find(file_name, '.') {
        None =&gt; None,
        Some(i) =&gt; Some(&amp;file_name[i+1..]),
    }
}
</code></pre>
<p>(Pro-tip: don't use this code. Use the
[<code>extension</code>](../std/path/struct.Path.html#method.extension)
method in the standard library instead.)</p>
<p>The code stays simple, but the important thing to notice is that the type of
<code>find</code> forces us to consider the possibility of absence. This is a good thing
because it means the compiler won't let us accidentally forget about the case
where a file name doesn't have an extension. On the other hand, doing explicit
case analysis like we've done in <code>extension_explicit</code> every time can get a bit
tiresome.</p>
<p>In fact, the case analysis in <code>extension_explicit</code> follows a very common
pattern: <em>map</em> a function on to the value inside of an <code>Option&lt;T&gt;</code>, unless the
option is <code>None</code>, in which case, return <code>None</code>.</p>
<p>Rust has parametric polymorphism, so it is very easy to define a combinator
that abstracts this pattern:</p>
<p><span id="code-option-map"></span></p>
<pre><code class="language-rust">fn map&lt;F, T, A&gt;(option: Option&lt;T&gt;, f: F) -&gt; Option&lt;A&gt; where F: FnOnce(T) -&gt; A {
    match option {
        None =&gt; None,
        Some(value) =&gt; Some(f(value)),
    }
}
</code></pre>
<p>Indeed, <code>map</code> is <a href="../std/option/enum.Option.html#method.map">defined as a method</a> on <code>Option&lt;T&gt;</code> in the standard library.
As a method, it has a slightly different signature: methods take <code>self</code>, <code>&amp;self</code>,
or <code>&amp;mut self</code> as their first argument.</p>
<p>Armed with our new combinator, we can rewrite our <code>extension_explicit</code> method
to get rid of the case analysis:</p>
<pre><code class="language-rust"># fn find(_: &amp;str, _: char) -&gt; Option&lt;usize&gt; { None }
// Returns the extension of the given file name, where the extension is defined
// as all characters proceeding the first `.`.
// If `file_name` has no `.`, then `None` is returned.
fn extension(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; {
    find(file_name, '.').map(|i| &amp;file_name[i+1..])
}
</code></pre>
<p>One other pattern we commonly find is assigning a default value to the case
when an <code>Option</code> value is <code>None</code>. For example, maybe your program assumes that
the extension of a file is <code>rs</code> even if none is present. As you might imagine,
the case analysis for this is not specific to file extensions - it can work
with any <code>Option&lt;T&gt;</code>:</p>
<pre><code class="language-rust">fn unwrap_or&lt;T&gt;(option: Option&lt;T&gt;, default: T) -&gt; T {
    match option {
        None =&gt; default,
        Some(value) =&gt; value,
    }
}
</code></pre>
<p>Like with <code>map</code> above, the standard library implementation is a method instead
of a free function.</p>
<p>The trick here is that the default value must have the same type as the value
that might be inside the <code>Option&lt;T&gt;</code>. Using it is dead simple in our case:</p>
<pre><code class="language-rust"># fn find(haystack: &amp;str, needle: char) -&gt; Option&lt;usize&gt; {
#     for (offset, c) in haystack.char_indices() {
#         if c == needle {
#             return Some(offset);
#         }
#     }
#     None
# }
#
# fn extension(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; {
#     find(file_name, '.').map(|i| &amp;file_name[i+1..])
# }
fn main() {
    assert_eq!(extension(&quot;foobar.csv&quot;).unwrap_or(&quot;rs&quot;), &quot;csv&quot;);
    assert_eq!(extension(&quot;foobar&quot;).unwrap_or(&quot;rs&quot;), &quot;rs&quot;);
}
</code></pre>
<p>(Note that <code>unwrap_or</code> is <a href="../std/option/enum.Option.html#method.unwrap_or">defined as a method</a> on <code>Option&lt;T&gt;</code> in the
standard library, so we use that here instead of the free-standing function we
defined above. Don't forget to check out the more general [<code>unwrap_or_else</code>]<a href="../std/option/enum.Option.html#method.unwrap_or_else">4</a>
method.)</p>
<p>There is one more combinator that we think is worth paying special attention to:
<code>and_then</code>. It makes it easy to compose distinct computations that admit the
<em>possibility of absence</em>. For example, much of the code in this section is
about finding an extension given a file name. In order to do this, you first
need the file name which is typically extracted from a file <em>path</em>. While most
file paths have a file name, not <em>all</em> of them do. For example, <code>.</code>, <code>..</code> or
<code>/</code>.</p>
<p>So, we are tasked with the challenge of finding an extension given a file
<em>path</em>. Let's start with explicit case analysis:</p>
<pre><code class="language-rust"># fn extension(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; { None }
fn file_path_ext_explicit(file_path: &amp;str) -&gt; Option&lt;&amp;str&gt; {
    match file_name(file_path) {
        None =&gt; None,
        Some(name) =&gt; match extension(name) {
            None =&gt; None,
            Some(ext) =&gt; Some(ext),
        }
    }
}

fn file_name(file_path: &amp;str) -&gt; Option&lt;&amp;str&gt; {
  // implementation elided
  unimplemented!()
}
</code></pre>
<p>You might think that we could use the <code>map</code> combinator to reduce the case
analysis, but its type doesn't quite fit...</p>
<pre><code class="language-rust,ignore">fn file_path_ext(file_path: &amp;str) -&gt; Option&lt;&amp;str&gt; {
    file_name(file_path).map(|x| extension(x)) //Compilation error
}
</code></pre>
<p>The <code>map</code> function here wraps the value returned by the <code>extension</code> function
inside an <code>Option&lt;_&gt;</code> and since the <code>extension</code> function itself returns an
<code>Option&lt;&amp;str&gt;</code> the expression <code>file_name(file_path).map(|x| extension(x))</code>
actually returns an <code>Option&lt;Option&lt;&amp;str&gt;&gt;</code>.</p>
<p>But since <code>file_path_ext</code> just returns <code>Option&lt;&amp;str&gt;</code> (and not
<code>Option&lt;Option&lt;&amp;str&gt;&gt;</code>) we get a compilation error.</p>
<p>The result of the function taken by map as input is <em>always</em> [rewrapped with
<code>Some</code>](#code-option-map). Instead, we need something like <code>map</code>, but which
allows the caller to return a <code>Option&lt;_&gt;</code> directly without wrapping it in
another <code>Option&lt;_&gt;</code>.</p>
<p>Its generic implementation is even simpler than <code>map</code>:</p>
<pre><code class="language-rust">fn and_then&lt;F, T, A&gt;(option: Option&lt;T&gt;, f: F) -&gt; Option&lt;A&gt;
        where F: FnOnce(T) -&gt; Option&lt;A&gt; {
    match option {
        None =&gt; None,
        Some(value) =&gt; f(value),
    }
}
</code></pre>
<p>Now we can rewrite our <code>file_path_ext</code> function without explicit case analysis:</p>
<pre><code class="language-rust"># fn extension(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; { None }
# fn file_name(file_path: &amp;str) -&gt; Option&lt;&amp;str&gt; { None }
fn file_path_ext(file_path: &amp;str) -&gt; Option&lt;&amp;str&gt; {
    file_name(file_path).and_then(extension)
}
</code></pre>
<p>Side note: Since <code>and_then</code> essentially works like <code>map</code> but returns an
<code>Option&lt;_&gt;</code> instead of an <code>Option&lt;Option&lt;_&gt;&gt;</code> it is known as <code>flatmap</code> in some
other languages.</p>
<p>The <code>Option</code> type has many other combinators <a href="../std/option/enum.Option.html">defined in the standard
library</a>. It is a good idea to skim this list and familiarize
yourself with what's available—they can often reduce case analysis
for you. Familiarizing yourself with these combinators will pay
dividends because many of them are also defined (with similar
semantics) for <code>Result</code>, which we will talk about next.</p>
<p>Combinators make using types like <code>Option</code> ergonomic because they reduce
explicit case analysis. They are also composable because they permit the caller
to handle the possibility of absence in their own way. Methods like <code>unwrap</code>
remove choices because they will panic if <code>Option&lt;T&gt;</code> is <code>None</code>.</p>
<h2>The <code>Result</code> type</h2>
<p>The <code>Result</code> type is also
<a href="../std/result/">defined in the standard library</a>:</p>
<p><span id="code-result-def"></span></p>
<pre><code class="language-rust">enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
</code></pre>
<p>The <code>Result</code> type is a richer version of <code>Option</code>. Instead of expressing the
possibility of <em>absence</em> like <code>Option</code> does, <code>Result</code> expresses the possibility
of <em>error</em>. Usually, the <em>error</em> is used to explain why the execution of some
computation failed. This is a strictly more general form of <code>Option</code>. Consider
the following type alias, which is semantically equivalent to the real
<code>Option&lt;T&gt;</code> in every way:</p>
<pre><code class="language-rust">type Option&lt;T&gt; = Result&lt;T, ()&gt;;
</code></pre>
<p>This fixes the second type parameter of <code>Result</code> to always be <code>()</code> (pronounced
“unit” or “empty tuple”). Exactly one value inhabits the <code>()</code> type: <code>()</code>. (Yup,
the type and value level terms have the same notation!)</p>
<p>The <code>Result</code> type is a way of representing one of two possible outcomes in a
computation. By convention, one outcome is meant to be expected or “<code>Ok</code>” while
the other outcome is meant to be unexpected or “<code>Err</code>”.</p>
<p>Just like <code>Option</code>, the <code>Result</code> type also has an
<a href="../std/result/enum.Result.html#method.unwrap"><code>unwrap</code> method
defined</a>
in the standard library. Let's define it:</p>
<pre><code class="language-rust"># enum Result&lt;T, E&gt; { Ok(T), Err(E) }
impl&lt;T, E: ::std::fmt::Debug&gt; Result&lt;T, E&gt; {
    fn unwrap(self) -&gt; T {
        match self {
            Result::Ok(val) =&gt; val,
            Result::Err(err) =&gt;
              panic!(&quot;called `Result::unwrap()` on an `Err` value: {:?}&quot;, err),
        }
    }
}
</code></pre>
<p>This is effectively the same as our [definition for
<code>Option::unwrap</code>](#code-option-def-unwrap), except it includes the
error value in the <code>panic!</code> message. This makes debugging easier, but
it also requires us to add a [<code>Debug</code>]<a href="../std/fmt/trait.Debug.html">8</a> constraint on the <code>E</code> type
parameter (which represents our error type). Since the vast majority
of types should satisfy the <code>Debug</code> constraint, this tends to work out
in practice. (<code>Debug</code> on a type simply means that there's a reasonable
way to print a human readable description of values with that type.)</p>
<p>OK, let's move on to an example.</p>
<h3>Parsing integers</h3>
<p>The Rust standard library makes converting strings to integers dead simple.
It's so easy in fact, that it is very tempting to write something like the
following:</p>
<pre><code class="language-rust">fn double_number(number_str: &amp;str) -&gt; i32 {
    2 * number_str.parse::&lt;i32&gt;().unwrap()
}

fn main() {
    let n: i32 = double_number(&quot;10&quot;);
    assert_eq!(n, 20);
}
</code></pre>
<p>At this point, you should be skeptical of calling <code>unwrap</code>. For example, if
the string doesn't parse as a number, you'll get a panic:</p>
<pre><code class="language-text">thread '&lt;main&gt;' panicked at 'called `Result::unwrap()` on an `Err` value: ParseIntError { kind: InvalidDigit }', /home/rustbuild/src/rust-buildbot/slave/beta-dist-rustc-linux/build/src/libcore/result.rs:729
</code></pre>
<p>This is rather unsightly, and if this happened inside a library you're
using, you might be understandably annoyed. Instead, we should try to
handle the error in our function and let the caller decide what to
do. This means changing the return type of <code>double_number</code>. But to
what? Well, that requires looking at the signature of the <a href="../std/primitive.str.html#method.parse"><code>parse</code>
method</a> in the standard library:</p>
<pre><code class="language-rust,ignore">impl str {
    fn parse&lt;F: FromStr&gt;(&amp;self) -&gt; Result&lt;F, F::Err&gt;;
}
</code></pre>
<p>Hmm. So we at least know that we need to use a <code>Result</code>. Certainly, it's
possible that this could have returned an <code>Option</code>. After all, a string either
parses as a number or it doesn't, right? That's certainly a reasonable way to
go, but the implementation internally distinguishes <em>why</em> the string didn't
parse as an integer. (Whether it's an empty string, an invalid digit, too big
or too small.) Therefore, using a <code>Result</code> makes sense because we want to
provide more information than simply “absence.” We want to say <em>why</em> the
parsing failed. You should try to emulate this line of reasoning when faced
with a choice between <code>Option</code> and <code>Result</code>. If you can provide detailed error
information, then you probably should. (We'll see more on this later.)</p>
<p>OK, but how do we write our return type? The <code>parse</code> method as defined
above is generic over all the different number types defined in the
standard library. We could (and probably should) also make our
function generic, but let's favor explicitness for the moment. We only
care about <code>i32</code>, so we need to [find its implementation of
<code>FromStr</code>](../std/primitive.i32.html) (do a <code>CTRL-F</code> in your browser
for “FromStr”) and look at its <a href="../book/associated-types.html">associated type</a> <code>Err</code>. We did
this so we can find the concrete error type. In this case, it's
[<code>std::num::ParseIntError</code>](../std/num/struct.ParseIntError.html).
Finally, we can rewrite our function:</p>
<pre><code class="language-rust">use std::num::ParseIntError;

fn double_number(number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    match number_str.parse::&lt;i32&gt;() {
        Ok(n) =&gt; Ok(2 * n),
        Err(err) =&gt; Err(err),
    }
}

fn main() {
    match double_number(&quot;10&quot;) {
        Ok(n) =&gt; assert_eq!(n, 20),
        Err(err) =&gt; println!(&quot;Error: {:?}&quot;, err),
    }
}
</code></pre>
<p>This is a little better, but now we've written a lot more code! The case
analysis has once again bitten us.</p>
<p>Combinators to the rescue! Just like <code>Option</code>, <code>Result</code> has lots of combinators
defined as methods. There is a large intersection of common combinators between
<code>Result</code> and <code>Option</code>. In particular, <code>map</code> is part of that intersection:</p>
<pre><code class="language-rust">use std::num::ParseIntError;

fn double_number(number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    number_str.parse::&lt;i32&gt;().map(|n| 2 * n)
}

fn main() {
    match double_number(&quot;10&quot;) {
        Ok(n) =&gt; assert_eq!(n, 20),
        Err(err) =&gt; println!(&quot;Error: {:?}&quot;, err),
    }
}
</code></pre>
<p>The usual suspects are all there for <code>Result</code>, including
[<code>unwrap_or</code>](../std/result/enum.Result.html#method.unwrap_or) and
[<code>and_then</code>](../std/result/enum.Result.html#method.and_then).
Additionally, since <code>Result</code> has a second type parameter, there are
combinators that affect only the error type, such as
[<code>map_err</code>](../std/result/enum.Result.html#method.map_err) (instead of
<code>map</code>) and [<code>or_else</code>](../std/result/enum.Result.html#method.or_else)
(instead of <code>and_then</code>).</p>
<h3>The <code>Result</code> type alias idiom</h3>
<p>In the standard library, you may frequently see types like
<code>Result&lt;i32&gt;</code>. But wait, [we defined <code>Result</code>](#code-result-def) to
have two type parameters. How can we get away with only specifying
one? The key is to define a <code>Result</code> type alias that <em>fixes</em> one of
the type parameters to a particular type. Usually the fixed type is
the error type. For example, our previous example parsing integers
could be rewritten like this:</p>
<pre><code class="language-rust">use std::num::ParseIntError;
use std::result;

type Result&lt;T&gt; = result::Result&lt;T, ParseIntError&gt;;

fn double_number(number_str: &amp;str) -&gt; Result&lt;i32&gt; {
    unimplemented!();
}
</code></pre>
<p>Why would we do this? Well, if we have a lot of functions that could return
<code>ParseIntError</code>, then it's much more convenient to define an alias that always
uses <code>ParseIntError</code> so that we don't have to write it out all the time.</p>
<p>The most prominent place this idiom is used in the standard library is
with [<code>io::Result</code>](../std/io/type.Result.html). Typically, one writes
<code>io::Result&lt;T&gt;</code>, which makes it clear that you're using the <code>io</code>
module's type alias instead of the plain definition from
<code>std::result</code>. (This idiom is also used for
[<code>fmt::Result</code>](../std/fmt/type.Result.html).)</p>
<h2>A brief interlude: unwrapping isn't evil</h2>
<p>If you've been following along, you might have noticed that I've taken a pretty
hard line against calling methods like <code>unwrap</code> that could <code>panic</code> and abort
your program. <em>Generally speaking</em>, this is good advice.</p>
<p>However, <code>unwrap</code> can still be used judiciously. What exactly justifies use of
<code>unwrap</code> is somewhat of a grey area and reasonable people can disagree. I'll
summarize some of my <em>opinions</em> on the matter.</p>
<ul>
<li><strong>In examples and quick 'n' dirty code.</strong> Sometimes you're writing examples
or a quick program, and error handling simply isn't important. Beating the
convenience of <code>unwrap</code> can be hard in such scenarios, so it is very
appealing.</li>
<li><strong>When panicking indicates a bug in the program.</strong> When the invariants of
your code should prevent a certain case from happening (like, say, popping
from an empty stack), then panicking can be permissible. This is because it
exposes a bug in your program. This can be explicit, like from an <code>assert!</code>
failing, or it could be because your index into an array was out of bounds.</li>
</ul>
<p>This is probably not an exhaustive list. Moreover, when using an
<code>Option</code>, it is often better to use its
[<code>expect</code>](../std/option/enum.Option.html#method.expect)
method. <code>expect</code> does exactly the same thing as <code>unwrap</code>, except it
prints a message you give to <code>expect</code>. This makes the resulting panic
a bit nicer to deal with, since it will show your message instead of
“called unwrap on a <code>None</code> value.”</p>
<p>My advice boils down to this: use good judgment. There's a reason why the words
“never do X” or “Y is considered harmful” don't appear in my writing. There are
trade offs to all things, and it is up to you as the programmer to determine
what is acceptable for your use cases. My goal is only to help you evaluate
trade offs as accurately as possible.</p>
<p>Now that we've covered the basics of error handling in Rust, and
explained unwrapping, let's start exploring more of the standard
library.</p>
<h1>Working with multiple error types</h1>
<p>Thus far, we've looked at error handling where everything was either an
<code>Option&lt;T&gt;</code> or a <code>Result&lt;T, SomeError&gt;</code>. But what happens when you have both an
<code>Option</code> and a <code>Result</code>? Or what if you have a <code>Result&lt;T, Error1&gt;</code> and a
<code>Result&lt;T, Error2&gt;</code>? Handling <em>composition of distinct error types</em> is the next
challenge in front of us, and it will be the major theme throughout the rest of
this section.</p>
<h2>Composing <code>Option</code> and <code>Result</code></h2>
<p>So far, I've talked about combinators defined for <code>Option</code> and combinators
defined for <code>Result</code>. We can use these combinators to compose results of
different computations without doing explicit case analysis.</p>
<p>Of course, in real code, things aren't always as clean. Sometimes you have a
mix of <code>Option</code> and <code>Result</code> types. Must we resort to explicit case analysis,
or can we continue using combinators?</p>
<p>For now, let's revisit one of the first examples in this section:</p>
<pre><code class="language-rust,should_panic">use std::env;

fn main() {
    let mut argv = env::args();
    let arg: String = argv.nth(1).unwrap(); // error 1
    let n: i32 = arg.parse().unwrap(); // error 2
    println!(&quot;{}&quot;, 2 * n);
}
</code></pre>
<p>Given our new found knowledge of <code>Option</code>, <code>Result</code> and their various
combinators, we should try to rewrite this so that errors are handled properly
and the program doesn't panic if there's an error.</p>
<p>The tricky aspect here is that <code>argv.nth(1)</code> produces an <code>Option</code> while
<code>arg.parse()</code> produces a <code>Result</code>. These aren't directly composable. When faced
with both an <code>Option</code> and a <code>Result</code>, the solution is <em>usually</em> to convert the
<code>Option</code> to a <code>Result</code>. In our case, the absence of a command line parameter
(from <code>env::args()</code>) means the user didn't invoke the program correctly. We
could use a <code>String</code> to describe the error. Let's try:</p>
<p><span id="code-error-double-string"></span></p>
<pre><code class="language-rust">use std::env;

fn double_arg(mut argv: env::Args) -&gt; Result&lt;i32, String&gt; {
    argv.nth(1)
        .ok_or(&quot;Please give at least one argument&quot;.to_owned())
        .and_then(|arg| arg.parse::&lt;i32&gt;().map_err(|err| err.to_string()))
        .map(|n| 2 * n)
}

fn main() {
    match double_arg(env::args()) {
        Ok(n) =&gt; println!(&quot;{}&quot;, n),
        Err(err) =&gt; println!(&quot;Error: {}&quot;, err),
    }
}
</code></pre>
<p>There are a couple new things in this example. The first is the use of the
[<code>Option::ok_or</code>](../std/option/enum.Option.html#method.ok_or)
combinator. This is one way to convert an <code>Option</code> into a <code>Result</code>. The
conversion requires you to specify what error to use if <code>Option</code> is <code>None</code>.
Like the other combinators we've seen, its definition is very simple:</p>
<pre><code class="language-rust">fn ok_or&lt;T, E&gt;(option: Option&lt;T&gt;, err: E) -&gt; Result&lt;T, E&gt; {
    match option {
        Some(val) =&gt; Ok(val),
        None =&gt; Err(err),
    }
}
</code></pre>
<p>The other new combinator used here is
[<code>Result::map_err</code>](../std/result/enum.Result.html#method.map_err).
This is like <code>Result::map</code>, except it maps a function on to the <em>error</em>
portion of a <code>Result</code> value. If the <code>Result</code> is an <code>Ok(...)</code> value, then it is
returned unmodified.</p>
<p>We use <code>map_err</code> here because it is necessary for the error types to remain
the same (because of our use of <code>and_then</code>). Since we chose to convert the
<code>Option&lt;String&gt;</code> (from <code>argv.nth(1)</code>) to a <code>Result&lt;String, String&gt;</code>, we must
also convert the <code>ParseIntError</code> from <code>arg.parse()</code> to a <code>String</code>.</p>
<h2>The limits of combinators</h2>
<p>Doing IO and parsing input is a very common task, and it's one that I
personally have done a lot of in Rust. Therefore, we will use (and continue to
use) IO and various parsing routines to exemplify error handling.</p>
<p>Let's start simple. We are tasked with opening a file, reading all of its
contents and converting its contents to a number. Then we multiply it by <code>2</code>
and print the output.</p>
<p>Although I've tried to convince you not to use <code>unwrap</code>, it can be useful
to first write your code using <code>unwrap</code>. It allows you to focus on your problem
instead of the error handling, and it exposes the points where proper error
handling need to occur. Let's start there so we can get a handle on the code,
and then refactor it to use better error handling.</p>
<pre><code class="language-rust,should_panic">use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; i32 {
    let mut file = File::open(file_path).unwrap(); // error 1
    let mut contents = String::new();
    file.read_to_string(&amp;mut contents).unwrap(); // error 2
    let n: i32 = contents.trim().parse().unwrap(); // error 3
    2 * n
}

fn main() {
    let doubled = file_double(&quot;foobar&quot;);
    println!(&quot;{}&quot;, doubled);
}
</code></pre>
<p>(N.B. The <code>AsRef&lt;Path&gt;</code> is used because those are the
[same bounds used on
<code>std::fs::File::open</code>](../std/fs/struct.File.html#method.open).
This makes it ergonomic to use any kind of string as a file path.)</p>
<p>There are three different errors that can occur here:</p>
<ol>
<li>A problem opening the file.</li>
<li>A problem reading data from the file.</li>
<li>A problem parsing the data as a number.</li>
</ol>
<p>The first two problems are described via the
[<code>std::io::Error</code>](../std/io/struct.Error.html) type. We know this
because of the return types of
[<code>std::fs::File::open</code>](../std/fs/struct.File.html#method.open) and
[<code>std::io::Read::read_to_string</code>](../std/io/trait.Read.html#method.read_to_string).
(Note that they both use the <a href="#the-result-type-alias-idiom"><code>Result</code> type alias
idiom</a> described previously. If you
click on the <code>Result</code> type, you'll <a href="../std/io/type.Result.html">see the type
alias</a>, and consequently, the underlying
<code>io::Error</code> type.)  The third problem is described by the
[<code>std::num::ParseIntError</code>](../std/num/struct.ParseIntError.html)
type. The <code>io::Error</code> type in particular is <em>pervasive</em> throughout the
standard library. You will see it again and again.</p>
<p>Let's start the process of refactoring the <code>file_double</code> function. To make this
function composable with other components of the program, it should <em>not</em> panic
if any of the above error conditions are met. Effectively, this means that the
function should <em>return an error</em> if any of its operations fail. Our problem is
that the return type of <code>file_double</code> is <code>i32</code>, which does not give us any
useful way of reporting an error. Thus, we must start by changing the return
type from <code>i32</code> to something else.</p>
<p>The first thing we need to decide: should we use <code>Option</code> or <code>Result</code>? We
certainly could use <code>Option</code> very easily. If any of the three errors occur, we
could simply return <code>None</code>. This will work <em>and it is better than panicking</em>,
but we can do a lot better. Instead, we should pass some detail about the error
that occurred. Since we want to express the <em>possibility of error</em>, we should
use <code>Result&lt;i32, E&gt;</code>. But what should <code>E</code> be? Since two <em>different</em> types of
errors can occur, we need to convert them to a common type. One such type is
<code>String</code>. Let's see how that impacts our code:</p>
<pre><code class="language-rust">use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, String&gt; {
    File::open(file_path)
         .map_err(|err| err.to_string())
         .and_then(|mut file| {
              let mut contents = String::new();
              file.read_to_string(&amp;mut contents)
                  .map_err(|err| err.to_string())
                  .map(|_| contents)
         })
         .and_then(|contents| {
              contents.trim().parse::&lt;i32&gt;()
                      .map_err(|err| err.to_string())
         })
         .map(|n| 2 * n)
}

fn main() {
    match file_double(&quot;foobar&quot;) {
        Ok(n) =&gt; println!(&quot;{}&quot;, n),
        Err(err) =&gt; println!(&quot;Error: {}&quot;, err),
    }
}
</code></pre>
<p>This code looks a bit hairy. It can take quite a bit of practice before code
like this becomes easy to write. The way we write it is by <em>following the
types</em>. As soon as we changed the return type of <code>file_double</code> to
<code>Result&lt;i32, String&gt;</code>, we had to start looking for the right combinators. In
this case, we only used three different combinators: <code>and_then</code>, <code>map</code> and
<code>map_err</code>.</p>
<p><code>and_then</code> is used to chain multiple computations where each computation could
return an error. After opening the file, there are two more computations that
could fail: reading from the file and parsing the contents as a number.
Correspondingly, there are two calls to <code>and_then</code>.</p>
<p><code>map</code> is used to apply a function to the <code>Ok(...)</code> value of a <code>Result</code>. For
example, the very last call to <code>map</code> multiplies the <code>Ok(...)</code> value (which is
an <code>i32</code>) by <code>2</code>. If an error had occurred before that point, this operation
would have been skipped because of how <code>map</code> is defined.</p>
<p><code>map_err</code> is the trick that makes all of this work. <code>map_err</code> is like
<code>map</code>, except it applies a function to the <code>Err(...)</code> value of a <code>Result</code>. In
this case, we want to convert all of our errors to one type: <code>String</code>. Since
both <code>io::Error</code> and <code>num::ParseIntError</code> implement <code>ToString</code>, we can call the
<code>to_string()</code> method to convert them.</p>
<p>With all of that said, the code is still hairy. Mastering use of combinators is
important, but they have their limits. Let's try a different approach: early
returns.</p>
<h2>Early returns</h2>
<p>I'd like to take the code from the previous section and rewrite it using <em>early
returns</em>. Early returns let you exit the function early. We can't return early
in <code>file_double</code> from inside another closure, so we'll need to revert back to
explicit case analysis.</p>
<pre><code class="language-rust">use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, String&gt; {
    let mut file = match File::open(file_path) {
        Ok(file) =&gt; file,
        Err(err) =&gt; return Err(err.to_string()),
    };
    let mut contents = String::new();
    if let Err(err) = file.read_to_string(&amp;mut contents) {
        return Err(err.to_string());
    }
    let n: i32 = match contents.trim().parse() {
        Ok(n) =&gt; n,
        Err(err) =&gt; return Err(err.to_string()),
    };
    Ok(2 * n)
}

fn main() {
    match file_double(&quot;foobar&quot;) {
        Ok(n) =&gt; println!(&quot;{}&quot;, n),
        Err(err) =&gt; println!(&quot;Error: {}&quot;, err),
    }
}
</code></pre>
<p>Reasonable people can disagree over whether this code is better than the code
that uses combinators, but if you aren't familiar with the combinator approach,
this code looks simpler to read to me. It uses explicit case analysis with
<code>match</code> and <code>if let</code>. If an error occurs, it simply stops executing the
function and returns the error (by converting it to a string).</p>
<p>Isn't this a step backwards though? Previously, we said that the key to
ergonomic error handling is reducing explicit case analysis, yet we've reverted
back to explicit case analysis here. It turns out, there are <em>multiple</em> ways to
reduce explicit case analysis. Combinators aren't the only way.</p>
<h2>The <code>try!</code> macro</h2>
<p>A cornerstone of error handling in Rust is the <code>try!</code> macro. The <code>try!</code> macro
abstracts case analysis like combinators, but unlike combinators, it also
abstracts <em>control flow</em>. Namely, it can abstract the <em>early return</em> pattern
seen above.</p>
<p>Here is a simplified definition of a <code>try!</code> macro:</p>
<p><span id="code-try-def-simple"></span></p>
<pre><code class="language-rust">macro_rules! try {
    ($e:expr) =&gt; (match $e {
        Ok(val) =&gt; val,
        Err(err) =&gt; return Err(err),
    });
}
</code></pre>
<p>(The <a href="../std/macro.try!.html">real definition</a> is a bit more
sophisticated. We will address that later.)</p>
<p>Using the <code>try!</code> macro makes it very easy to simplify our last example. Since
it does the case analysis and the early return for us, we get tighter code that
is easier to read:</p>
<pre><code class="language-rust">use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, String&gt; {
    let mut file = try!(File::open(file_path).map_err(|e| e.to_string()));
    let mut contents = String::new();
    try!(file.read_to_string(&amp;mut contents).map_err(|e| e.to_string()));
    let n = try!(contents.trim().parse::&lt;i32&gt;().map_err(|e| e.to_string()));
    Ok(2 * n)
}

fn main() {
    match file_double(&quot;foobar&quot;) {
        Ok(n) =&gt; println!(&quot;{}&quot;, n),
        Err(err) =&gt; println!(&quot;Error: {}&quot;, err),
    }
}
</code></pre>
<p>The <code>map_err</code> calls are still necessary given
[our definition of <code>try!</code>](#code-try-def-simple).
This is because the error types still need to be converted to <code>String</code>.
The good news is that we will soon learn how to remove those <code>map_err</code> calls!
The bad news is that we will need to learn a bit more about a couple important
traits in the standard library before we can remove the <code>map_err</code> calls.</p>
<h2>Defining your own error type</h2>
<p>Before we dive into some of the standard library error traits, I'd like to wrap
up this section by removing the use of <code>String</code> as our error type in the
previous examples.</p>
<p>Using <code>String</code> as we did in our previous examples is convenient because it's
easy to convert errors to strings, or even make up your own errors as strings
on the spot. However, using <code>String</code> for your errors has some downsides.</p>
<p>The first downside is that the error messages tend to clutter your
code. It's possible to define the error messages elsewhere, but unless
you're unusually disciplined, it is very tempting to embed the error
message into your code. Indeed, we did exactly this in a <a href="#code-error-double-string">previous
example</a>.</p>
<p>The second and more important downside is that <code>String</code>s are <em>lossy</em>. That is,
if all errors are converted to strings, then the errors we pass to the caller
become completely opaque. The only reasonable thing the caller can do with a
<code>String</code> error is show it to the user. Certainly, inspecting the string to
determine the type of error is not robust. (Admittedly, this downside is far
more important inside of a library as opposed to, say, an application.)</p>
<p>For example, the <code>io::Error</code> type embeds an
[<code>io::ErrorKind</code>](../std/io/enum.ErrorKind.html),
which is <em>structured data</em> that represents what went wrong during an IO
operation. This is important because you might want to react differently
depending on the error. (e.g., A <code>BrokenPipe</code> error might mean quitting your
program gracefully while a <code>NotFound</code> error might mean exiting with an error
code and showing an error to the user.) With <code>io::ErrorKind</code>, the caller can
examine the type of an error with case analysis, which is strictly superior
to trying to tease out the details of an error inside of a <code>String</code>.</p>
<p>Instead of using a <code>String</code> as an error type in our previous example of reading
an integer from a file, we can define our own error type that represents errors
with <em>structured data</em>. We endeavor to not drop information from underlying
errors in case the caller wants to inspect the details.</p>
<p>The ideal way to represent <em>one of many possibilities</em> is to define our own
sum type using <code>enum</code>. In our case, an error is either an <code>io::Error</code> or a
<code>num::ParseIntError</code>, so a natural definition arises:</p>
<pre><code class="language-rust">use std::io;
use std::num;

// We derive `Debug` because all types should probably derive `Debug`.
// This gives us a reasonable human readable description of `CliError` values.
#[derive(Debug)]
enum CliError {
    Io(io::Error),
    Parse(num::ParseIntError),
}
</code></pre>
<p>Tweaking our code is very easy. Instead of converting errors to strings, we
simply convert them to our <code>CliError</code> type using the corresponding value
constructor:</p>
<pre><code class="language-rust"># #[derive(Debug)]
# enum CliError { Io(::std::io::Error), Parse(::std::num::ParseIntError) }
use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, CliError&gt; {
    let mut file = try!(File::open(file_path).map_err(CliError::Io));
    let mut contents = String::new();
    try!(file.read_to_string(&amp;mut contents).map_err(CliError::Io));
    let n: i32 = try!(contents.trim().parse().map_err(CliError::Parse));
    Ok(2 * n)
}

fn main() {
    match file_double(&quot;foobar&quot;) {
        Ok(n) =&gt; println!(&quot;{}&quot;, n),
        Err(err) =&gt; println!(&quot;Error: {:?}&quot;, err),
    }
}
</code></pre>
<p>The only change here is switching <code>map_err(|e| e.to_string())</code> (which converts
errors to strings) to <code>map_err(CliError::Io)</code> or <code>map_err(CliError::Parse)</code>.
The <em>caller</em> gets to decide the level of detail to report to the user. In
effect, using a <code>String</code> as an error type removes choices from the caller while
using a custom <code>enum</code> error type like <code>CliError</code> gives the caller all of the
conveniences as before in addition to <em>structured data</em> describing the error.</p>
<p>A rule of thumb is to define your own error type, but a <code>String</code> error type
will do in a pinch, particularly if you're writing an application. If you're
writing a library, defining your own error type should be strongly preferred so
that you don't remove choices from the caller unnecessarily.</p>
<h1>Standard library traits used for error handling</h1>
<p>The standard library defines two integral traits for error handling:
[<code>std::error::Error</code>](../std/error/trait.Error.html) and
[<code>std::convert::From</code>](../std/convert/trait.From.html). While <code>Error</code>
is designed specifically for generically describing errors, the <code>From</code>
trait serves a more general role for converting values between two
distinct types.</p>
<h2>The <code>Error</code> trait</h2>
<p>The <code>Error</code> trait is <a href="../std/error/trait.Error.html">defined in the standard
library</a>:</p>
<pre><code class="language-rust">use std::fmt::{Debug, Display};

trait Error: Debug + Display {
  /// A short description of the error.
  fn description(&amp;self) -&gt; &amp;str;

  /// The lower level cause of this error, if any.
  fn cause(&amp;self) -&gt; Option&lt;&amp;Error&gt; { None }
}
</code></pre>
<p>This trait is super generic because it is meant to be implemented for <em>all</em>
types that represent errors. This will prove useful for writing composable code
as we'll see later. Otherwise, the trait allows you to do at least the
following things:</p>
<ul>
<li>Obtain a <code>Debug</code> representation of the error.</li>
<li>Obtain a user-facing <code>Display</code> representation of the error.</li>
<li>Obtain a short description of the error (via the <code>description</code> method).</li>
<li>Inspect the causal chain of an error, if one exists (via the <code>cause</code> method).</li>
</ul>
<p>The first two are a result of <code>Error</code> requiring impls for both <code>Debug</code> and
<code>Display</code>. The latter two are from the two methods defined on <code>Error</code>. The
power of <code>Error</code> comes from the fact that all error types impl <code>Error</code>, which
means errors can be existentially quantified as a
<a href="../book/trait-objects.html">trait object</a>.
This manifests as either <code>Box&lt;Error&gt;</code> or <code>&amp;Error</code>. Indeed, the <code>cause</code> method
returns an <code>&amp;Error</code>, which is itself a trait object. We'll revisit the
<code>Error</code> trait's utility as a trait object later.</p>
<p>For now, it suffices to show an example implementing the <code>Error</code> trait. Let's
use the error type we defined in the
<a href="#defining-your-own-error-type">previous section</a>:</p>
<pre><code class="language-rust">use std::io;
use std::num;

// We derive `Debug` because all types should probably derive `Debug`.
// This gives us a reasonable human readable description of `CliError` values.
#[derive(Debug)]
enum CliError {
    Io(io::Error),
    Parse(num::ParseIntError),
}
</code></pre>
<p>This particular error type represents the possibility of two types of errors
occurring: an error dealing with I/O or an error converting a string to a
number. The error could represent as many error types as you want by adding new
variants to the <code>enum</code> definition.</p>
<p>Implementing <code>Error</code> is pretty straight-forward. It's mostly going to be a lot
explicit case analysis.</p>
<pre><code class="language-rust,ignore">use std::error;
use std::fmt;

impl fmt::Display for CliError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match *self {
            // Both underlying errors already impl `Display`, so we defer to
            // their implementations.
            CliError::Io(ref err) =&gt; write!(f, &quot;IO error: {}&quot;, err),
            CliError::Parse(ref err) =&gt; write!(f, &quot;Parse error: {}&quot;, err),
        }
    }
}

impl error::Error for CliError {
    fn description(&amp;self) -&gt; &amp;str {
        // Both underlying errors already impl `Error`, so we defer to their
        // implementations.
        match *self {
            CliError::Io(ref err) =&gt; err.description(),
            CliError::Parse(ref err) =&gt; err.description(),
        }
    }

    fn cause(&amp;self) -&gt; Option&lt;&amp;error::Error&gt; {
        match *self {
            // N.B. Both of these implicitly cast `err` from their concrete
            // types (either `&amp;io::Error` or `&amp;num::ParseIntError`)
            // to a trait object `&amp;Error`. This works because both error types
            // implement `Error`.
            CliError::Io(ref err) =&gt; Some(err),
            CliError::Parse(ref err) =&gt; Some(err),
        }
    }
}
</code></pre>
<p>We note that this is a very typical implementation of <code>Error</code>: match on your
different error types and satisfy the contracts defined for <code>description</code> and
<code>cause</code>.</p>
<h2>The <code>From</code> trait</h2>
<p>The <code>std::convert::From</code> trait is
<a href="../std/convert/trait.From.html">defined in the standard
library</a>:</p>
<p><span id="code-from-def"></span></p>
<pre><code class="language-rust">trait From&lt;T&gt; {
    fn from(T) -&gt; Self;
}
</code></pre>
<p>Deliciously simple, yes? <code>From</code> is very useful because it gives us a generic
way to talk about conversion <em>from</em> a particular type <code>T</code> to some other type
(in this case, “some other type” is the subject of the impl, or <code>Self</code>).
The crux of <code>From</code> is the
<a href="../std/convert/trait.From.html">set of implementations provided by the standard
library</a>.</p>
<p>Here are a few simple examples demonstrating how <code>From</code> works:</p>
<pre><code class="language-rust">let string: String = From::from(&quot;foo&quot;);
let bytes: Vec&lt;u8&gt; = From::from(&quot;foo&quot;);
let cow: ::std::borrow::Cow&lt;str&gt; = From::from(&quot;foo&quot;);
</code></pre>
<p>OK, so <code>From</code> is useful for converting between strings. But what about errors?
It turns out, there is one critical impl:</p>
<pre><code class="language-rust,ignore">impl&lt;'a, E: Error + 'a&gt; From&lt;E&gt; for Box&lt;Error + 'a&gt;
</code></pre>
<p>This impl says that for <em>any</em> type that impls <code>Error</code>, we can convert it to a
trait object <code>Box&lt;Error&gt;</code>. This may not seem terribly surprising, but it is
useful in a generic context.</p>
<p>Remember the two errors we were dealing with previously? Specifically,
<code>io::Error</code> and <code>num::ParseIntError</code>. Since both impl <code>Error</code>, they work with
<code>From</code>:</p>
<pre><code class="language-rust">use std::error::Error;
use std::fs;
use std::io;
use std::num;

// We have to jump through some hoops to actually get error values.
let io_err: io::Error = io::Error::last_os_error();
let parse_err: num::ParseIntError = &quot;not a number&quot;.parse::&lt;i32&gt;().unwrap_err();

// OK, here are the conversions.
let err1: Box&lt;Error&gt; = From::from(io_err);
let err2: Box&lt;Error&gt; = From::from(parse_err);
</code></pre>
<p>There is a really important pattern to recognize here. Both <code>err1</code> and <code>err2</code>
have the <em>same type</em>. This is because they are existentially quantified types,
or trait objects. In particular, their underlying type is <em>erased</em> from the
compiler's knowledge, so it truly sees <code>err1</code> and <code>err2</code> as exactly the same.
Additionally, we constructed <code>err1</code> and <code>err2</code> using precisely the same
function call: <code>From::from</code>. This is because <code>From::from</code> is overloaded on both
its argument and its return type.</p>
<p>This pattern is important because it solves a problem we had earlier: it gives
us a way to reliably convert errors to the same type using the same function.</p>
<p>Time to revisit an old friend; the <code>try!</code> macro.</p>
<h2>The real <code>try!</code> macro</h2>
<p>Previously, we presented this definition of <code>try!</code>:</p>
<pre><code class="language-rust">macro_rules! try {
    ($e:expr) =&gt; (match $e {
        Ok(val) =&gt; val,
        Err(err) =&gt; return Err(err),
    });
}
</code></pre>
<p>This is not its real definition. Its real definition is
<a href="../std/macro.try!.html">in the standard library</a>:</p>
<p><span id="code-try-def"></span></p>
<pre><code class="language-rust">macro_rules! try {
    ($e:expr) =&gt; (match $e {
        Ok(val) =&gt; val,
        Err(err) =&gt; return Err(::std::convert::From::from(err)),
    });
}
</code></pre>
<p>There's one tiny but powerful change: the error value is passed through
<code>From::from</code>. This makes the <code>try!</code> macro a lot more powerful because it gives
you automatic type conversion for free.</p>
<p>Armed with our more powerful <code>try!</code> macro, let's take a look at code we wrote
previously to read a file and convert its contents to an integer:</p>
<pre><code class="language-rust">use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, String&gt; {
    let mut file = try!(File::open(file_path).map_err(|e| e.to_string()));
    let mut contents = String::new();
    try!(file.read_to_string(&amp;mut contents).map_err(|e| e.to_string()));
    let n = try!(contents.trim().parse::&lt;i32&gt;().map_err(|e| e.to_string()));
    Ok(2 * n)
}
</code></pre>
<p>Earlier, we promised that we could get rid of the <code>map_err</code> calls. Indeed, all
we have to do is pick a type that <code>From</code> works with. As we saw in the previous
section, <code>From</code> has an impl that lets it convert any error type into a
<code>Box&lt;Error&gt;</code>:</p>
<pre><code class="language-rust">use std::error::Error;
use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, Box&lt;Error&gt;&gt; {
    let mut file = try!(File::open(file_path));
    let mut contents = String::new();
    try!(file.read_to_string(&amp;mut contents));
    let n = try!(contents.trim().parse::&lt;i32&gt;());
    Ok(2 * n)
}
</code></pre>
<p>We are getting very close to ideal error handling. Our code has very little
overhead as a result from error handling because the <code>try!</code> macro encapsulates
three things simultaneously:</p>
<ol>
<li>Case analysis.</li>
<li>Control flow.</li>
<li>Error type conversion.</li>
</ol>
<p>When all three things are combined, we get code that is unencumbered by
combinators, calls to <code>unwrap</code> or case analysis.</p>
<p>There's one little nit left: the <code>Box&lt;Error&gt;</code> type is <em>opaque</em>. If we
return a <code>Box&lt;Error&gt;</code> to the caller, the caller can't (easily) inspect
underlying error type. The situation is certainly better than <code>String</code>
because the caller can call methods like
[<code>description</code>](../std/error/trait.Error.html#tymethod.description)
and [<code>cause</code>](../std/error/trait.Error.html#method.cause), but the
limitation remains: <code>Box&lt;Error&gt;</code> is opaque. (N.B. This isn't entirely
true because Rust does have runtime reflection, which is useful in
some scenarios that are <a href="https://crates.io/crates/error">beyond the scope of this
section</a>.)</p>
<p>It's time to revisit our custom <code>CliError</code> type and tie everything together.</p>
<h2>Composing custom error types</h2>
<p>In the last section, we looked at the real <code>try!</code> macro and how it does
automatic type conversion for us by calling <code>From::from</code> on the error value.
In particular, we converted errors to <code>Box&lt;Error&gt;</code>, which works, but the type
is opaque to callers.</p>
<p>To fix this, we use the same remedy that we're already familiar with: a custom
error type. Once again, here is the code that reads the contents of a file and
converts it to an integer:</p>
<pre><code class="language-rust">use std::fs::File;
use std::io::{self, Read};
use std::num;
use std::path::Path;

// We derive `Debug` because all types should probably derive `Debug`.
// This gives us a reasonable human readable description of `CliError` values.
#[derive(Debug)]
enum CliError {
    Io(io::Error),
    Parse(num::ParseIntError),
}

fn file_double_verbose&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, CliError&gt; {
    let mut file = try!(File::open(file_path).map_err(CliError::Io));
    let mut contents = String::new();
    try!(file.read_to_string(&amp;mut contents).map_err(CliError::Io));
    let n: i32 = try!(contents.trim().parse().map_err(CliError::Parse));
    Ok(2 * n)
}
</code></pre>
<p>Notice that we still have the calls to <code>map_err</code>. Why? Well, recall the
definitions of [<code>try!</code>](#code-try-def) and [<code>From</code>](#code-from-def). The
problem is that there is no <code>From</code> impl that allows us to convert from error
types like <code>io::Error</code> and <code>num::ParseIntError</code> to our own custom <code>CliError</code>.
Of course, it is easy to fix this! Since we defined <code>CliError</code>, we can impl
<code>From</code> with it:</p>
<pre><code class="language-rust"># #[derive(Debug)]
# enum CliError { Io(io::Error), Parse(num::ParseIntError) }
use std::io;
use std::num;

impl From&lt;io::Error&gt; for CliError {
    fn from(err: io::Error) -&gt; CliError {
        CliError::Io(err)
    }
}

impl From&lt;num::ParseIntError&gt; for CliError {
    fn from(err: num::ParseIntError) -&gt; CliError {
        CliError::Parse(err)
    }
}
</code></pre>
<p>All these impls are doing is teaching <code>From</code> how to create a <code>CliError</code> from
other error types. In our case, construction is as simple as invoking the
corresponding value constructor. Indeed, it is <em>typically</em> this easy.</p>
<p>We can finally rewrite <code>file_double</code>:</p>
<pre><code class="language-rust"># use std::io;
# use std::num;
# enum CliError { Io(::std::io::Error), Parse(::std::num::ParseIntError) }
# impl From&lt;io::Error&gt; for CliError {
#     fn from(err: io::Error) -&gt; CliError { CliError::Io(err) }
# }
# impl From&lt;num::ParseIntError&gt; for CliError {
#     fn from(err: num::ParseIntError) -&gt; CliError { CliError::Parse(err) }
# }

use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, CliError&gt; {
    let mut file = try!(File::open(file_path));
    let mut contents = String::new();
    try!(file.read_to_string(&amp;mut contents));
    let n: i32 = try!(contents.trim().parse());
    Ok(2 * n)
}
</code></pre>
<p>The only thing we did here was remove the calls to <code>map_err</code>. They are no
longer needed because the <code>try!</code> macro invokes <code>From::from</code> on the error value.
This works because we've provided <code>From</code> impls for all the error types that
could appear.</p>
<p>If we modified our <code>file_double</code> function to perform some other operation, say,
convert a string to a float, then we'd need to add a new variant to our error
type:</p>
<pre><code class="language-rust">use std::io;
use std::num;

enum CliError {
    Io(io::Error),
    ParseInt(num::ParseIntError),
    ParseFloat(num::ParseFloatError),
}
</code></pre>
<p>And add a new <code>From</code> impl:</p>
<pre><code class="language-rust"># enum CliError {
#     Io(::std::io::Error),
#     ParseInt(num::ParseIntError),
#     ParseFloat(num::ParseFloatError),
# }

use std::num;

impl From&lt;num::ParseFloatError&gt; for CliError {
    fn from(err: num::ParseFloatError) -&gt; CliError {
        CliError::ParseFloat(err)
    }
}
</code></pre>
<p>And that's it!</p>
<h2>Advice for library writers</h2>
<p>If your library needs to report custom errors, then you should
probably define your own error type. It's up to you whether or not to
expose its representation (like
[<code>ErrorKind</code>](../std/io/enum.ErrorKind.html)) or keep it hidden (like
[<code>ParseIntError</code>](../std/num/struct.ParseIntError.html)). Regardless
of how you do it, it's usually good practice to at least provide some
information about the error beyond its <code>String</code>
representation. But certainly, this will vary depending on use cases.</p>
<p>At a minimum, you should probably implement the
[<code>Error</code>](../std/error/trait.Error.html)
trait. This will give users of your library some minimum flexibility for
<a href="#the-real-try-macro">composing errors</a>. Implementing the <code>Error</code> trait also
means that users are guaranteed the ability to obtain a string representation
of an error (because it requires impls for both <code>fmt::Debug</code> and
<code>fmt::Display</code>).</p>
<p>Beyond that, it can also be useful to provide implementations of <code>From</code> on your
error types. This allows you (the library author) and your users to
<a href="#composing-custom-error-types">compose more detailed errors</a>. For example,
[<code>csv::Error</code>](http://burntsushi.net/rustdoc/csv/enum.Error.html)
provides <code>From</code> impls for both <code>io::Error</code> and <code>byteorder::Error</code>.</p>
<p>Finally, depending on your tastes, you may also want to define a
<a href="#the-result-type-alias-idiom"><code>Result</code> type alias</a>, particularly if your
library defines a single error type. This is used in the standard library
for [<code>io::Result</code>](../std/io/type.Result.html)
and [<code>fmt::Result</code>](../std/fmt/type.Result.html).</p>
<h1>Case study: A program to read population data</h1>
<p>This section was long, and depending on your background, it might be
rather dense. While there is plenty of example code to go along with
the prose, most of it was specifically designed to be pedagogical. So,
we're going to do something new: a case study.</p>
<p>For this, we're going to build up a command line program that lets you
query world population data. The objective is simple: you give it a location
and it will tell you the population. Despite the simplicity, there is a lot
that can go wrong!</p>
<p>The data we'll be using comes from the <a href="https://github.com/petewarden/dstkdata">Data Science
Toolkit</a>. I've prepared some data from it for this exercise. You
can either grab the <a href="http://burntsushi.net/stuff/worldcitiespop.csv.gz">world population data</a> (41MB gzip compressed,
145MB uncompressed) or only the <a href="http://burntsushi.net/stuff/uscitiespop.csv.gz">US population data</a> (2.2MB gzip
compressed, 7.2MB uncompressed).</p>
<p>Up until now, we've kept the code limited to Rust's standard library. For a real
task like this though, we'll want to at least use something to parse CSV data,
parse the program arguments and decode that stuff into Rust types automatically. For that, we'll use the
[<code>csv</code>](https://crates.io/crates/csv),
and [<code>rustc-serialize</code>](https://crates.io/crates/rustc-serialize) crates.</p>
<h2>Initial setup</h2>
<p>We're not going to spend a lot of time on setting up a project with
Cargo because it is already covered well in <a href="getting-started.html#hello-cargo">the Cargo
section</a> and <a href="http://doc.crates.io/guide.html">Cargo's documentation</a>.</p>
<p>To get started from scratch, run <code>cargo new --bin city-pop</code> and make sure your
<code>Cargo.toml</code> looks something like this:</p>
<pre><code class="language-text">[package]
name = &quot;city-pop&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Andrew Gallant &lt;jamslam@gmail.com&gt;&quot;]

[[bin]]
name = &quot;city-pop&quot;

[dependencies]
csv = &quot;0.*&quot;
rustc-serialize = &quot;0.*&quot;
getopts = &quot;0.*&quot;
</code></pre>
<p>You should already be able to run:</p>
<pre><code class="language-text">cargo build --release
./target/release/city-pop
# Outputs: Hello, world!
</code></pre>
<h2>Argument parsing</h2>
<p>Let's get argument parsing out of the way. We won't go into too much
detail on Getopts, but there is <a href="http://doc.rust-lang.org/getopts/getopts/index.html">some good documentation</a>
describing it. The short story is that Getopts generates an argument
parser and a help message from a vector of options (The fact that it
is a vector is hidden behind a struct and a set of methods). Once the
parsing is done, we can decode the program arguments into a Rust
struct. From there, we can get information about the flags, for
instance, whether they were passed in, and what arguments they
had. Here's our program with the appropriate <code>extern crate</code>
statements, and the basic argument setup for Getopts:</p>
<pre><code class="language-rust,ignore">extern crate getopts;
extern crate rustc_serialize;

use getopts::Options;
use std::env;

fn print_usage(program: &amp;str, opts: Options) {
    println!(&quot;{}&quot;, opts.usage(&amp;format!(&quot;Usage: {} [options] &lt;data-path&gt; &lt;city&gt;&quot;, program)));
}

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    let program = &amp;args[0];

    let mut opts = Options::new();
    opts.optflag(&quot;h&quot;, &quot;help&quot;, &quot;Show this usage message.&quot;);

    let matches = match opts.parse(&amp;args[1..]) {
        Ok(m)  =&gt; { m }
        Err(e) =&gt; { panic!(e.to_string()) }
    };
    if matches.opt_present(&quot;h&quot;) {
        print_usage(&amp;program, opts);
        return;
    }
    let data_path = &amp;args[1];
    let city = &amp;args[2];

    // Do stuff with information
}
</code></pre>
<p>First, we get a vector of the arguments passed into our program. We
then store the first one, knowing that it is our program's name. Once
that's done, we set up our argument flags, in this case a simplistic
help message flag. Once we have the argument flags set up, we use
<code>Options.parse</code> to parse the argument vector (starting from index one,
because index 0 is the program name). If this was successful, we
assign matches to the parsed object, if not, we panic. Once past that,
we test if the user passed in the help flag, and if so print the usage
message. The option help messages are constructed by Getopts, so all
we have to do to print the usage message is tell it what we want it to
print for the program name and template. If the user has not passed in
the help flag, we assign the proper variables to their corresponding
arguments.</p>
<h2>Writing the logic</h2>
<p>We all write code differently, but error handling is usually the last thing we
want to think about. This isn't great for the overall design of a program, but
it can be useful for rapid prototyping. Because Rust forces us to be explicit
about error handling (by making us call <code>unwrap</code>), it is easy to see which
parts of our program can cause errors.</p>
<p>In this case study, the logic is really simple. All we need to do is parse the
CSV data given to us and print out a field in matching rows. Let's do it. (Make
sure to add <code>extern crate csv;</code> to the top of your file.)</p>
<pre><code class="language-rust,ignore">use std::fs::File;

// This struct represents the data in each row of the CSV file.
// Type based decoding absolves us of a lot of the nitty gritty error
// handling, like parsing strings as integers or floats.
#[derive(Debug, RustcDecodable)]
struct Row {
    country: String,
    city: String,
    accent_city: String,
    region: String,

    // Not every row has data for the population, latitude or longitude!
    // So we express them as `Option` types, which admits the possibility of
    // absence. The CSV parser will fill in the correct value for us.
    population: Option&lt;u64&gt;,
    latitude: Option&lt;f64&gt;,
    longitude: Option&lt;f64&gt;,
}

fn print_usage(program: &amp;str, opts: Options) {
    println!(&quot;{}&quot;, opts.usage(&amp;format!(&quot;Usage: {} [options] &lt;data-path&gt; &lt;city&gt;&quot;, program)));
}

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    let program = &amp;args[0];

    let mut opts = Options::new();
    opts.optflag(&quot;h&quot;, &quot;help&quot;, &quot;Show this usage message.&quot;);

    let matches = match opts.parse(&amp;args[1..]) {
        Ok(m)  =&gt; { m }
        Err(e) =&gt; { panic!(e.to_string()) }
    };

    if matches.opt_present(&quot;h&quot;) {
        print_usage(&amp;program, opts);
        return;
    }

    let data_path = &amp;args[1];
    let city: &amp;str = &amp;args[2];

    let file = File::open(data_path).unwrap();
    let mut rdr = csv::Reader::from_reader(file);

    for row in rdr.decode::&lt;Row&gt;() {
        let row = row.unwrap();

        if row.city == city {
            println!(&quot;{}, {}: {:?}&quot;,
                row.city, row.country,
                row.population.expect(&quot;population count&quot;));
        }
    }
}
</code></pre>
<p>Let's outline the errors. We can start with the obvious: the three places that
<code>unwrap</code> is called:</p>
<ol>
<li>[<code>File::open</code>](../std/fs/struct.File.html#method.open)
can return an
[<code>io::Error</code>](../std/io/struct.Error.html).</li>
<li>[<code>csv::Reader::decode</code>](http://burntsushi.net/rustdoc/csv/struct.Reader.html#method.decode)
decodes one record at a time, and
<a href="http://burntsushi.net/rustdoc/csv/struct.DecodedRecords.html">decoding a
record</a>
(look at the <code>Item</code> associated type on the <code>Iterator</code> impl)
can produce a
[<code>csv::Error</code>](http://burntsushi.net/rustdoc/csv/enum.Error.html).</li>
<li>If <code>row.population</code> is <code>None</code>, then calling <code>expect</code> will panic.</li>
</ol>
<p>Are there any others? What if we can't find a matching city? Tools like <code>grep</code>
will return an error code, so we probably should too. So we have logic errors
specific to our problem, IO errors and CSV parsing errors. We're going to
explore two different ways to approach handling these errors.</p>
<p>I'd like to start with <code>Box&lt;Error&gt;</code>. Later, we'll see how defining our own
error type can be useful.</p>
<h2>Error handling with <code>Box&lt;Error&gt;</code></h2>
<p><code>Box&lt;Error&gt;</code> is nice because it <em>just works</em>. You don't need to define your own
error types and you don't need any <code>From</code> implementations. The downside is that
since <code>Box&lt;Error&gt;</code> is a trait object, it <em>erases the type</em>, which means the
compiler can no longer reason about its underlying type.</p>
<p><a href="#the-limits-of-combinators">Previously</a> we started refactoring our code by
changing the type of our function from <code>T</code> to <code>Result&lt;T, OurErrorType&gt;</code>. In
this case, <code>OurErrorType</code> is only <code>Box&lt;Error&gt;</code>. But what's <code>T</code>? And can we add
a return type to <code>main</code>?</p>
<p>The answer to the second question is no, we can't. That means we'll need to
write a new function. But what is <code>T</code>? The simplest thing we can do is to
return a list of matching <code>Row</code> values as a <code>Vec&lt;Row&gt;</code>. (Better code would
return an iterator, but that is left as an exercise to the reader.)</p>
<p>Let's refactor our code into its own function, but keep the calls to <code>unwrap</code>.
Note that we opt to handle the possibility of a missing population count by
simply ignoring that row.</p>
<pre><code class="language-rust,ignore">use std::path::Path;

struct Row {
    // unchanged
}

struct PopulationCount {
    city: String,
    country: String,
    // This is no longer an `Option` because values of this type are only
    // constructed if they have a population count.
    count: u64,
}

fn print_usage(program: &amp;str, opts: Options) {
    println!(&quot;{}&quot;, opts.usage(&amp;format!(&quot;Usage: {} [options] &lt;data-path&gt; &lt;city&gt;&quot;, program)));
}

fn search&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P, city: &amp;str) -&gt; Vec&lt;PopulationCount&gt; {
    let mut found = vec![];
    let file = File::open(file_path).unwrap();
    let mut rdr = csv::Reader::from_reader(file);
    for row in rdr.decode::&lt;Row&gt;() {
        let row = row.unwrap();
        match row.population {
            None =&gt; { } // skip it
            Some(count) =&gt; if row.city == city {
                found.push(PopulationCount {
                    city: row.city,
                    country: row.country,
                    count: count,
                });
            },
        }
    }
    found
}

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    let program = &amp;args[0];

    let mut opts = Options::new();
    opts.optflag(&quot;h&quot;, &quot;help&quot;, &quot;Show this usage message.&quot;);

    let matches = match opts.parse(&amp;args[1..]) {
        Ok(m)  =&gt; { m }
        Err(e) =&gt; { panic!(e.to_string()) }
    };
    if matches.opt_present(&quot;h&quot;) {
        print_usage(&amp;program, opts);
        return;
    }

    let data_path = &amp;args[1];
    let city = &amp;args[2];
    for pop in search(data_path, city) {
        println!(&quot;{}, {}: {:?}&quot;, pop.city, pop.country, pop.count);
    }
}

</code></pre>
<p>While we got rid of one use of <code>expect</code> (which is a nicer variant of <code>unwrap</code>),
we still should handle the absence of any search results.</p>
<p>To convert this to proper error handling, we need to do the following:</p>
<ol>
<li>Change the return type of <code>search</code> to be <code>Result&lt;Vec&lt;PopulationCount&gt;, Box&lt;Error&gt;&gt;</code>.</li>
<li>Use the <a href="#code-try-def"><code>try!</code> macro</a> so that errors are returned to the
caller instead of panicking the program.</li>
<li>Handle the error in <code>main</code>.</li>
</ol>
<p>Let's try it:</p>
<pre><code class="language-rust,ignore">use std::error::Error;

// The rest of the code before this is unchanged

fn search&lt;P: AsRef&lt;Path&gt;&gt;
         (file_path: P, city: &amp;str)
         -&gt; Result&lt;Vec&lt;PopulationCount&gt;, Box&lt;Error+Send+Sync&gt;&gt; {
    let mut found = vec![];
    let file = try!(File::open(file_path));
    let mut rdr = csv::Reader::from_reader(file);
    for row in rdr.decode::&lt;Row&gt;() {
        let row = try!(row);
        match row.population {
            None =&gt; { } // skip it
            Some(count) =&gt; if row.city == city {
                found.push(PopulationCount {
                    city: row.city,
                    country: row.country,
                    count: count,
                });
            },
        }
    }
    if found.is_empty() {
        Err(From::from(&quot;No matching cities with a population were found.&quot;))
    } else {
        Ok(found)
    }
}
</code></pre>
<p>Instead of <code>x.unwrap()</code>, we now have <code>try!(x)</code>. Since our function returns a
<code>Result&lt;T, E&gt;</code>, the <code>try!</code> macro will return early from the function if an
error occurs.</p>
<p>There is one big gotcha in this code: we used <code>Box&lt;Error + Send + Sync&gt;</code>
instead of <code>Box&lt;Error&gt;</code>. We did this so we could convert a plain string to an
error type. We need these extra bounds so that we can use the
<a href="../std/convert/trait.From.html">corresponding <code>From</code>
impls</a>:</p>
<pre><code class="language-rust,ignore">// We are making use of this impl in the code above, since we call `From::from`
// on a `&amp;'static str`.
impl&lt;'a, 'b&gt; From&lt;&amp;'b str&gt; for Box&lt;Error + Send + Sync + 'a&gt;

// But this is also useful when you need to allocate a new string for an
// error message, usually with `format!`.
impl From&lt;String&gt; for Box&lt;Error + Send + Sync&gt;
</code></pre>
<p>Since <code>search</code> now returns a <code>Result&lt;T, E&gt;</code>, <code>main</code> should use case analysis
when calling <code>search</code>:</p>
<pre><code class="language-rust,ignore">...
match search(&amp;data_file, &amp;city) {
    Ok(pops) =&gt; {
        for pop in pops {
            println!(&quot;{}, {}: {:?}&quot;, pop.city, pop.country, pop.count);
        }
    }
    Err(err) =&gt; println!(&quot;{}&quot;, err)
}
...
</code></pre>
<p>Now that we've seen how to do proper error handling with <code>Box&lt;Error&gt;</code>, let's
try a different approach with our own custom error type. But first, let's take
a quick break from error handling and add support for reading from <code>stdin</code>.</p>
<h2>Reading from stdin</h2>
<p>In our program, we accept a single file for input and do one pass over the
data. This means we probably should be able to accept input on stdin. But maybe
we like the current format too—so let's have both!</p>
<p>Adding support for stdin is actually quite easy. There are only three things we
have to do:</p>
<ol>
<li>Tweak the program arguments so that a single parameter—the
city—can be accepted while the population data is read from stdin.</li>
<li>Modify the program so that an option <code>-f</code> can take the file, if it
is not passed into stdin.</li>
<li>Modify the <code>search</code> function to take an <em>optional</em> file path. When <code>None</code>,
it should know to read from stdin.</li>
</ol>
<p>First, here's the new usage:</p>
<pre><code class="language-rust,ignore">fn print_usage(program: &amp;str, opts: Options) {
    println!(&quot;{}&quot;, opts.usage(&amp;format!(&quot;Usage: {} [options] &lt;city&gt;&quot;, program)));
}
</code></pre>
<p>The next part is going to be only a little harder:</p>
<pre><code class="language-rust,ignore">...
let mut opts = Options::new();
opts.optopt(&quot;f&quot;, &quot;file&quot;, &quot;Choose an input file, instead of using STDIN.&quot;, &quot;NAME&quot;);
opts.optflag(&quot;h&quot;, &quot;help&quot;, &quot;Show this usage message.&quot;);
...
let file = matches.opt_str(&quot;f&quot;);
let data_file = &amp;file.as_ref().map(Path::new);

let city = if !matches.free.is_empty() {
    &amp;matches.free[0]
} else {
    print_usage(&amp;program, opts);
    return;
};

match search(data_file, city) {
    Ok(pops) =&gt; {
        for pop in pops {
            println!(&quot;{}, {}: {:?}&quot;, pop.city, pop.country, pop.count);
        }
    }
    Err(err) =&gt; println!(&quot;{}&quot;, err)
}
...
</code></pre>
<p>In this piece of code, we take <code>file</code> (which has the type
<code>Option&lt;String&gt;</code>), and convert it to a type that <code>search</code> can use, in
this case, <code>&amp;Option&lt;AsRef&lt;Path&gt;&gt;</code>. To do this, we take a reference of
file, and map <code>Path::new</code> onto it. In this case, <code>as_ref()</code> converts
the <code>Option&lt;String&gt;</code> into an <code>Option&lt;&amp;str&gt;</code>, and from there, we can
execute <code>Path::new</code> to the content of the optional, and return the
optional of the new value. Once we have that, it is a simple matter of
getting the <code>city</code> argument and executing <code>search</code>.</p>
<p>Modifying <code>search</code> is slightly trickier. The <code>csv</code> crate can build a
parser out of
[any type that implements <code>io::Read</code>](http://burntsushi.net/rustdoc/csv/struct.Reader.html#method.from_reader).
But how can we use the same code over both types? There's actually a
couple ways we could go about this. One way is to write <code>search</code> such
that it is generic on some type parameter <code>R</code> that satisfies
<code>io::Read</code>. Another way is to use trait objects:</p>
<pre><code class="language-rust,ignore">use std::io;

// The rest of the code before this is unchanged

fn search&lt;P: AsRef&lt;Path&gt;&gt;
         (file_path: &amp;Option&lt;P&gt;, city: &amp;str)
         -&gt; Result&lt;Vec&lt;PopulationCount&gt;, Box&lt;Error+Send+Sync&gt;&gt; {
    let mut found = vec![];
    let input: Box&lt;io::Read&gt; = match *file_path {
        None =&gt; Box::new(io::stdin()),
        Some(ref file_path) =&gt; Box::new(try!(File::open(file_path))),
    };
    let mut rdr = csv::Reader::from_reader(input);
    // The rest remains unchanged!
}
</code></pre>
<h2>Error handling with a custom type</h2>
<p>Previously, we learned how to
<a href="#composing-custom-error-types">compose errors using a custom error type</a>.
We did this by defining our error type as an <code>enum</code> and implementing <code>Error</code>
and <code>From</code>.</p>
<p>Since we have three distinct errors (IO, CSV parsing and not found), let's
define an <code>enum</code> with three variants:</p>
<pre><code class="language-rust,ignore">#[derive(Debug)]
enum CliError {
    Io(io::Error),
    Csv(csv::Error),
    NotFound,
}
</code></pre>
<p>And now for impls on <code>Display</code> and <code>Error</code>:</p>
<pre><code class="language-rust,ignore">impl fmt::Display for CliError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match *self {
            CliError::Io(ref err) =&gt; err.fmt(f),
            CliError::Csv(ref err) =&gt; err.fmt(f),
            CliError::NotFound =&gt; write!(f, &quot;No matching cities with a \
                                             population were found.&quot;),
        }
    }
}

impl Error for CliError {
    fn description(&amp;self) -&gt; &amp;str {
        match *self {
            CliError::Io(ref err) =&gt; err.description(),
            CliError::Csv(ref err) =&gt; err.description(),
            CliError::NotFound =&gt; &quot;not found&quot;,
        }
    }
}
</code></pre>
<p>Before we can use our <code>CliError</code> type in our <code>search</code> function, we need to
provide a couple <code>From</code> impls. How do we know which impls to provide? Well,
we'll need to convert from both <code>io::Error</code> and <code>csv::Error</code> to <code>CliError</code>.
Those are the only external errors, so we'll only need two <code>From</code> impls for
now:</p>
<pre><code class="language-rust,ignore">impl From&lt;io::Error&gt; for CliError {
    fn from(err: io::Error) -&gt; CliError {
        CliError::Io(err)
    }
}

impl From&lt;csv::Error&gt; for CliError {
    fn from(err: csv::Error) -&gt; CliError {
        CliError::Csv(err)
    }
}
</code></pre>
<p>The <code>From</code> impls are important because of how
<a href="#code-try-def"><code>try!</code> is defined</a>. In particular, if an error occurs,
<code>From::from</code> is called on the error, which in this case, will convert it to our
own error type <code>CliError</code>.</p>
<p>With the <code>From</code> impls done, we only need to make two small tweaks to our
<code>search</code> function: the return type and the “not found” error. Here it is in
full:</p>
<pre><code class="language-rust,ignore">fn search&lt;P: AsRef&lt;Path&gt;&gt;
         (file_path: &amp;Option&lt;P&gt;, city: &amp;str)
         -&gt; Result&lt;Vec&lt;PopulationCount&gt;, CliError&gt; {
    let mut found = vec![];
    let input: Box&lt;io::Read&gt; = match *file_path {
        None =&gt; Box::new(io::stdin()),
        Some(ref file_path) =&gt; Box::new(try!(File::open(file_path))),
    };
    let mut rdr = csv::Reader::from_reader(input);
    for row in rdr.decode::&lt;Row&gt;() {
        let row = try!(row);
        match row.population {
            None =&gt; { } // skip it
            Some(count) =&gt; if row.city == city {
                found.push(PopulationCount {
                    city: row.city,
                    country: row.country,
                    count: count,
                });
            },
        }
    }
    if found.is_empty() {
        Err(CliError::NotFound)
    } else {
        Ok(found)
    }
}
</code></pre>
<p>No other changes are necessary.</p>
<h2>Adding functionality</h2>
<p>Writing generic code is great, because generalizing stuff is cool, and
it can then be useful later. But sometimes, the juice isn't worth the
squeeze. Look at what we just did in the previous step:</p>
<ol>
<li>Defined a new error type.</li>
<li>Added impls for <code>Error</code>, <code>Display</code> and two for <code>From</code>.</li>
</ol>
<p>The big downside here is that our program didn't improve a whole lot.
There is quite a bit of overhead to representing errors with <code>enum</code>s,
especially in short programs like this.</p>
<p><em>One</em> useful aspect of using a custom error type like we've done here is that
the <code>main</code> function can now choose to handle errors differently. Previously,
with <code>Box&lt;Error&gt;</code>, it didn't have much of a choice: just print the message.
We're still doing that here, but what if we wanted to, say, add a <code>--quiet</code>
flag? The <code>--quiet</code> flag should silence any verbose output.</p>
<p>Right now, if the program doesn't find a match, it will output a message saying
so. This can be a little clumsy, especially if you intend for the program to
be used in shell scripts.</p>
<p>So let's start by adding the flags. Like before, we need to tweak the usage
string and add a flag to the Option variable. Once we've done that, Getopts does the rest:</p>
<pre><code class="language-rust,ignore">...
let mut opts = Options::new();
opts.optopt(&quot;f&quot;, &quot;file&quot;, &quot;Choose an input file, instead of using STDIN.&quot;, &quot;NAME&quot;);
opts.optflag(&quot;h&quot;, &quot;help&quot;, &quot;Show this usage message.&quot;);
opts.optflag(&quot;q&quot;, &quot;quiet&quot;, &quot;Silences errors and warnings.&quot;);
...
</code></pre>
<p>Now we only need to implement our “quiet” functionality. This requires us to
tweak the case analysis in <code>main</code>:</p>
<pre><code class="language-rust,ignore">match search(&amp;args.arg_data_path, &amp;args.arg_city) {
    Err(CliError::NotFound) if args.flag_quiet =&gt; process::exit(1),
    Err(err) =&gt; panic!(&quot;{}&quot;, err),
    Ok(pops) =&gt; for pop in pops {
        println!(&quot;{}, {}: {:?}&quot;, pop.city, pop.country, pop.count);
    }
}
</code></pre>
<p>Certainly, we don't want to be quiet if there was an IO error or if the data
failed to parse. Therefore, we use case analysis to check if the error type is
<code>NotFound</code> <em>and</em> if <code>--quiet</code> has been enabled. If the search failed, we still
quit with an exit code (following <code>grep</code>'s convention).</p>
<p>If we had stuck with <code>Box&lt;Error&gt;</code>, then it would be pretty tricky to implement
the <code>--quiet</code> functionality.</p>
<p>This pretty much sums up our case study. From here, you should be ready to go
out into the world and write your own programs and libraries with proper error
handling.</p>
<h1>The Short Story</h1>
<p>Since this section is long, it is useful to have a quick summary for error
handling in Rust. These are some good “rules of thumb.&quot; They are emphatically
<em>not</em> commandments. There are probably good reasons to break every one of these
heuristics!</p>
<ul>
<li>If you're writing short example code that would be overburdened by error
handling, it's probably fine to use <code>unwrap</code> (whether that's
[<code>Result::unwrap</code>](../std/result/enum.Result.html#method.unwrap),
[<code>Option::unwrap</code>](../std/option/enum.Option.html#method.unwrap)
or preferably
[<code>Option::expect</code>](../std/option/enum.Option.html#method.expect)).
Consumers of your code should know to use proper error handling. (If they
don't, send them here!)</li>
<li>If you're writing a quick 'n' dirty program, don't feel ashamed if you use
<code>unwrap</code>. Be warned: if it winds up in someone else's hands, don't be
surprised if they are agitated by poor error messages!</li>
<li>If you're writing a quick 'n' dirty program and feel ashamed about panicking
anyway, then use either a <code>String</code> or a <code>Box&lt;Error + Send + Sync&gt;</code> for your
error type (the <code>Box&lt;Error + Send + Sync&gt;</code> type is because of the
<a href="../std/convert/trait.From.html">available <code>From</code> impls</a>).</li>
<li>Otherwise, in a program, define your own error types with appropriate
[<code>From</code>](../std/convert/trait.From.html)
and
[<code>Error</code>](../std/error/trait.Error.html)
impls to make the [<code>try!</code>](../std/macro.try!.html)
macro more ergonomic.</li>
<li>If you're writing a library and your code can produce errors, define your own
error type and implement the
[<code>std::error::Error</code>](../std/error/trait.Error.html)
trait. Where appropriate, implement
[<code>From</code>](../std/convert/trait.From.html) to make both
your library code and the caller's code easier to write. (Because of Rust's
coherence rules, callers will not be able to impl <code>From</code> on your error type,
so your library should do it.)</li>
<li>Learn the combinators defined on
[<code>Option</code>](../std/option/enum.Option.html)
and
[<code>Result</code>](../std/result/enum.Result.html).
Using them exclusively can be a bit tiring at times, but I've personally
found a healthy mix of <code>try!</code> and combinators to be quite appealing.
<code>and_then</code>, <code>map</code> and <code>unwrap_or</code> are my favorites.</li>
</ul>
<blockquote>
<p><em>commit 6571ae2</em></p>
</blockquote>
<p>% Choosing your Guarantees</p>
<p>One important feature of Rust is that it lets us control the costs and guarantees
of a program.</p>
<p>There are various “wrapper type” abstractions in the Rust standard library which embody
a multitude of tradeoffs between cost, ergonomics, and guarantees. Many let one choose between
run time and compile time enforcement. This section will explain a few selected abstractions in
detail.</p>
<p>Before proceeding, it is highly recommended that one reads about <a href="ownership.html">ownership</a> and
<a href="references-and-borrowing.html">borrowing</a> in Rust.</p>
<h1>Basic pointer types</h1>
<h2><code>Box&lt;T&gt;</code></h2>
<p>[<code>Box&lt;T&gt;</code>]<a href="../std/boxed/struct.Box.html">box</a> is an “owned” pointer, or a “box”. While it can hand
out references to the contained data, it is the only owner of the data. In particular, consider
the following:</p>
<pre><code class="language-rust">let x = Box::new(1);
let y = x;
// x no longer accessible here
</code></pre>
<p>Here, the box was <em>moved</em> into <code>y</code>. As <code>x</code> no longer owns it, the compiler will no longer allow the
programmer to use <code>x</code> after this. A box can similarly be moved <em>out</em> of a function by returning it.</p>
<p>When a box (that hasn't been moved) goes out of scope, destructors are run. These destructors take
care of deallocating the inner data.</p>
<p>This is a zero-cost abstraction for dynamic allocation. If you want to allocate some memory on the
heap and safely pass around a pointer to that memory, this is ideal. Note that you will only be
allowed to share references to this by the regular borrowing rules, checked at compile time.</p>
<h2><code>&amp;T</code> and <code>&amp;mut T</code></h2>
<p>These are immutable and mutable references respectively. They follow the “read-write lock”
pattern, such that one may either have only one mutable reference to some data, or any number of
immutable ones, but not both. This guarantee is enforced at compile time, and has no visible cost at
runtime. In most cases these two pointer types suffice for sharing cheap references between sections
of code.</p>
<p>These pointers cannot be copied in such a way that they outlive the lifetime associated with them.</p>
<h2><code>*const T</code> and <code>*mut T</code></h2>
<p>These are C-like raw pointers with no lifetime or ownership attached to them. They point to
some location in memory with no other restrictions. The only guarantee that these provide is that
they cannot be dereferenced except in code marked <code>unsafe</code>.</p>
<p>These are useful when building safe, low cost abstractions like <code>Vec&lt;T&gt;</code>, but should be avoided in
safe code.</p>
<h2><code>Rc&lt;T&gt;</code></h2>
<p>This is the first wrapper we will cover that has a runtime cost.</p>
<p>[<code>Rc&lt;T&gt;</code>]<a href="../std/rc/struct.Rc.html">rc</a> is a reference counted pointer. In other words, this lets us have multiple &quot;owning&quot;
pointers to the same data, and the data will be dropped (destructors will be run) when all pointers
are out of scope.</p>
<p>Internally, it contains a shared “reference count” (also called “refcount”),
which is incremented each time the <code>Rc</code> is cloned, and decremented each time one of the <code>Rc</code>s goes
out of scope. The main responsibility of <code>Rc&lt;T&gt;</code> is to ensure that destructors are called for shared
data.</p>
<p>The internal data here is immutable, and if a cycle of references is created, the data will be
leaked. If we want data that doesn't leak when there are cycles, we need a garbage collector.</p>
<h4>Guarantees</h4>
<p>The main guarantee provided here is that the data will not be destroyed until all references to it
are out of scope.</p>
<p>This should be used when we wish to dynamically allocate and share some data (read-only) between
various portions of your program, where it is not certain which portion will finish using the pointer
last. It's a viable alternative to <code>&amp;T</code> when <code>&amp;T</code> is either impossible to statically check for
correctness, or creates extremely unergonomic code where the programmer does not wish to spend the
development cost of working with.</p>
<p>This pointer is <em>not</em> thread safe, and Rust will not let it be sent or shared with other threads.
This lets one avoid the cost of atomics in situations where they are unnecessary.</p>
<p>There is a sister smart pointer to this one, <code>Weak&lt;T&gt;</code>. This is a non-owning, but also non-borrowed,
smart pointer. It is also similar to <code>&amp;T</code>, but it is not restricted in lifetime—a <code>Weak&lt;T&gt;</code>
can be held on to forever. However, it is possible that an attempt to access the inner data may fail
and return <code>None</code>, since this can outlive the owned <code>Rc</code>s. This is useful for cyclic
data structures and other things.</p>
<h4>Cost</h4>
<p>As far as memory goes, <code>Rc&lt;T&gt;</code> is a single allocation, though it will allocate two extra words (i.e.
two <code>usize</code> values) as compared to a regular <code>Box&lt;T&gt;</code> (for &quot;strong&quot; and &quot;weak&quot; refcounts).</p>
<p><code>Rc&lt;T&gt;</code> has the computational cost of incrementing/decrementing the refcount whenever it is cloned
or goes out of scope respectively. Note that a clone will not do a deep copy, rather it will simply
increment the inner reference count and return a copy of the <code>Rc&lt;T&gt;</code>.</p>
<h1>Cell types</h1>
<p><code>Cell</code>s provide interior mutability. In other words, they contain data which can be manipulated even
if the type cannot be obtained in a mutable form (for example, when it is behind an <code>&amp;</code>-ptr or
<code>Rc&lt;T&gt;</code>).</p>
<p><a href="../std/cell/">The documentation for the <code>cell</code> module has a pretty good explanation for these</a>.</p>
<p>These types are <em>generally</em> found in struct fields, but they may be found elsewhere too.</p>
<h2><code>Cell&lt;T&gt;</code></h2>
<p>[<code>Cell&lt;T&gt;</code>]<a href="../std/cell/struct.Cell.html">cell</a> is a type that provides zero-cost interior mutability, but only for <code>Copy</code> types.
Since the compiler knows that all the data owned by the contained value is on the stack, there's
no worry of leaking any data behind references (or worse!) by simply replacing the data.</p>
<p>It is still possible to violate your own invariants using this wrapper, so be careful when using it.
If a field is wrapped in <code>Cell</code>, it's a nice indicator that the chunk of data is mutable and may not
stay the same between the time you first read it and when you intend to use it.</p>
<pre><code class="language-rust">use std::cell::Cell;

let x = Cell::new(1);
let y = &amp;x;
let z = &amp;x;
x.set(2);
y.set(3);
z.set(4);
println!(&quot;{}&quot;, x.get());
</code></pre>
<p>Note that here we were able to mutate the same value from various immutable references.</p>
<p>This has the same runtime cost as the following:</p>
<pre><code class="language-rust,ignore">let mut x = 1;
let y = &amp;mut x;
let z = &amp;mut x;
x = 2;
*y = 3;
*z = 4;
println!(&quot;{}&quot;, x);
</code></pre>
<p>but it has the added benefit of actually compiling successfully.</p>
<h4>Guarantees</h4>
<p>This relaxes the “no aliasing with mutability” restriction in places where it's
unnecessary. However, this also relaxes the guarantees that the restriction provides; so if your
invariants depend on data stored within <code>Cell</code>, you should be careful.</p>
<p>This is useful for mutating primitives and other <code>Copy</code> types when there is no easy way of
doing it in line with the static rules of <code>&amp;</code> and <code>&amp;mut</code>.</p>
<p><code>Cell</code> does not let you obtain interior references to the data, which makes it safe to freely
mutate.</p>
<h4>Cost</h4>
<p>There is no runtime cost to using <code>Cell&lt;T&gt;</code>, however if you are using it to wrap larger (<code>Copy</code>)
structs, it might be worthwhile to instead wrap individual fields in <code>Cell&lt;T&gt;</code> since each write is
otherwise a full copy of the struct.</p>
<h2><code>RefCell&lt;T&gt;</code></h2>
<p>[<code>RefCell&lt;T&gt;</code>]<a href="../std/cell/struct.RefCell.html">refcell</a> also provides interior mutability, but isn't restricted to <code>Copy</code> types.</p>
<p>Instead, it has a runtime cost. <code>RefCell&lt;T&gt;</code> enforces the read-write lock pattern at runtime (it's
like a single-threaded mutex), unlike <code>&amp;T</code>/<code>&amp;mut T</code> which do so at compile time. This is done by the
<code>borrow()</code> and <code>borrow_mut()</code> functions, which modify an internal reference count and return smart
pointers which can be dereferenced immutably and mutably respectively. The refcount is restored when
the smart pointers go out of scope. With this system, we can dynamically ensure that there are never
any other borrows active when a mutable borrow is active. If the programmer attempts to make such a
borrow, the thread will panic.</p>
<pre><code class="language-rust">use std::cell::RefCell;

let x = RefCell::new(vec![1,2,3,4]);
{
    println!(&quot;{:?}&quot;, *x.borrow())
}

{
    let mut my_ref = x.borrow_mut();
    my_ref.push(1);
}
</code></pre>
<p>Similar to <code>Cell</code>, this is mainly useful for situations where it's hard or impossible to satisfy the
borrow checker. Generally we know that such mutations won't happen in a nested form, but it's good
to check.</p>
<p>For large, complicated programs, it becomes useful to put some things in <code>RefCell</code>s to make things
simpler. For example, a lot of the maps in <a href="../rustc/middle/ty/struct.ctxt.html">the <code>ctxt</code> struct</a> in the Rust compiler internals
are inside this wrapper. These are only modified once (during creation, which is not right after
initialization) or a couple of times in well-separated places. However, since this struct is
pervasively used everywhere, juggling mutable and immutable pointers would be hard (perhaps
impossible) and probably form a soup of <code>&amp;</code>-ptrs which would be hard to extend. On the other hand,
the <code>RefCell</code> provides a cheap (not zero-cost) way of safely accessing these. In the future, if
someone adds some code that attempts to modify the cell when it's already borrowed, it will cause a
(usually deterministic) panic which can be traced back to the offending borrow.</p>
<p>Similarly, in Servo's DOM there is a lot of mutation, most of which is local to a DOM type, but some
of which crisscrosses the DOM and modifies various things. Using <code>RefCell</code> and <code>Cell</code> to guard all
mutation lets us avoid worrying about mutability everywhere, and it simultaneously highlights the
places where mutation is <em>actually</em> happening.</p>
<p>Note that <code>RefCell</code> should be avoided if a mostly simple solution is possible with <code>&amp;</code> pointers.</p>
<h4>Guarantees</h4>
<p><code>RefCell</code> relaxes the <em>static</em> restrictions preventing aliased mutation, and replaces them with
<em>dynamic</em> ones. As such the guarantees have not changed.</p>
<h4>Cost</h4>
<p><code>RefCell</code> does not allocate, but it contains an additional &quot;borrow state&quot;
indicator (one word in size) along with the data.</p>
<p>At runtime each borrow causes a modification/check of the refcount.</p>
<h1>Synchronous types</h1>
<p>Many of the types above cannot be used in a threadsafe manner. Particularly, <code>Rc&lt;T&gt;</code> and
<code>RefCell&lt;T&gt;</code>, which both use non-atomic reference counts (<em>atomic</em> reference counts are those which
can be incremented from multiple threads without causing a data race), cannot be used this way. This
makes them cheaper to use, but we need thread safe versions of these too. They exist, in the form of
<code>Arc&lt;T&gt;</code> and <code>Mutex&lt;T&gt;</code>/<code>RwLock&lt;T&gt;</code></p>
<p>Note that the non-threadsafe types <em>cannot</em> be sent between threads, and this is checked at compile
time.</p>
<p>There are many useful wrappers for concurrent programming in the <a href="../std/sync/index.html">sync</a> module, but only the
major ones will be covered below.</p>
<h2><code>Arc&lt;T&gt;</code></h2>
<p>[<code>Arc&lt;T&gt;</code>]<a href="../std/sync/struct.Arc.html">arc</a> is a version of <code>Rc&lt;T&gt;</code> that uses an atomic reference count (hence, &quot;Arc&quot;).
This can be sent freely between threads.</p>
<p>C++'s <code>shared_ptr</code> is similar to <code>Arc</code>, however in the case of C++ the inner data is always mutable.
For semantics similar to that from C++, we should use <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>, <code>Arc&lt;RwLock&lt;T&gt;&gt;</code>, or
<code>Arc&lt;UnsafeCell&lt;T&gt;&gt;</code><sup class="footnote-reference"><a href="#4">1</a></sup> (<code>UnsafeCell&lt;T&gt;</code> is a cell type that can be used to hold any data and has
no runtime cost, but accessing it requires <code>unsafe</code> blocks). The last one should only be used if we
are certain that the usage won't cause any memory unsafety. Remember that writing to a struct is not
an atomic operation, and many functions like <code>vec.push()</code> can reallocate internally and cause unsafe
behavior, so even monotonicity may not be enough to justify <code>UnsafeCell</code>.</p>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">1</sup>
<p><code>Arc&lt;UnsafeCell&lt;T&gt;&gt;</code> actually won't compile since <code>UnsafeCell&lt;T&gt;</code> isn't <code>Send</code> or <code>Sync</code>, but we can wrap it in a type and implement <code>Send</code>/<code>Sync</code> for it manually to get <code>Arc&lt;Wrapper&lt;T&gt;&gt;</code> where <code>Wrapper</code> is <code>struct Wrapper&lt;T&gt;(UnsafeCell&lt;T&gt;)</code>.</p>
<h4>Guarantees</h4>
<p>Like <code>Rc</code>, this provides the (thread safe) guarantee that the destructor for the internal data will
be run when the last <code>Arc</code> goes out of scope (barring any cycles).</p>
<h4>Cost</h4>
<p>This has the added cost of using atomics for changing the refcount (which will happen whenever it is
cloned or goes out of scope). When sharing data from an <code>Arc</code> in a single thread, it is preferable
to share <code>&amp;</code> pointers whenever possible.</p>
<h2><code>Mutex&lt;T&gt;</code> and <code>RwLock&lt;T&gt;</code></h2>
<p>[<code>Mutex&lt;T&gt;</code>]<a href="../std/sync/struct.Mutex.html">mutex</a> and [<code>RwLock&lt;T&gt;</code>]<a href="../std/sync/struct.RwLock.html">rwlock</a> provide mutual-exclusion via RAII guards (guards are
objects which maintain some state, like a lock, until their destructor is called). For both of
these, the mutex is opaque until we call <code>lock()</code> on it, at which point the thread will block
until a lock can be acquired, and then a guard will be returned. This guard can be used to access
the inner data (mutably), and the lock will be released when the guard goes out of scope.</p>
<pre><code class="language-rust,ignore">{
    let guard = mutex.lock();
    // guard dereferences mutably to the inner type
    *guard += 1;
} // lock released when destructor runs
</code></pre>
</div>
<p><code>RwLock</code> has the added benefit of being efficient for multiple reads. It is always safe to have
multiple readers to shared data as long as there are no writers; and <code>RwLock</code> lets readers acquire a
&quot;read lock&quot;. Such locks can be acquired concurrently and are kept track of via a reference count.
Writers must obtain a &quot;write lock&quot; which can only be obtained when all readers have gone out of
scope.</p>
<h4>Guarantees</h4>
<p>Both of these provide safe shared mutability across threads, however they are prone to deadlocks.
Some level of additional protocol safety can be obtained via the type system.</p>
<h4>Costs</h4>
<p>These use internal atomic-like types to maintain the locks, which are pretty costly (they can block
all memory reads across processors till they're done). Waiting on these locks can also be slow when
there's a lot of concurrent access happening.</p>
<h1>Composition</h1>
<p>A common gripe when reading Rust code is with types like <code>Rc&lt;RefCell&lt;Vec&lt;T&gt;&gt;&gt;</code> (or even more
complicated compositions of such types). It's not always clear what the composition does, or why the
author chose one like this (and when one should be using such a composition in one's own code)</p>
<p>Usually, it's a case of composing together the guarantees that you need, without paying for stuff
that is unnecessary.</p>
<p>For example, <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> is one such composition. <code>Rc&lt;T&gt;</code> itself can't be dereferenced mutably;
because <code>Rc&lt;T&gt;</code> provides sharing and shared mutability can lead to unsafe behavior, so we put
<code>RefCell&lt;T&gt;</code> inside to get dynamically verified shared mutability. Now we have shared mutable data,
but it's shared in a way that there can only be one mutator (and no readers) or multiple readers.</p>
<p>Now, we can take this a step further, and have <code>Rc&lt;RefCell&lt;Vec&lt;T&gt;&gt;&gt;</code> or <code>Rc&lt;Vec&lt;RefCell&lt;T&gt;&gt;&gt;</code>. These
are both shareable, mutable vectors, but they're not the same.</p>
<p>With the former, the <code>RefCell&lt;T&gt;</code> is wrapping the <code>Vec&lt;T&gt;</code>, so the <code>Vec&lt;T&gt;</code> in its entirety is
mutable. At the same time, there can only be one mutable borrow of the whole <code>Vec</code> at a given time.
This means that your code cannot simultaneously work on different elements of the vector from
different <code>Rc</code> handles. However, we are able to push and pop from the <code>Vec&lt;T&gt;</code> at will. This is
similar to a <code>&amp;mut Vec&lt;T&gt;</code> with the borrow checking done at runtime.</p>
<p>With the latter, the borrowing is of individual elements, but the overall vector is immutable. Thus,
we can independently borrow separate elements, but we cannot push or pop from the vector. This is
similar to a <code>&amp;mut [T]</code><sup class="footnote-reference"><a href="#3">2</a></sup>, but, again, the borrow checking is at runtime.</p>
<p>In concurrent programs, we have a similar situation with <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>, which provides shared
mutability and ownership.</p>
<p>When reading code that uses these, go in step by step and look at the guarantees/costs provided.</p>
<p>When choosing a composed type, we must do the reverse; figure out which guarantees we want, and at
which point of the composition we need them. For example, if there is a choice between
<code>Vec&lt;RefCell&lt;T&gt;&gt;</code> and <code>RefCell&lt;Vec&lt;T&gt;&gt;</code>, we should figure out the tradeoffs as done above and pick
one.</p>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">2</sup>
<p><code>&amp;[T]</code> and <code>&amp;mut [T]</code> are <em>slices</em>; they consist of a pointer and a length and can refer to a portion of a vector or array. <code>&amp;mut [T]</code> can have its elements mutated, however its length cannot be touched.</p>
</div>
<blockquote>
<p><em>commit 6ba9520</em></p>
</blockquote>
<p>% Foreign Function Interface</p>
<h1>Introduction</h1>
<p>This guide will use the <a href="https://github.com/google/snappy">snappy</a>
compression/decompression library as an introduction to writing bindings for
foreign code. Rust is currently unable to call directly into a C++ library, but
snappy includes a C interface (documented in
[<code>snappy-c.h</code>](https://github.com/google/snappy/blob/master/snappy-c.h)).</p>
<h2>A note about libc</h2>
<p>Many of these examples use <a href="https://crates.io/crates/libc">the <code>libc</code> crate</a>, which provides various
type definitions for C types, among other things. If you’re trying these
examples yourself, you’ll need to add <code>libc</code> to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
libc = &quot;0.2.0&quot;
</code></pre>
<p>and add <code>extern crate libc;</code> to your crate root.</p>
<h2>Calling foreign functions</h2>
<p>The following is a minimal example of calling a foreign function which will
compile if snappy is installed:</p>
<pre><code class="language-no_run"># #![feature(libc)]
extern crate libc;
use libc::size_t;

#[link(name = &quot;snappy&quot;)]
extern {
    fn snappy_max_compressed_length(source_length: size_t) -&gt; size_t;
}

fn main() {
    let x = unsafe { snappy_max_compressed_length(100) };
    println!(&quot;max compressed length of a 100 byte buffer: {}&quot;, x);
}
</code></pre>
<p>The <code>extern</code> block is a list of function signatures in a foreign library, in
this case with the platform's C ABI. The <code>#[link(...)]</code> attribute is used to
instruct the linker to link against the snappy library so the symbols are
resolved.</p>
<p>Foreign functions are assumed to be unsafe so calls to them need to be wrapped
with <code>unsafe {}</code> as a promise to the compiler that everything contained within
truly is safe. C libraries often expose interfaces that aren't thread-safe, and
almost any function that takes a pointer argument isn't valid for all possible
inputs since the pointer could be dangling, and raw pointers fall outside of
Rust's safe memory model.</p>
<p>When declaring the argument types to a foreign function, the Rust compiler can
not check if the declaration is correct, so specifying it correctly is part of
keeping the binding correct at runtime.</p>
<p>The <code>extern</code> block can be extended to cover the entire snappy API:</p>
<pre><code class="language-no_run"># #![feature(libc)]
extern crate libc;
use libc::{c_int, size_t};

#[link(name = &quot;snappy&quot;)]
extern {
    fn snappy_compress(input: *const u8,
                       input_length: size_t,
                       compressed: *mut u8,
                       compressed_length: *mut size_t) -&gt; c_int;
    fn snappy_uncompress(compressed: *const u8,
                         compressed_length: size_t,
                         uncompressed: *mut u8,
                         uncompressed_length: *mut size_t) -&gt; c_int;
    fn snappy_max_compressed_length(source_length: size_t) -&gt; size_t;
    fn snappy_uncompressed_length(compressed: *const u8,
                                  compressed_length: size_t,
                                  result: *mut size_t) -&gt; c_int;
    fn snappy_validate_compressed_buffer(compressed: *const u8,
                                         compressed_length: size_t) -&gt; c_int;
}
# fn main() {}
</code></pre>
<h1>Creating a safe interface</h1>
<p>The raw C API needs to be wrapped to provide memory safety and make use of higher-level concepts
like vectors. A library can choose to expose only the safe, high-level interface and hide the unsafe
internal details.</p>
<p>Wrapping the functions which expect buffers involves using the <code>slice::raw</code> module to manipulate Rust
vectors as pointers to memory. Rust's vectors are guaranteed to be a contiguous block of memory. The
length is number of elements currently contained, and the capacity is the total size in elements of
the allocated memory. The length is less than or equal to the capacity.</p>
<pre><code class="language-rust"># #![feature(libc)]
# extern crate libc;
# use libc::{c_int, size_t};
# unsafe fn snappy_validate_compressed_buffer(_: *const u8, _: size_t) -&gt; c_int { 0 }
# fn main() {}
pub fn validate_compressed_buffer(src: &amp;[u8]) -&gt; bool {
    unsafe {
        snappy_validate_compressed_buffer(src.as_ptr(), src.len() as size_t) == 0
    }
}
</code></pre>
<p>The <code>validate_compressed_buffer</code> wrapper above makes use of an <code>unsafe</code> block, but it makes the
guarantee that calling it is safe for all inputs by leaving off <code>unsafe</code> from the function
signature.</p>
<p>The <code>snappy_compress</code> and <code>snappy_uncompress</code> functions are more complex, since a buffer has to be
allocated to hold the output too.</p>
<p>The <code>snappy_max_compressed_length</code> function can be used to allocate a vector with the maximum
required capacity to hold the compressed output. The vector can then be passed to the
<code>snappy_compress</code> function as an output parameter. An output parameter is also passed to retrieve
the true length after compression for setting the length.</p>
<pre><code class="language-rust"># #![feature(libc)]
# extern crate libc;
# use libc::{size_t, c_int};
# unsafe fn snappy_compress(a: *const u8, b: size_t, c: *mut u8,
#                           d: *mut size_t) -&gt; c_int { 0 }
# unsafe fn snappy_max_compressed_length(a: size_t) -&gt; size_t { a }
# fn main() {}
pub fn compress(src: &amp;[u8]) -&gt; Vec&lt;u8&gt; {
    unsafe {
        let srclen = src.len() as size_t;
        let psrc = src.as_ptr();

        let mut dstlen = snappy_max_compressed_length(srclen);
        let mut dst = Vec::with_capacity(dstlen as usize);
        let pdst = dst.as_mut_ptr();

        snappy_compress(psrc, srclen, pdst, &amp;mut dstlen);
        dst.set_len(dstlen as usize);
        dst
    }
}
</code></pre>
<p>Decompression is similar, because snappy stores the uncompressed size as part of the compression
format and <code>snappy_uncompressed_length</code> will retrieve the exact buffer size required.</p>
<pre><code class="language-rust"># #![feature(libc)]
# extern crate libc;
# use libc::{size_t, c_int};
# unsafe fn snappy_uncompress(compressed: *const u8,
#                             compressed_length: size_t,
#                             uncompressed: *mut u8,
#                             uncompressed_length: *mut size_t) -&gt; c_int { 0 }
# unsafe fn snappy_uncompressed_length(compressed: *const u8,
#                                      compressed_length: size_t,
#                                      result: *mut size_t) -&gt; c_int { 0 }
# fn main() {}
pub fn uncompress(src: &amp;[u8]) -&gt; Option&lt;Vec&lt;u8&gt;&gt; {
    unsafe {
        let srclen = src.len() as size_t;
        let psrc = src.as_ptr();

        let mut dstlen: size_t = 0;
        snappy_uncompressed_length(psrc, srclen, &amp;mut dstlen);

        let mut dst = Vec::with_capacity(dstlen as usize);
        let pdst = dst.as_mut_ptr();

        if snappy_uncompress(psrc, srclen, pdst, &amp;mut dstlen) == 0 {
            dst.set_len(dstlen as usize);
            Some(dst)
        } else {
            None // SNAPPY_INVALID_INPUT
        }
    }
}
</code></pre>
<p>For reference, the examples used here are also available as a <a href="https://github.com/thestinger/rust-snappy">library on
GitHub</a>.</p>
<h1>Destructors</h1>
<p>Foreign libraries often hand off ownership of resources to the calling code.
When this occurs, we must use Rust's destructors to provide safety and guarantee
the release of these resources (especially in the case of panic).</p>
<p>For more about destructors, see the <a href="../std/ops/trait.Drop.html">Drop trait</a>.</p>
<h1>Callbacks from C code to Rust functions</h1>
<p>Some external libraries require the usage of callbacks to report back their
current state or intermediate data to the caller.
It is possible to pass functions defined in Rust to an external library.
The requirement for this is that the callback function is marked as <code>extern</code>
with the correct calling convention to make it callable from C code.</p>
<p>The callback function can then be sent through a registration call
to the C library and afterwards be invoked from there.</p>
<p>A basic example is:</p>
<p>Rust code:</p>
<pre><code class="language-no_run">extern fn callback(a: i32) {
    println!(&quot;I'm called from C with value {0}&quot;, a);
}

#[link(name = &quot;extlib&quot;)]
extern {
   fn register_callback(cb: extern fn(i32)) -&gt; i32;
   fn trigger_callback();
}

fn main() {
    unsafe {
        register_callback(callback);
        trigger_callback(); // Triggers the callback
    }
}
</code></pre>
<p>C code:</p>
<pre><code class="language-c">typedef void (*rust_callback)(int32_t);
rust_callback cb;

int32_t register_callback(rust_callback callback) {
    cb = callback;
    return 1;
}

void trigger_callback() {
  cb(7); // Will call callback(7) in Rust
}
</code></pre>
<p>In this example Rust's <code>main()</code> will call <code>trigger_callback()</code> in C,
which would, in turn, call back to <code>callback()</code> in Rust.</p>
<h2>Targeting callbacks to Rust objects</h2>
<p>The former example showed how a global function can be called from C code.
However it is often desired that the callback is targeted to a special
Rust object. This could be the object that represents the wrapper for the
respective C object.</p>
<p>This can be achieved by passing an raw pointer to the object down to the
C library. The C library can then include the pointer to the Rust object in
the notification. This will allow the callback to unsafely access the
referenced Rust object.</p>
<p>Rust code:</p>
<pre><code class="language-no_run">#[repr(C)]
struct RustObject {
    a: i32,
    // other members
}

extern &quot;C&quot; fn callback(target: *mut RustObject, a: i32) {
    println!(&quot;I'm called from C with value {0}&quot;, a);
    unsafe {
        // Update the value in RustObject with the value received from the callback
        (*target).a = a;
    }
}

#[link(name = &quot;extlib&quot;)]
extern {
   fn register_callback(target: *mut RustObject,
                        cb: extern fn(*mut RustObject, i32)) -&gt; i32;
   fn trigger_callback();
}

fn main() {
    // Create the object that will be referenced in the callback
    let mut rust_object = Box::new(RustObject { a: 5 });

    unsafe {
        register_callback(&amp;mut *rust_object, callback);
        trigger_callback();
    }
}
</code></pre>
<p>C code:</p>
<pre><code class="language-c">typedef void (*rust_callback)(void*, int32_t);
void* cb_target;
rust_callback cb;

int32_t register_callback(void* callback_target, rust_callback callback) {
    cb_target = callback_target;
    cb = callback;
    return 1;
}

void trigger_callback() {
  cb(cb_target, 7); // Will call callback(&amp;rustObject, 7) in Rust
}
</code></pre>
<h2>Asynchronous callbacks</h2>
<p>In the previously given examples the callbacks are invoked as a direct reaction
to a function call to the external C library.
The control over the current thread is switched from Rust to C to Rust for the
execution of the callback, but in the end the callback is executed on the
same thread that called the function which triggered the callback.</p>
<p>Things get more complicated when the external library spawns its own threads
and invokes callbacks from there.
In these cases access to Rust data structures inside the callbacks is
especially unsafe and proper synchronization mechanisms must be used.
Besides classical synchronization mechanisms like mutexes, one possibility in
Rust is to use channels (in <code>std::sync::mpsc</code>) to forward data from the C
thread that invoked the callback into a Rust thread.</p>
<p>If an asynchronous callback targets a special object in the Rust address space
it is also absolutely necessary that no more callbacks are performed by the
C library after the respective Rust object gets destroyed.
This can be achieved by unregistering the callback in the object's
destructor and designing the library in a way that guarantees that no
callback will be performed after deregistration.</p>
<h1>Linking</h1>
<p>The <code>link</code> attribute on <code>extern</code> blocks provides the basic building block for
instructing rustc how it will link to native libraries. There are two accepted
forms of the link attribute today:</p>
<ul>
<li><code>#[link(name = &quot;foo&quot;)]</code></li>
<li><code>#[link(name = &quot;foo&quot;, kind = &quot;bar&quot;)]</code></li>
</ul>
<p>In both of these cases, <code>foo</code> is the name of the native library that we're
linking to, and in the second case <code>bar</code> is the type of native library that the
compiler is linking to. There are currently three known types of native
libraries:</p>
<ul>
<li>Dynamic - <code>#[link(name = &quot;readline&quot;)]</code></li>
<li>Static - <code>#[link(name = &quot;my_build_dependency&quot;, kind = &quot;static&quot;)]</code></li>
<li>Frameworks - <code>#[link(name = &quot;CoreFoundation&quot;, kind = &quot;framework&quot;)]</code></li>
</ul>
<p>Note that frameworks are only available on OSX targets.</p>
<p>The different <code>kind</code> values are meant to differentiate how the native library
participates in linkage. From a linkage perspective, the Rust compiler creates
two flavors of artifacts: partial (rlib/staticlib) and final (dylib/binary).
Native dynamic library and framework dependencies are propagated to the final
artifact boundary, while static library dependencies are not propagated at
all, because the static libraries are integrated directly into the subsequent
artifact.</p>
<p>A few examples of how this model can be used are:</p>
<ul>
<li>
<p>A native build dependency. Sometimes some C/C++ glue is needed when writing
some Rust code, but distribution of the C/C++ code in a library format is
a burden. In this case, the code will be archived into <code>libfoo.a</code> and then the
Rust crate would declare a dependency via <code>#[link(name = &quot;foo&quot;, kind = &quot;static&quot;)]</code>.</p>
<p>Regardless of the flavor of output for the crate, the native static library
will be included in the output, meaning that distribution of the native static
library is not necessary.</p>
</li>
<li>
<p>A normal dynamic dependency. Common system libraries (like <code>readline</code>) are
available on a large number of systems, and often a static copy of these
libraries cannot be found. When this dependency is included in a Rust crate,
partial targets (like rlibs) will not link to the library, but when the rlib
is included in a final target (like a binary), the native library will be
linked in.</p>
</li>
</ul>
<p>On OSX, frameworks behave with the same semantics as a dynamic library.</p>
<h1>Unsafe blocks</h1>
<p>Some operations, like dereferencing raw pointers or calling functions that have been marked
unsafe are only allowed inside unsafe blocks. Unsafe blocks isolate unsafety and are a promise to
the compiler that the unsafety does not leak out of the block.</p>
<p>Unsafe functions, on the other hand, advertise it to the world. An unsafe function is written like
this:</p>
<pre><code class="language-rust">unsafe fn kaboom(ptr: *const i32) -&gt; i32 { *ptr }
</code></pre>
<p>This function can only be called from an <code>unsafe</code> block or another <code>unsafe</code> function.</p>
<h1>Accessing foreign globals</h1>
<p>Foreign APIs often export a global variable which could do something like track
global state. In order to access these variables, you declare them in <code>extern</code>
blocks with the <code>static</code> keyword:</p>
<pre><code class="language-no_run"># #![feature(libc)]
extern crate libc;

#[link(name = &quot;readline&quot;)]
extern {
    static rl_readline_version: libc::c_int;
}

fn main() {
    println!(&quot;You have readline version {} installed.&quot;,
             rl_readline_version as i32);
}
</code></pre>
<p>Alternatively, you may need to alter global state provided by a foreign
interface. To do this, statics can be declared with <code>mut</code> so we can mutate
them.</p>
<pre><code class="language-no_run"># #![feature(libc)]
extern crate libc;

use std::ffi::CString;
use std::ptr;

#[link(name = &quot;readline&quot;)]
extern {
    static mut rl_prompt: *const libc::c_char;
}

fn main() {
    let prompt = CString::new(&quot;[my-awesome-shell] $&quot;).unwrap();
    unsafe {
        rl_prompt = prompt.as_ptr();

        println!(&quot;{:?}&quot;, rl_prompt);

        rl_prompt = ptr::null();
    }
}
</code></pre>
<p>Note that all interaction with a <code>static mut</code> is unsafe, both reading and
writing. Dealing with global mutable state requires a great deal of care.</p>
<h1>Foreign calling conventions</h1>
<p>Most foreign code exposes a C ABI, and Rust uses the platform's C calling convention by default when
calling foreign functions. Some foreign functions, most notably the Windows API, use other calling
conventions. Rust provides a way to tell the compiler which convention to use:</p>
<pre><code class="language-rust"># #![feature(libc)]
extern crate libc;

#[cfg(all(target_os = &quot;win32&quot;, target_arch = &quot;x86&quot;))]
#[link(name = &quot;kernel32&quot;)]
#[allow(non_snake_case)]
extern &quot;stdcall&quot; {
    fn SetEnvironmentVariableA(n: *const u8, v: *const u8) -&gt; libc::c_int;
}
# fn main() { }
</code></pre>
<p>This applies to the entire <code>extern</code> block. The list of supported ABI constraints
are:</p>
<ul>
<li><code>stdcall</code></li>
<li><code>aapcs</code></li>
<li><code>cdecl</code></li>
<li><code>fastcall</code></li>
<li><code>vectorcall</code>
This is currently hidden behind the <code>abi_vectorcall</code> gate and is subject to change.</li>
<li><code>Rust</code></li>
<li><code>rust-intrinsic</code></li>
<li><code>system</code></li>
<li><code>C</code></li>
<li><code>win64</code></li>
</ul>
<p>Most of the abis in this list are self-explanatory, but the <code>system</code> abi may
seem a little odd. This constraint selects whatever the appropriate ABI is for
interoperating with the target's libraries. For example, on win32 with a x86
architecture, this means that the abi used would be <code>stdcall</code>. On x86_64,
however, windows uses the <code>C</code> calling convention, so <code>C</code> would be used. This
means that in our previous example, we could have used <code>extern &quot;system&quot; { ... }</code>
to define a block for all windows systems, not only x86 ones.</p>
<h1>Interoperability with foreign code</h1>
<p>Rust guarantees that the layout of a <code>struct</code> is compatible with the platform's
representation in C only if the <code>#[repr(C)]</code> attribute is applied to it.
<code>#[repr(C, packed)]</code> can be used to lay out struct members without padding.
<code>#[repr(C)]</code> can also be applied to an enum.</p>
<p>Rust's owned boxes (<code>Box&lt;T&gt;</code>) use non-nullable pointers as handles which point
to the contained object. However, they should not be manually created because
they are managed by internal allocators. References can safely be assumed to be
non-nullable pointers directly to the type.  However, breaking the borrow
checking or mutability rules is not guaranteed to be safe, so prefer using raw
pointers (<code>*</code>) if that's needed because the compiler can't make as many
assumptions about them.</p>
<p>Vectors and strings share the same basic memory layout, and utilities are
available in the <code>vec</code> and <code>str</code> modules for working with C APIs. However,
strings are not terminated with <code>\0</code>. If you need a NUL-terminated string for
interoperability with C, you should use the <code>CString</code> type in the <code>std::ffi</code>
module.</p>
<p>The <a href="https://crates.io/crates/libc"><code>libc</code> crate on crates.io</a> includes type aliases and function
definitions for the C standard library in the <code>libc</code> module, and Rust links
against <code>libc</code> and <code>libm</code> by default.</p>
<h1>The &quot;nullable pointer optimization&quot;</h1>
<p>Certain types are defined to not be <code>null</code>. This includes references (<code>&amp;T</code>,
<code>&amp;mut T</code>), boxes (<code>Box&lt;T&gt;</code>), and function pointers (<code>extern &quot;abi&quot; fn()</code>).
When interfacing with C, pointers that might be null are often used.
As a special case, a generic <code>enum</code> that contains exactly two variants, one of
which contains no data and the other containing a single field, is eligible
for the &quot;nullable pointer optimization&quot;. When such an enum is instantiated
with one of the non-nullable types, it is represented as a single pointer,
and the non-data variant is represented as the null pointer. So
<code>Option&lt;extern &quot;C&quot; fn(c_int) -&gt; c_int&gt;</code> is how one represents a nullable
function pointer using the C ABI.</p>
<h1>Calling Rust code from C</h1>
<p>You may wish to compile Rust code in a way so that it can be called from C. This is
fairly easy, but requires a few things:</p>
<pre><code class="language-rust">#[no_mangle]
pub extern fn hello_rust() -&gt; *const u8 {
    &quot;Hello, world!\0&quot;.as_ptr()
}
# fn main() {}
</code></pre>
<p>The <code>extern</code> makes this function adhere to the C calling convention, as
discussed above in &quot;<a href="ffi.html#foreign-calling-conventions">Foreign Calling
Conventions</a>&quot;. The <code>no_mangle</code>
attribute turns off Rust's name mangling, so that it is easier to link to.</p>
<h1>FFI and panics</h1>
<p>It’s important to be mindful of <code>panic!</code>s when working with FFI. A <code>panic!</code>
across an FFI boundary is undefined behavior. If you’re writing code that may
panic, you should run it in another thread, so that the panic doesn’t bubble up
to C:</p>
<pre><code class="language-rust">use std::thread;

#[no_mangle]
pub extern fn oh_no() -&gt; i32 {
    let h = thread::spawn(|| {
        panic!(&quot;Oops!&quot;);
    });

    match h.join() {
        Ok(_) =&gt; 1,
        Err(_) =&gt; 0,
    }
}
# fn main() {}
</code></pre>
<h1>Representing opaque structs</h1>
<p>Sometimes, a C library wants to provide a pointer to something, but not let you
know the internal details of the thing it wants. The simplest way is to use a
<code>void *</code> argument:</p>
<pre><code class="language-c">void foo(void *arg);
void bar(void *arg);
</code></pre>
<p>We can represent this in Rust with the <code>c_void</code> type:</p>
<pre><code class="language-rust"># #![feature(libc)]
extern crate libc;

extern &quot;C&quot; {
    pub fn foo(arg: *mut libc::c_void);
    pub fn bar(arg: *mut libc::c_void);
}
# fn main() {}
</code></pre>
<p>This is a perfectly valid way of handling the situation. However, we can do a bit
better. To solve this, some C libraries will instead create a <code>struct</code>, where
the details and memory layout of the struct are private. This gives some amount
of type safety. These structures are called ‘opaque’. Here’s an example, in C:</p>
<pre><code class="language-c">struct Foo; /* Foo is a structure, but its contents are not part of the public interface */
struct Bar;
void foo(struct Foo *arg);
void bar(struct Bar *arg);
</code></pre>
<p>To do this in Rust, let’s create our own opaque types with <code>enum</code>:</p>
<pre><code class="language-rust">pub enum Foo {}
pub enum Bar {}

extern &quot;C&quot; {
    pub fn foo(arg: *mut Foo);
    pub fn bar(arg: *mut Bar);
}
# fn main() {}
</code></pre>
<p>By using an <code>enum</code> with no variants, we create an opaque type that we can’t
instantiate, as it has no variants. But because our <code>Foo</code> and <code>Bar</code> types are
different, we’ll get type safety between the two of them, so we cannot
accidentally pass a pointer to <code>Foo</code> to <code>bar()</code>.</p>
<blockquote>
<p><em>commit 077f4ee</em></p>
</blockquote>
<p>% Borrow and AsRef</p>
<p>The [<code>Borrow</code>]<a href="../std/borrow/trait.Borrow.html">borrow</a> and [<code>AsRef</code>]<a href="../std/convert/trait.AsRef.html">asref</a> traits are very similar, but
different. Here’s a quick refresher on what these two traits mean.</p>
<h1>Borrow</h1>
<p>The <code>Borrow</code> trait is used when you’re writing a datastructure, and you want to
use either an owned or borrowed type as synonymous for some purpose.</p>
<p>For example, [<code>HashMap</code>]<a href="../std/collections/struct.HashMap.html">hashmap</a> has a <a href="../std/collections/struct.HashMap.html#method.get"><code>get</code> method</a> which uses <code>Borrow</code>:</p>
<pre><code class="language-rust,ignore">fn get&lt;Q: ?Sized&gt;(&amp;self, k: &amp;Q) -&gt; Option&lt;&amp;V&gt;
    where K: Borrow&lt;Q&gt;,
          Q: Hash + Eq
</code></pre>
<p>This signature is pretty complicated. The <code>K</code> parameter is what we’re interested
in here. It refers to a parameter of the <code>HashMap</code> itself:</p>
<pre><code class="language-rust,ignore">struct HashMap&lt;K, V, S = RandomState&gt; {
</code></pre>
<p>The <code>K</code> parameter is the type of <em>key</em> the <code>HashMap</code> uses. So, looking at
the signature of <code>get()</code> again, we can use <code>get()</code> when the key implements
<code>Borrow&lt;Q&gt;</code>. That way, we can make a <code>HashMap</code> which uses <code>String</code> keys,
but use <code>&amp;str</code>s when we’re searching:</p>
<pre><code class="language-rust">use std::collections::HashMap;

let mut map = HashMap::new();
map.insert(&quot;Foo&quot;.to_string(), 42);

assert_eq!(map.get(&quot;Foo&quot;), Some(&amp;42));
</code></pre>
<p>This is because the standard library has <code>impl Borrow&lt;str&gt; for String</code>.</p>
<p>For most types, when you want to take an owned or borrowed type, a <code>&amp;T</code> is
enough. But one area where <code>Borrow</code> is effective is when there’s more than one
kind of borrowed value. This is especially true of references and slices: you
can have both an <code>&amp;T</code> or a <code>&amp;mut T</code>. If we wanted to accept both of these types,
<code>Borrow</code> is up for it:</p>
<pre><code class="language-rust">use std::borrow::Borrow;
use std::fmt::Display;

fn foo&lt;T: Borrow&lt;i32&gt; + Display&gt;(a: T) {
    println!(&quot;a is borrowed: {}&quot;, a);
}

let mut i = 5;

foo(&amp;i);
foo(&amp;mut i);
</code></pre>
<p>This will print out <code>a is borrowed: 5</code> twice.</p>
<h1>AsRef</h1>
<p>The <code>AsRef</code> trait is a conversion trait. It’s used for converting some value to
a reference in generic code. Like this:</p>
<pre><code class="language-rust">let s = &quot;Hello&quot;.to_string();

fn foo&lt;T: AsRef&lt;str&gt;&gt;(s: T) {
    let slice = s.as_ref();
}
</code></pre>
<h1>Which should I use?</h1>
<p>We can see how they’re kind of the same: they both deal with owned and borrowed
versions of some type. However, they’re a bit different.</p>
<p>Choose <code>Borrow</code> when you want to abstract over different kinds of borrowing, or
when you’re building a datastructure that treats owned and borrowed values in
equivalent ways, such as hashing and comparison.</p>
<p>Choose <code>AsRef</code> when you want to convert something to a reference directly, and
you’re writing generic code.</p>
<blockquote>
<p><em>commit 024aa9a</em></p>
</blockquote>
<p>% Release Channels</p>
<p>The Rust project uses a concept called ‘release channels’ to manage releases.
It’s important to understand this process to choose which version of Rust
your project should use.</p>
<h1>Overview</h1>
<p>There are three channels for Rust releases:</p>
<ul>
<li>Nightly</li>
<li>Beta</li>
<li>Stable</li>
</ul>
<p>New nightly releases are created once a day. Every six weeks, the latest
nightly release is promoted to ‘Beta’. At that point, it will only receive
patches to fix serious errors. Six weeks later, the beta is promoted to
‘Stable’, and becomes the next release of <code>1.x</code>.</p>
<p>This process happens in parallel. So every six weeks, on the same day,
nightly goes to beta, beta goes to stable. When <code>1.x</code> is released, at
the same time, <code>1.(x + 1)-beta</code> is released, and the nightly becomes the
first version of <code>1.(x + 2)-nightly</code>.</p>
<h1>Choosing a version</h1>
<p>Generally speaking, unless you have a specific reason, you should be using the
stable release channel. These releases are intended for a general audience.</p>
<p>However, depending on your interest in Rust, you may choose to use nightly
instead. The basic tradeoff is this: in the nightly channel, you can use
unstable, new Rust features. However, unstable features are subject to change,
and so any new nightly release may break your code. If you use the stable
release, you cannot use experimental features, but the next release of Rust
will not cause significant issues through breaking changes.</p>
<h1>Helping the ecosystem through CI</h1>
<p>What about beta? We encourage all Rust users who use the stable release channel
to also test against the beta channel in their continuous integration systems.
This will help alert the team in case there’s an accidental regression.</p>
<p>Additionally, testing against nightly can catch regressions even sooner, and so
if you don’t mind a third build, we’d appreciate testing against all channels.</p>
<p>As an example, many Rust programmers use <a href="https://travis-ci.org/">Travis</a> to
test their crates, which is free for open source projects. Travis <a href="http://docs.travis-ci.com/user/languages/rust/">supports
Rust directly</a>, and you can use a <code>.travis.yml</code> file like this to
test on all channels:</p>
<pre><code class="language-yaml">language: rust
rust:
  - nightly
  - beta
  - stable

matrix:
  allow_failures:
    - rust: nightly
</code></pre>
<p>With this configuration, Travis will test all three channels, but if something
breaks on nightly, it won’t fail your build. A similar configuration is
recommended for any CI system, check the documentation of the one you’re
using for more details.</p>
<blockquote>
<p><em>commit 024aa9a</em></p>
</blockquote>
<p>% Using Rust Without the Standard Library</p>
<p>Rust’s standard library provides a lot of useful functionality, but assumes
support for various features of its host system: threads, networking, heap
allocation, and others. There are systems that do not have these features,
however, and Rust can work with those too! To do so, we tell Rust that we
don’t want to use the standard library via an attribute: <code>#![no_std]</code>.</p>
<blockquote>
<p>Note: This feature is technically stable, but there are some caveats. For
one, you can build a <code>#![no_std]</code> <em>library</em> on stable, but not a <em>binary</em>.
For details on binaries without the standard library, see [the nightly
chapter on <code>#![no_std]</code>](no-stdlib.html)</p>
</blockquote>
<p>To use <code>#![no_std]</code>, add it to your crate root:</p>
<pre><code class="language-rust">#![no_std]

fn plus_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
<p>Much of the functionality that’s exposed in the standard library is also
available via the <a href="../core/"><code>core</code> crate</a>. When we’re using the standard
library, Rust automatically brings <code>std</code> into scope, allowing you to use
its features without an explicit import. By the same token, when using
<code>!#[no_std]</code>, Rust will bring <code>core</code> into scope for you, as well as <a href="../core/prelude/v1/">its
prelude</a>. This means that a lot of code will Just Work:</p>
<pre><code class="language-rust">#![no_std]

fn may_fail(failure: bool) -&gt; Result&lt;(), &amp;'static str&gt; {
    if failure {
        Err(&quot;this didn’t work!&quot;)
    } else {
        Ok(())
    }
}
</code></pre>
<blockquote>
<p><em>commit 251f419</em></p>
</blockquote>
<p>% Nightly Rust</p>
<p>Rust provides three distribution channels for Rust: nightly, beta, and stable.
Unstable features are only available on nightly Rust. For more details on this
process, see ‘<a href="http://blog.rust-lang.org/2014/10/30/Stability.html">Stability as a deliverable</a>’.</p>
<p>To install nightly Rust, you can use <code>rustup.sh</code>:</p>
<pre><code class="language-bash">$ curl -s https://static.rust-lang.org/rustup.sh | sh -s -- --channel=nightly
</code></pre>
<p>If you're concerned about the <a href="http://curlpipesh.tumblr.com">potential insecurity</a> of using <code>curl | sh</code>, please keep reading and see our disclaimer below. And feel free to
use a two-step version of the installation and examine our installation script:</p>
<pre><code class="language-bash">$ curl -f -L https://static.rust-lang.org/rustup.sh -O
$ sh rustup.sh --channel=nightly
</code></pre>
<p>If you're on Windows, please download either the <a href="https://static.rust-lang.org/dist/rust-nightly-i686-pc-windows-gnu.msi">32-bit installer</a> or
the <a href="https://static.rust-lang.org/dist/rust-nightly-x86_64-pc-windows-gnu.msi">64-bit installer</a> and run it.</p>
<h2>Uninstalling</h2>
<p>If you decide you don't want Rust anymore, we'll be a bit sad, but that's okay.
Not every programming language is great for everyone. Just run the uninstall
script:</p>
<pre><code class="language-bash">$ sudo /usr/local/lib/rustlib/uninstall.sh
</code></pre>
<p>If you used the Windows installer, re-run the <code>.msi</code> and it will give you
an uninstall option.</p>
<p>Some people, and somewhat rightfully so, get very upset when we tell you to
<code>curl | sh</code>. Basically, when you do this, you are trusting that the good
people who maintain Rust aren't going to hack your computer and do bad things.
That's a good instinct! If you're one of those people, please check out the
documentation on <a href="https://github.com/rust-lang/rust#building-from-source">building Rust from Source</a>, or <a href="https://www.rust-lang.org/install.html">the official
binary downloads</a>.</p>
<p>Oh, we should also mention the officially supported platforms:</p>
<ul>
<li>Windows (7, 8, Server 2008 R2)</li>
<li>Linux (2.6.18 or later, various distributions), x86 and x86-64</li>
<li>OSX 10.7 (Lion) or greater, x86 and x86-64</li>
</ul>
<p>We extensively test Rust on these platforms, and a few others, too, like
Android. But these are the ones most likely to work, as they have the most
testing.</p>
<p>Finally, a comment about Windows. Rust considers Windows to be a first-class
platform upon release, but if we're honest, the Windows experience isn't as
integrated as the Linux/OS X experience is. We're working on it! If anything
does not work, it is a bug. Please let us know if that happens. Each and every
commit is tested against Windows like any other platform.</p>
<p>If you've got Rust installed, you can open up a shell, and type this:</p>
<pre><code class="language-bash">$ rustc --version
</code></pre>
<p>You should see the version number, commit hash, commit date and build date:</p>
<pre><code class="language-bash">rustc 1.0.0-nightly (f11f3e7ba 2015-01-04) (built 2015-01-06)
</code></pre>
<p>If you did, Rust has been installed successfully! Congrats!</p>
<p>This installer also installs a copy of the documentation locally, so you can
read it offline. On UNIX systems, <code>/usr/local/share/doc/rust</code> is the location.
On Windows, it's in a <code>share/doc</code> directory, inside wherever you installed Rust
to.</p>
<p>If not, there are a number of places where you can get help. The easiest is
<a href="irc://irc.mozilla.org/#rust">the #rust IRC channel on irc.mozilla.org</a>, which you can access through
<a href="http://chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23rust">Mibbit</a>. Click that link, and you'll be chatting with other Rustaceans
(a silly nickname we call ourselves), and we can help you out. Other great
resources include <a href="https://users.rust-lang.org/">the user’s forum</a>, and <a href="http://stackoverflow.com/questions/tagged/rust">Stack Overflow</a>.</p>
<blockquote>
<p><em>commit 6ba9520</em></p>
</blockquote>
<p>% Compiler Plugins</p>
<h1>Introduction</h1>
<p><code>rustc</code> can load compiler plugins, which are user-provided libraries that
extend the compiler's behavior with new syntax extensions, lint checks, etc.</p>
<p>A plugin is a dynamic library crate with a designated <em>registrar</em> function that
registers extensions with <code>rustc</code>. Other crates can load these extensions using
the crate attribute <code>#![plugin(...)]</code>.  See the
[<code>rustc_plugin</code>](../rustc_plugin/index.html) documentation for more about the
mechanics of defining and loading a plugin.</p>
<p>If present, arguments passed as <code>#![plugin(foo(... args ...))]</code> are not
interpreted by rustc itself.  They are provided to the plugin through the
<code>Registry</code>'s <a href="../rustc_plugin/registry/struct.Registry.html#method.args"><code>args</code> method</a>.</p>
<p>In the vast majority of cases, a plugin should <em>only</em> be used through
<code>#![plugin]</code> and not through an <code>extern crate</code> item.  Linking a plugin would
pull in all of libsyntax and librustc as dependencies of your crate.  This is
generally unwanted unless you are building another plugin.  The
<code>plugin_as_library</code> lint checks these guidelines.</p>
<p>The usual practice is to put compiler plugins in their own crate, separate from
any <code>macro_rules!</code> macros or ordinary Rust code meant to be used by consumers
of a library.</p>
<h1>Syntax extensions</h1>
<p>Plugins can extend Rust's syntax in various ways. One kind of syntax extension
is the procedural macro. These are invoked the same way as <a href="macros.html">ordinary
macros</a>, but the expansion is performed by arbitrary Rust
code that manipulates <a href="../syntax/ast/index.html">syntax trees</a> at
compile time.</p>
<p>Let's write a plugin
[<code>roman_numerals.rs</code>](https://github.com/rust-lang/rust/tree/master/src/test/auxiliary/roman_numerals.rs)
that implements Roman numeral integer literals.</p>
<pre><code class="language-ignore">#![crate_type=&quot;dylib&quot;]
#![feature(plugin_registrar, rustc_private)]

extern crate syntax;
extern crate rustc;
extern crate rustc_plugin;

use syntax::codemap::Span;
use syntax::parse::token;
use syntax::ast::TokenTree;
use syntax::ext::base::{ExtCtxt, MacResult, DummyResult, MacEager};
use syntax::ext::build::AstBuilder;  // trait for expr_usize
use rustc_plugin::Registry;

fn expand_rn(cx: &amp;mut ExtCtxt, sp: Span, args: &amp;[TokenTree])
        -&gt; Box&lt;MacResult + 'static&gt; {

    static NUMERALS: &amp;'static [(&amp;'static str, usize)] = &amp;[
        (&quot;M&quot;, 1000), (&quot;CM&quot;, 900), (&quot;D&quot;, 500), (&quot;CD&quot;, 400),
        (&quot;C&quot;,  100), (&quot;XC&quot;,  90), (&quot;L&quot;,  50), (&quot;XL&quot;,  40),
        (&quot;X&quot;,   10), (&quot;IX&quot;,   9), (&quot;V&quot;,   5), (&quot;IV&quot;,   4),
        (&quot;I&quot;,    1)];

    if args.len() != 1 {
        cx.span_err(
            sp,
            &amp;format!(&quot;argument should be a single identifier, but got {} arguments&quot;, args.len()));
        return DummyResult::any(sp);
    }

    let text = match args[0] {
        TokenTree::Token(_, token::Ident(s, _)) =&gt; s.to_string(),
        _ =&gt; {
            cx.span_err(sp, &quot;argument should be a single identifier&quot;);
            return DummyResult::any(sp);
        }
    };

    let mut text = &amp;*text;
    let mut total = 0;
    while !text.is_empty() {
        match NUMERALS.iter().find(|&amp;&amp;(rn, _)| text.starts_with(rn)) {
            Some(&amp;(rn, val)) =&gt; {
                total += val;
                text = &amp;text[rn.len()..];
            }
            None =&gt; {
                cx.span_err(sp, &quot;invalid Roman numeral&quot;);
                return DummyResult::any(sp);
            }
        }
    }

    MacEager::expr(cx.expr_usize(sp, total))
}

#[plugin_registrar]
pub fn plugin_registrar(reg: &amp;mut Registry) {
    reg.register_macro(&quot;rn&quot;, expand_rn);
}
</code></pre>
<p>Then we can use <code>rn!()</code> like any other macro:</p>
<pre><code class="language-ignore">#![feature(plugin)]
#![plugin(roman_numerals)]

fn main() {
    assert_eq!(rn!(MMXV), 2015);
}
</code></pre>
<p>The advantages over a simple <code>fn(&amp;str) -&gt; u32</code> are:</p>
<ul>
<li>The (arbitrarily complex) conversion is done at compile time.</li>
<li>Input validation is also performed at compile time.</li>
<li>It can be extended to allow use in patterns, which effectively gives
a way to define new literal syntax for any data type.</li>
</ul>
<p>In addition to procedural macros, you can define new
[<code>derive</code>](../reference.html#derive)-like attributes and other kinds of
extensions.  See
[<code>Registry::register_syntax_extension</code>](../rustc_plugin/registry/struct.Registry.html#method.register_syntax_extension)
and the <a href="https://doc.rust-lang.org/syntax/ext/base/enum.SyntaxExtension.html"><code>SyntaxExtension</code>
enum</a>.  For
a more involved macro example, see
[<code>regex_macros</code>](https://github.com/rust-lang/regex/blob/master/regex_macros/src/lib.rs).</p>
<h2>Tips and tricks</h2>
<p>Some of the <a href="macros.html#debugging-macro-code">macro debugging tips</a> are applicable.</p>
<p>You can use [<code>syntax::parse</code>](../syntax/parse/index.html) to turn token trees into
higher-level syntax elements like expressions:</p>
<pre><code class="language-ignore">fn expand_foo(cx: &amp;mut ExtCtxt, sp: Span, args: &amp;[TokenTree])
        -&gt; Box&lt;MacResult+'static&gt; {

    let mut parser = cx.new_parser_from_tts(args);

    let expr: P&lt;Expr&gt; = parser.parse_expr();
</code></pre>
<p>Looking through <a href="https://github.com/rust-lang/rust/blob/master/src/libsyntax/parse/parser.rs"><code>libsyntax</code> parser
code</a>
will give you a feel for how the parsing infrastructure works.</p>
<p>Keep the <a href="../syntax/codemap/struct.Span.html"><code>Span</code>s</a> of
everything you parse, for better error reporting. You can wrap
[<code>Spanned</code>](../syntax/codemap/struct.Spanned.html) around
your custom data structures.</p>
<p>Calling
[<code>ExtCtxt::span_fatal</code>](../syntax/ext/base/struct.ExtCtxt.html#method.span_fatal)
will immediately abort compilation. It's better to instead call
[<code>ExtCtxt::span_err</code>](../syntax/ext/base/struct.ExtCtxt.html#method.span_err)
and return
[<code>DummyResult</code>](../syntax/ext/base/struct.DummyResult.html),
so that the compiler can continue and find further errors.</p>
<p>To print syntax fragments for debugging, you can use
[<code>span_note</code>](../syntax/ext/base/struct.ExtCtxt.html#method.span_note) together
with
[<code>syntax::print::pprust::*_to_string</code>](https://doc.rust-lang.org/syntax/print/pprust/index.html#functions).</p>
<p>The example above produced an integer literal using
[<code>AstBuilder::expr_usize</code>](../syntax/ext/build/trait.AstBuilder.html#tymethod.expr_usize).
As an alternative to the <code>AstBuilder</code> trait, <code>libsyntax</code> provides a set of
<a href="../syntax/ext/quote/index.html">quasiquote macros</a>.  They are undocumented and
very rough around the edges.  However, the implementation may be a good
starting point for an improved quasiquote as an ordinary plugin library.</p>
<h1>Lint plugins</h1>
<p>Plugins can extend <a href="../reference.html#lint-check-attributes">Rust's lint
infrastructure</a> with additional checks for
code style, safety, etc. Now let's write a plugin [<code>lint_plugin_test.rs</code>](https://github.com/rust-lang/rust/blob/master/src/test/auxiliary/lint_plugin_test.rs)
that warns about any item named <code>lintme</code>.</p>
<pre><code class="language-ignore">#![feature(plugin_registrar)]
#![feature(box_syntax, rustc_private)]

extern crate syntax;

// Load rustc as a plugin to get macros
#[macro_use]
extern crate rustc;
extern crate rustc_plugin;

use rustc::lint::{EarlyContext, LintContext, LintPass, EarlyLintPass,
                  EarlyLintPassObject, LintArray};
use rustc_plugin::Registry;
use syntax::ast;

declare_lint!(TEST_LINT, Warn, &quot;Warn about items named 'lintme'&quot;);

struct Pass;

impl LintPass for Pass {
    fn get_lints(&amp;self) -&gt; LintArray {
        lint_array!(TEST_LINT)
    }
}

impl EarlyLintPass for Pass {
    fn check_item(&amp;mut self, cx: &amp;EarlyContext, it: &amp;ast::Item) {
        if it.ident.name.as_str() == &quot;lintme&quot; {
            cx.span_lint(TEST_LINT, it.span, &quot;item is named 'lintme'&quot;);
        }
    }
}

#[plugin_registrar]
pub fn plugin_registrar(reg: &amp;mut Registry) {
    reg.register_early_lint_pass(box Pass as EarlyLintPassObject);
}
</code></pre>
<p>Then code like</p>
<pre><code class="language-ignore">#![plugin(lint_plugin_test)]

fn lintme() { }
</code></pre>
<p>will produce a compiler warning:</p>
<pre><code class="language-txt">foo.rs:4:1: 4:16 warning: item is named 'lintme', #[warn(test_lint)] on by default
foo.rs:4 fn lintme() { }
         ^~~~~~~~~~~~~~~
</code></pre>
<p>The components of a lint plugin are:</p>
<ul>
<li>
<p>one or more <code>declare_lint!</code> invocations, which define static
[<code>Lint</code>](../rustc/lint/struct.Lint.html) structs;</p>
</li>
<li>
<p>a struct holding any state needed by the lint pass (here, none);</p>
</li>
<li>
<p>a [<code>LintPass</code>](../rustc/lint/trait.LintPass.html)
implementation defining how to check each syntax element. A single
<code>LintPass</code> may call <code>span_lint</code> for several different <code>Lint</code>s, but should
register them all through the <code>get_lints</code> method.</p>
</li>
</ul>
<p>Lint passes are syntax traversals, but they run at a late stage of compilation
where type information is available. <code>rustc</code>'s <a href="https://github.com/rust-lang/rust/blob/master/src/librustc/lint/builtin.rs">built-in
lints</a>
mostly use the same infrastructure as lint plugins, and provide examples of how
to access type information.</p>
<p>Lints defined by plugins are controlled by the usual <a href="../reference.html#lint-check-attributes">attributes and compiler
flags</a>, e.g. <code>#[allow(test_lint)]</code> or
<code>-A test-lint</code>. These identifiers are derived from the first argument to
<code>declare_lint!</code>, with appropriate case and punctuation conversion.</p>
<p>You can run <code>rustc -W help foo.rs</code> to see a list of lints known to <code>rustc</code>,
including those provided by plugins loaded by <code>foo.rs</code>.</p>
<blockquote>
<p><em>commit 1430a35</em></p>
</blockquote>
<p>% Inline Assembly</p>
<p>For extremely low-level manipulations and performance reasons, one
might wish to control the CPU directly. Rust supports using inline
assembly to do this via the <code>asm!</code> macro. The syntax roughly matches
that of GCC &amp; Clang:</p>
<pre><code class="language-ignore">asm!(assembly template
   : output operands
   : input operands
   : clobbers
   : options
   );
</code></pre>
<p>Any use of <code>asm</code> is feature gated (requires <code>#![feature(asm)]</code> on the
crate to allow) and of course requires an <code>unsafe</code> block.</p>
<blockquote>
<p><strong>Note</strong>: the examples here are given in x86/x86-64 assembly, but
all platforms are supported.</p>
</blockquote>
<h2>Assembly template</h2>
<p>The <code>assembly template</code> is the only required parameter and must be a
literal string (i.e. <code>&quot;&quot;</code>)</p>
<pre><code class="language-rust">#![feature(asm)]

#[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
fn foo() {
    unsafe {
        asm!(&quot;NOP&quot;);
    }
}

// other platforms
#[cfg(not(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;)))]
fn foo() { /* ... */ }

fn main() {
    // ...
    foo();
    // ...
}
</code></pre>
<p>(The <code>feature(asm)</code> and <code>#[cfg]</code>s are omitted from now on.)</p>
<p>Output operands, input operands, clobbers and options are all optional
but you must add the right number of <code>:</code> if you skip them:</p>
<pre><code class="language-rust"># #![feature(asm)]
# #[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
# fn main() { unsafe {
asm!(&quot;xor %eax, %eax&quot;
    :
    :
    : &quot;{eax}&quot;
   );
# } }
</code></pre>
<p>Whitespace also doesn't matter:</p>
<pre><code class="language-rust"># #![feature(asm)]
# #[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
# fn main() { unsafe {
asm!(&quot;xor %eax, %eax&quot; ::: &quot;{eax}&quot;);
# } }
</code></pre>
<h2>Operands</h2>
<p>Input and output operands follow the same format: <code>: &quot;constraints1&quot;(expr1), &quot;constraints2&quot;(expr2), ...&quot;</code>. Output operand
expressions must be mutable lvalues, or not yet assigned:</p>
<pre><code class="language-rust"># #![feature(asm)]
# #[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
fn add(a: i32, b: i32) -&gt; i32 {
    let c: i32;
    unsafe {
        asm!(&quot;add $2, $0&quot;
             : &quot;=r&quot;(c)
             : &quot;0&quot;(a), &quot;r&quot;(b)
             );
    }
    c
}
# #[cfg(not(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;)))]
# fn add(a: i32, b: i32) -&gt; i32 { a + b }

fn main() {
    assert_eq!(add(3, 14159), 14162)
}
</code></pre>
<p>If you would like to use real operands in this position, however,
you are required to put curly braces <code>{}</code> around the register that
you want, and you are required to put the specific size of the
operand. This is useful for very low level programming, where
which register you use is important:</p>
<pre><code class="language-rust"># #![feature(asm)]
# #[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
# unsafe fn read_byte_in(port: u16) -&gt; u8 {
let result: u8;
asm!(&quot;in %dx, %al&quot; : &quot;={al}&quot;(result) : &quot;{dx}&quot;(port));
result
# }
</code></pre>
<h2>Clobbers</h2>
<p>Some instructions modify registers which might otherwise have held
different values so we use the clobbers list to indicate to the
compiler not to assume any values loaded into those registers will
stay valid.</p>
<pre><code class="language-rust"># #![feature(asm)]
# #[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
# fn main() { unsafe {
// Put the value 0x200 in eax
asm!(&quot;mov $$0x200, %eax&quot; : /* no outputs */ : /* no inputs */ : &quot;{eax}&quot;);
# } }
</code></pre>
<p>Input and output registers need not be listed since that information
is already communicated by the given constraints. Otherwise, any other
registers used either implicitly or explicitly should be listed.</p>
<p>If the assembly changes the condition code register <code>cc</code> should be
specified as one of the clobbers. Similarly, if the assembly modifies
memory, <code>memory</code> should also be specified.</p>
<h2>Options</h2>
<p>The last section, <code>options</code> is specific to Rust. The format is comma
separated literal strings (i.e. <code>:&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;</code>). It's used to
specify some extra info about the inline assembly:</p>
<p>Current valid options are:</p>
<ol>
<li><em>volatile</em> - specifying this is analogous to
<code>__asm__ __volatile__ (...)</code> in gcc/clang.</li>
<li><em>alignstack</em> - certain instructions expect the stack to be
aligned a certain way (i.e. SSE) and specifying this indicates to
the compiler to insert its usual stack alignment code</li>
<li><em>intel</em> - use intel syntax instead of the default AT&amp;T.</li>
</ol>
<pre><code class="language-rust"># #![feature(asm)]
# #[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
# fn main() {
let result: i32;
unsafe {
   asm!(&quot;mov eax, 2&quot; : &quot;={eax}&quot;(result) : : : &quot;intel&quot;)
}
println!(&quot;eax is currently {}&quot;, result);
# }
</code></pre>
<h2>More Information</h2>
<p>The current implementation of the <code>asm!</code> macro is a direct binding to <a href="http://llvm.org/docs/LangRef.html#inline-assembler-expressions">LLVM's
inline assembler expressions</a>, so be sure to check out <a href="http://llvm.org/docs/LangRef.html#inline-assembler-expressions">their
documentation as well</a> for more information about clobbers,
constraints, etc.</p>
<blockquote>
<p><em>commit 024aa9a</em></p>
</blockquote>
<p>% No stdlib</p>
<p>Rust’s standard library provides a lot of useful functionality, but assumes
support for various features of its host system: threads, networking, heap
allocation, and others. There are systems that do not have these features,
however, and Rust can work with those too! To do so, we tell Rust that we
don’t want to use the standard library via an attribute: <code>#![no_std]</code>.</p>
<blockquote>
<p>Note: This feature is technically stable, but there are some caveats. For
one, you can build a <code>#![no_std]</code> <em>library</em> on stable, but not a <em>binary</em>.
For details on libraries without the standard library, see [the chapter on
<code>#![no_std]</code>](using-rust-without-the-standard-library.html)</p>
</blockquote>
<p>Obviously there's more to life than just libraries: one can use
<code>#[no_std]</code> with an executable, controlling the entry point is
possible in two ways: the <code>#[start]</code> attribute, or overriding the
default shim for the C <code>main</code> function with your own.</p>
<p>The function marked <code>#[start]</code> is passed the command line parameters
in the same format as C:</p>
<pre><code class="language-rust"># #![feature(libc)]
#![feature(lang_items)]
#![feature(start)]
#![no_std]

// Pull in the system libc library for what crt0.o likely requires
extern crate libc;

// Entry point for this program
#[start]
fn start(_argc: isize, _argv: *const *const u8) -&gt; isize {
    0
}

// These functions and traits are used by the compiler, but not
// for a bare-bones hello world. These are normally
// provided by libstd.
#[lang = &quot;eh_personality&quot;] extern fn eh_personality() {}
#[lang = &quot;panic_fmt&quot;] fn panic_fmt() -&gt; ! { loop {} }
# #[lang = &quot;eh_unwind_resume&quot;] extern fn rust_eh_unwind_resume() {}
# #[no_mangle] pub extern fn rust_eh_register_frames () {}
# #[no_mangle] pub extern fn rust_eh_unregister_frames () {}
# // fn main() {} tricked you, rustdoc!
</code></pre>
<p>To override the compiler-inserted <code>main</code> shim, one has to disable it
with <code>#![no_main]</code> and then create the appropriate symbol with the
correct ABI and the correct name, which requires overriding the
compiler's name mangling too:</p>
<pre><code class="language-rust"># #![feature(libc)]
#![feature(lang_items)]
#![feature(start)]
#![no_std]
#![no_main]

extern crate libc;

#[no_mangle] // ensure that this symbol is called `main` in the output
pub extern fn main(argc: i32, argv: *const *const u8) -&gt; i32 {
    0
}

#[lang = &quot;eh_personality&quot;] extern fn eh_personality() {}
#[lang = &quot;panic_fmt&quot;] fn panic_fmt() -&gt; ! { loop {} }
# #[lang = &quot;eh_unwind_resume&quot;] extern fn rust_eh_unwind_resume() {}
# #[no_mangle] pub extern fn rust_eh_register_frames () {}
# #[no_mangle] pub extern fn rust_eh_unregister_frames () {}
# // fn main() {} tricked you, rustdoc!
</code></pre>
<p>The compiler currently makes a few assumptions about symbols which are available
in the executable to call. Normally these functions are provided by the standard
library, but without it you must define your own.</p>
<p>The first of these two functions, <code>eh_personality</code>, is used by the failure
mechanisms of the compiler. This is often mapped to GCC's personality function
(see the <a href="https://github.com/rust-lang/rust/blob/master/src/libstd/sys/common/unwind/gcc.rs">libstd implementation</a> for more information), but crates
which do not trigger a panic can be assured that this function is never
called. The second function, <code>panic_fmt</code>, is also used by the failure
mechanisms of the compiler.</p>
<blockquote>
<p><em>commit c94b14a</em></p>
</blockquote>
<p>% Intrinsics</p>
<blockquote>
<p><strong>Note</strong>: intrinsics will forever have an unstable interface, it is
recommended to use the stable interfaces of libcore rather than intrinsics
directly.</p>
</blockquote>
<p>These are imported as if they were FFI functions, with the special
<code>rust-intrinsic</code> ABI. For example, if one was in a freestanding
context, but wished to be able to <code>transmute</code> between types, and
perform efficient pointer arithmetic, one would import those functions
via a declaration like</p>
<pre><code class="language-rust">#![feature(intrinsics)]
# fn main() {}

extern &quot;rust-intrinsic&quot; {
    fn transmute&lt;T, U&gt;(x: T) -&gt; U;

    fn offset&lt;T&gt;(dst: *const T, offset: isize) -&gt; *const T;
}
</code></pre>
<p>As with any other FFI functions, these are always <code>unsafe</code> to call.</p>
<blockquote>
<p><em>commit 024aa9a</em></p>
</blockquote>
<p>% Lang items</p>
<blockquote>
<p><strong>Note</strong>: lang items are often provided by crates in the Rust distribution,
and lang items themselves have an unstable interface. It is recommended to use
officially distributed crates instead of defining your own lang items.</p>
</blockquote>
<p>The <code>rustc</code> compiler has certain pluggable operations, that is,
functionality that isn't hard-coded into the language, but is
implemented in libraries, with a special marker to tell the compiler
it exists. The marker is the attribute <code>#[lang = &quot;...&quot;]</code> and there are
various different values of <code>...</code>, i.e. various different 'lang
items'.</p>
<p>For example, <code>Box</code> pointers require two lang items, one for allocation
and one for deallocation. A freestanding program that uses the <code>Box</code>
sugar for dynamic allocations via <code>malloc</code> and <code>free</code>:</p>
<pre><code class="language-rust">#![feature(lang_items, box_syntax, start, libc)]
#![no_std]

extern crate libc;

extern {
    fn abort() -&gt; !;
}

#[lang = &quot;owned_box&quot;]
pub struct Box&lt;T&gt;(*mut T);

#[lang = &quot;exchange_malloc&quot;]
unsafe fn allocate(size: usize, _align: usize) -&gt; *mut u8 {
    let p = libc::malloc(size as libc::size_t) as *mut u8;

    // malloc failed
    if p as usize == 0 {
        abort();
    }

    p
}

#[lang = &quot;exchange_free&quot;]
unsafe fn deallocate(ptr: *mut u8, _size: usize, _align: usize) {
    libc::free(ptr as *mut libc::c_void)
}

#[lang = &quot;box_free&quot;]
unsafe fn box_free&lt;T&gt;(ptr: *mut T) {
    deallocate(ptr as *mut u8, ::core::mem::size_of::&lt;T&gt;(), ::core::mem::align_of::&lt;T&gt;());
}

#[start]
fn main(argc: isize, argv: *const *const u8) -&gt; isize {
    let x = box 1;

    0
}

#[lang = &quot;eh_personality&quot;] extern fn eh_personality() {}
#[lang = &quot;panic_fmt&quot;] fn panic_fmt() -&gt; ! { loop {} }
# #[lang = &quot;eh_unwind_resume&quot;] extern fn rust_eh_unwind_resume() {}
# #[no_mangle] pub extern fn rust_eh_register_frames () {}
# #[no_mangle] pub extern fn rust_eh_unregister_frames () {}
</code></pre>
<p>Note the use of <code>abort</code>: the <code>exchange_malloc</code> lang item is assumed to
return a valid pointer, and so needs to do the check internally.</p>
<p>Other features provided by lang items include:</p>
<ul>
<li>overloadable operators via traits: the traits corresponding to the
<code>==</code>, <code>&lt;</code>, dereferencing (<code>*</code>) and <code>+</code> (etc.) operators are all
marked with lang items; those specific four are <code>eq</code>, <code>ord</code>,
<code>deref</code>, and <code>add</code> respectively.</li>
<li>stack unwinding and general failure; the <code>eh_personality</code>, <code>fail</code>
and <code>fail_bounds_checks</code> lang items.</li>
<li>the traits in <code>std::marker</code> used to indicate types of
various kinds; lang items <code>send</code>, <code>sync</code> and <code>copy</code>.</li>
<li>the marker types and variance indicators found in
<code>std::marker</code>; lang items <code>covariant_type</code>,
<code>contravariant_lifetime</code>, etc.</li>
</ul>
<p>Lang items are loaded lazily by the compiler; e.g. if one never uses
<code>Box</code> then there is no need to define functions for <code>exchange_malloc</code>
and <code>exchange_free</code>. <code>rustc</code> will emit an error when an item is needed
but not found in the current crate or any that it depends on.</p>
<blockquote>
<p><em>commit 432460a</em></p>
</blockquote>
<p>% Advanced Linking</p>
<p>The common cases of linking with Rust have been covered earlier in this book,
but supporting the range of linking possibilities made available by other
languages is important for Rust to achieve seamless interaction with native
libraries.</p>
<h1>Link args</h1>
<p>There is one other way to tell <code>rustc</code> how to customize linking, and that is via
the <code>link_args</code> attribute. This attribute is applied to <code>extern</code> blocks and
specifies raw flags which need to get passed to the linker when producing an
artifact. An example usage would be:</p>
<pre><code class="language-no_run">#![feature(link_args)]

#[link_args = &quot;-foo -bar -baz&quot;]
extern {}
# fn main() {}
</code></pre>
<p>Note that this feature is currently hidden behind the <code>feature(link_args)</code> gate
because this is not a sanctioned way of performing linking. Right now <code>rustc</code>
shells out to the system linker (<code>gcc</code> on most systems, <code>link.exe</code> on MSVC),
so it makes sense to provide extra command line
arguments, but this will not always be the case. In the future <code>rustc</code> may use
LLVM directly to link native libraries, in which case <code>link_args</code> will have no
meaning. You can achieve the same effect as the <code>link_args</code> attribute with the
<code>-C link-args</code> argument to <code>rustc</code>.</p>
<p>It is highly recommended to <em>not</em> use this attribute, and rather use the more
formal <code>#[link(...)]</code> attribute on <code>extern</code> blocks instead.</p>
<h1>Static linking</h1>
<p>Static linking refers to the process of creating output that contains all
required libraries and so doesn't need libraries installed on every system where
you want to use your compiled project. Pure-Rust dependencies are statically
linked by default so you can use created binaries and libraries without
installing Rust everywhere. By contrast, native libraries
(e.g. <code>libc</code> and <code>libm</code>) are usually dynamically linked, but it is possible to
change this and statically link them as well.</p>
<p>Linking is a very platform-dependent topic, and static linking may not even be
possible on some platforms! This section assumes some basic familiarity with
linking on your platform of choice.</p>
<h2>Linux</h2>
<p>By default, all Rust programs on Linux will link to the system <code>libc</code> along with
a number of other libraries. Let's look at an example on a 64-bit Linux machine
with GCC and <code>glibc</code> (by far the most common <code>libc</code> on Linux):</p>
<pre><code class="language-text">$ cat example.rs
fn main() {}
$ rustc example.rs
$ ldd example
        linux-vdso.so.1 =&gt;  (0x00007ffd565fd000)
        libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007fa81889c000)
        libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007fa81867e000)
        librt.so.1 =&gt; /lib/x86_64-linux-gnu/librt.so.1 (0x00007fa818475000)
        libgcc_s.so.1 =&gt; /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007fa81825f000)
        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fa817e9a000)
        /lib64/ld-linux-x86-64.so.2 (0x00007fa818cf9000)
        libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007fa817b93000)
</code></pre>
<p>Dynamic linking on Linux can be undesirable if you wish to use new library
features on old systems or target systems which do not have the required
dependencies for your program to run.</p>
<p>Static linking is supported via an alternative <code>libc</code>, [<code>musl</code>](http://www.musl-libc.org). You can compile
your own version of Rust with <code>musl</code> enabled and install it into a custom
directory with the instructions below:</p>
<pre><code class="language-text">$ mkdir musldist
$ PREFIX=$(pwd)/musldist
$
$ # Build musl
$ curl -O http://www.musl-libc.org/releases/musl-1.1.10.tar.gz
$ tar xf musl-1.1.10.tar.gz
$ cd musl-1.1.10/
musl-1.1.10 $ ./configure --disable-shared --prefix=$PREFIX
musl-1.1.10 $ make
musl-1.1.10 $ make install
musl-1.1.10 $ cd ..
$ du -h musldist/lib/libc.a
2.2M    musldist/lib/libc.a
$
$ # Build libunwind.a
$ curl -O http://llvm.org/releases/3.7.0/llvm-3.7.0.src.tar.xz
$ tar xf llvm-3.7.0.src.tar.xz
$ cd llvm-3.7.0.src/projects/
llvm-3.7.0.src/projects $ curl http://llvm.org/releases/3.7.0/libunwind-3.7.0.src.tar.xz | tar xJf -
llvm-3.7.0.src/projects $ mv libunwind-3.7.0.src libunwind
llvm-3.7.0.src/projects $ mkdir libunwind/build
llvm-3.7.0.src/projects $ cd libunwind/build
llvm-3.7.0.src/projects/libunwind/build $ cmake -DLLVM_PATH=../../.. -DLIBUNWIND_ENABLE_SHARED=0 ..
llvm-3.7.0.src/projects/libunwind/build $ make
llvm-3.7.0.src/projects/libunwind/build $ cp lib/libunwind.a $PREFIX/lib/
llvm-3.7.0.src/projects/libunwind/build $ cd ../../../../
$ du -h musldist/lib/libunwind.a
164K    musldist/lib/libunwind.a
$
$ # Build musl-enabled rust
$ git clone https://github.com/rust-lang/rust.git muslrust
$ cd muslrust
muslrust $ ./configure --target=x86_64-unknown-linux-musl --musl-root=$PREFIX --prefix=$PREFIX
muslrust $ make
muslrust $ make install
muslrust $ cd ..
$ du -h musldist/bin/rustc
12K     musldist/bin/rustc
</code></pre>
<p>You now have a build of a <code>musl</code>-enabled Rust! Because we've installed it to a
custom prefix we need to make sure our system can find the binaries and appropriate
libraries when we try and run it:</p>
<pre><code class="language-text">$ export PATH=$PREFIX/bin:$PATH
$ export LD_LIBRARY_PATH=$PREFIX/lib:$LD_LIBRARY_PATH
</code></pre>
<p>Let's try it out!</p>
<pre><code class="language-text">$ echo 'fn main() { println!(&quot;hi!&quot;); panic!(&quot;failed&quot;); }' &gt; example.rs
$ rustc --target=x86_64-unknown-linux-musl example.rs
$ ldd example
        not a dynamic executable
$ ./example
hi!
thread '&lt;main&gt;' panicked at 'failed', example.rs:1
</code></pre>
<p>Success! This binary can be copied to almost any Linux machine with the same
machine architecture and run without issues.</p>
<p><code>cargo build</code> also permits the <code>--target</code> option so you should be able to build
your crates as normal. However, you may need to recompile your native libraries
against <code>musl</code> before they can be linked against.</p>
<blockquote>
<p><em>commit 024aa9a</em></p>
</blockquote>
<p>% Benchmark tests</p>
<p>Rust supports benchmark tests, which can test the performance of your
code. Let's make our <code>src/lib.rs</code> look like this (comments elided):</p>
<pre><code class="language-rust,ignore">#![feature(test)]

extern crate test;

pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;
    use test::Bencher;

    #[test]
    fn it_works() {
        assert_eq!(4, add_two(2));
    }

    #[bench]
    fn bench_add_two(b: &amp;mut Bencher) {
        b.iter(|| add_two(2));
    }
}
</code></pre>
<p>Note the <code>test</code> feature gate, which enables this unstable feature.</p>
<p>We've imported the <code>test</code> crate, which contains our benchmarking support.
We have a new function as well, with the <code>bench</code> attribute. Unlike regular
tests, which take no arguments, benchmark tests take a <code>&amp;mut Bencher</code>. This
<code>Bencher</code> provides an <code>iter</code> method, which takes a closure. This closure
contains the code we'd like to benchmark.</p>
<p>We can run benchmark tests with <code>cargo bench</code>:</p>
<pre><code class="language-bash">$ cargo bench
   Compiling adder v0.0.1 (file:///home/steve/tmp/adder)
     Running target/release/adder-91b3e234d4ed382a

running 2 tests
test tests::it_works ... ignored
test tests::bench_add_two ... bench:         1 ns/iter (+/- 0)

test result: ok. 0 passed; 0 failed; 1 ignored; 1 measured
</code></pre>
<p>Our non-benchmark test was ignored. You may have noticed that <code>cargo bench</code>
takes a bit longer than <code>cargo test</code>. This is because Rust runs our benchmark
a number of times, and then takes the average. Because we're doing so little
work in this example, we have a <code>1 ns/iter (+/- 0)</code>, but this would show
the variance if there was one.</p>
<p>Advice on writing benchmarks:</p>
<ul>
<li>Move setup code outside the <code>iter</code> loop; only put the part you want to measure inside</li>
<li>Make the code do &quot;the same thing&quot; on each iteration; do not accumulate or change state</li>
<li>Make the outer function idempotent too; the benchmark runner is likely to run
it many times</li>
<li>Make the inner <code>iter</code> loop short and fast so benchmark runs are fast and the
calibrator can adjust the run-length at fine resolution</li>
<li>Make the code in the <code>iter</code> loop do something simple, to assist in pinpointing
performance improvements (or regressions)</li>
</ul>
<h2>Gotcha: optimizations</h2>
<p>There's another tricky part to writing benchmarks: benchmarks compiled with
optimizations activated can be dramatically changed by the optimizer so that
the benchmark is no longer benchmarking what one expects. For example, the
compiler might recognize that some calculation has no external effects and
remove it entirely.</p>
<pre><code class="language-rust,ignore">#![feature(test)]

extern crate test;
use test::Bencher;

#[bench]
fn bench_xor_1000_ints(b: &amp;mut Bencher) {
    b.iter(|| {
        (0..1000).fold(0, |old, new| old ^ new);
    });
}
</code></pre>
<p>gives the following results</p>
<pre><code class="language-text">running 1 test
test bench_xor_1000_ints ... bench:         0 ns/iter (+/- 0)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured
</code></pre>
<p>The benchmarking runner offers two ways to avoid this. Either, the closure that
the <code>iter</code> method receives can return an arbitrary value which forces the
optimizer to consider the result used and ensures it cannot remove the
computation entirely. This could be done for the example above by adjusting the
<code>b.iter</code> call to</p>
<pre><code class="language-rust"># struct X;
# impl X { fn iter&lt;T, F&gt;(&amp;self, _: F) where F: FnMut() -&gt; T {} } let b = X;
b.iter(|| {
    // note lack of `;` (could also use an explicit `return`).
    (0..1000).fold(0, |old, new| old ^ new)
});
</code></pre>
<p>Or, the other option is to call the generic <code>test::black_box</code> function, which
is an opaque &quot;black box&quot; to the optimizer and so forces it to consider any
argument as used.</p>
<pre><code class="language-rust">#![feature(test)]

extern crate test;

# fn main() {
# struct X;
# impl X { fn iter&lt;T, F&gt;(&amp;self, _: F) where F: FnMut() -&gt; T {} } let b = X;
b.iter(|| {
    let n = test::black_box(1000);

    (0..n).fold(0, |a, b| a ^ b)
})
# }
</code></pre>
<p>Neither of these read or modify the value, and are very cheap for small values.
Larger values can be passed indirectly to reduce overhead (e.g.
<code>black_box(&amp;huge_struct)</code>).</p>
<p>Performing either of the above changes gives the following benchmarking results</p>
<pre><code class="language-text">running 1 test
test bench_xor_1000_ints ... bench:       131 ns/iter (+/- 3)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured
</code></pre>
<p>However, the optimizer can still modify a testcase in an undesirable manner
even when using either of the above.</p>
<blockquote>
<p><em>commit 024aa9a</em></p>
</blockquote>
<p>%  Box Syntax and Patterns</p>
<p>Currently the only stable way to create a <code>Box</code> is via the <code>Box::new</code> method.
Also it is not possible in stable Rust to destructure a <code>Box</code> in a match
pattern. The unstable <code>box</code> keyword can be used to both create and destructure
a <code>Box</code>. An example usage would be:</p>
<pre><code class="language-rust">#![feature(box_syntax, box_patterns)]

fn main() {
    let b = Some(box 5);
    match b {
        Some(box n) if n &lt; 0 =&gt; {
            println!(&quot;Box contains negative number {}&quot;, n);
        },
        Some(box n) if n &gt;= 0 =&gt; {
            println!(&quot;Box contains non-negative number {}&quot;, n);
        },
        None =&gt; {
            println!(&quot;No box&quot;);
        },
        _ =&gt; unreachable!()
    }
}
</code></pre>
<p>Note that these features are currently hidden behind the <code>box_syntax</code> (box
creation) and <code>box_patterns</code> (destructuring and pattern matching) gates
because the syntax may still change in the future.</p>
<h1>Returning Pointers</h1>
<p>In many languages with pointers, you'd return a pointer from a function
so as to avoid copying a large data structure. For example:</p>
<pre><code class="language-rust">struct BigStruct {
    one: i32,
    two: i32,
    // etc
    one_hundred: i32,
}

fn foo(x: Box&lt;BigStruct&gt;) -&gt; Box&lt;BigStruct&gt; {
    Box::new(*x)
}

fn main() {
    let x = Box::new(BigStruct {
        one: 1,
        two: 2,
        one_hundred: 100,
    });

    let y = foo(x);
}
</code></pre>
<p>The idea is that by passing around a box, you're only copying a pointer, rather
than the hundred <code>i32</code>s that make up the <code>BigStruct</code>.</p>
<p>This is an antipattern in Rust. Instead, write this:</p>
<pre><code class="language-rust">#![feature(box_syntax)]

struct BigStruct {
    one: i32,
    two: i32,
    // etc
    one_hundred: i32,
}

fn foo(x: Box&lt;BigStruct&gt;) -&gt; BigStruct {
    *x
}

fn main() {
    let x = Box::new(BigStruct {
        one: 1,
        two: 2,
        one_hundred: 100,
    });

    let y: Box&lt;BigStruct&gt; = box foo(x);
}
</code></pre>
<p>This gives you flexibility without sacrificing performance.</p>
<p>You may think that this gives us terrible performance: return a value and then
immediately box it up ?! Isn't this pattern the worst of both worlds? Rust is
smarter than that. There is no copy in this code. <code>main</code> allocates enough room
for the <code>box</code>, passes a pointer to that memory into <code>foo</code> as <code>x</code>, and then
<code>foo</code> writes the value straight into the <code>Box&lt;T&gt;</code>.</p>
<p>This is important enough that it bears repeating: pointers are not for
optimizing returning values from your code. Allow the caller to choose how they
want to use your output.</p>
<blockquote>
<p><em>commit 024aa9a</em></p>
</blockquote>
<p>% Slice patterns</p>
<p>If you want to match against a slice or array, you can use <code>&amp;</code> with the
<code>slice_patterns</code> feature:</p>
<pre><code class="language-rust">#![feature(slice_patterns)]

fn main() {
    let v = vec![&quot;match_this&quot;, &quot;1&quot;];

    match &amp;v[..] {
        [&quot;match_this&quot;, second] =&gt; println!(&quot;The second element is {}&quot;, second),
        _ =&gt; {},
    }
}
</code></pre>
<p>The <code>advanced_slice_patterns</code> gate lets you use <code>..</code> to indicate any number of
elements inside a pattern matching a slice. This wildcard can only be used once
for a given array. If there's an identifier before the <code>..</code>, the result of the
slice will be bound to that name. For example:</p>
<pre><code class="language-rust">#![feature(advanced_slice_patterns, slice_patterns)]

fn is_symmetric(list: &amp;[u32]) -&gt; bool {
    match list {
        [] | [_] =&gt; true,
        [x, inside.., y] if x == y =&gt; is_symmetric(inside),
        _ =&gt; false
    }
}

fn main() {
    let sym = &amp;[0, 1, 4, 2, 4, 1, 0];
    assert!(is_symmetric(sym));

    let not_sym = &amp;[0, 1, 7, 2, 4, 1, 0];
    assert!(!is_symmetric(not_sym));
}
</code></pre>
<blockquote>
<p><em>commit 024aa9a</em></p>
</blockquote>
<p>% Associated Constants</p>
<p>With the <code>associated_consts</code> feature, you can define constants like this:</p>
<pre><code class="language-rust">#![feature(associated_consts)]

trait Foo {
    const ID: i32;
}

impl Foo for i32 {
    const ID: i32 = 1;
}

fn main() {
    assert_eq!(1, i32::ID);
}
</code></pre>
<p>Any implementor of <code>Foo</code> will have to define <code>ID</code>. Without the definition:</p>
<pre><code class="language-rust,ignore">#![feature(associated_consts)]

trait Foo {
    const ID: i32;
}

impl Foo for i32 {
}
</code></pre>
<p>gives</p>
<pre><code class="language-text">error: not all trait items implemented, missing: `ID` [E0046]
     impl Foo for i32 {
     }
</code></pre>
<p>A default value can be implemented as well:</p>
<pre><code class="language-rust">#![feature(associated_consts)]

trait Foo {
    const ID: i32 = 1;
}

impl Foo for i32 {
}

impl Foo for i64 {
    const ID: i32 = 5;
}

fn main() {
    assert_eq!(1, i32::ID);
    assert_eq!(5, i64::ID);
}
</code></pre>
<p>As you can see, when implementing <code>Foo</code>, you can leave it unimplemented, as
with <code>i32</code>. It will then use the default value. But, as in <code>i64</code>, we can also
add our own definition.</p>
<p>Associated constants don’t have to be associated with a trait. An <code>impl</code> block
for a <code>struct</code> or an <code>enum</code> works fine too:</p>
<pre><code class="language-rust">#![feature(associated_consts)]

struct Foo;

impl Foo {
    const FOO: u32 = 3;
}
</code></pre>
<blockquote>
<p><em>commit 024aa9a</em></p>
</blockquote>
<p>% Custom Allocators</p>
<p>Allocating memory isn't always the easiest thing to do, and while Rust generally
takes care of this by default it often becomes necessary to customize how
allocation occurs. The compiler and standard library currently allow switching
out the default global allocator in use at compile time. The design is currently
spelled out in <a href="https://github.com/rust-lang/rfcs/blob/master/text/1183-swap-out-jemalloc.md">RFC 1183</a> but this will walk you through how to get your
own allocator up and running.</p>
<h1>Default Allocator</h1>
<p>The compiler currently ships two default allocators: <code>alloc_system</code> and
<code>alloc_jemalloc</code> (some targets don't have jemalloc, however). These allocators
are normal Rust crates and contain an implementation of the routines to
allocate and deallocate memory. The standard library is not compiled assuming
either one, and the compiler will decide which allocator is in use at
compile-time depending on the type of output artifact being produced.</p>
<p>Binaries generated by the compiler will use <code>alloc_jemalloc</code> by default (where
available). In this situation the compiler &quot;controls the world&quot; in the sense of
it has power over the final link. Primarily this means that the allocator
decision can be left up the compiler.</p>
<p>Dynamic and static libraries, however, will use <code>alloc_system</code> by default. Here
Rust is typically a 'guest' in another application or another world where it
cannot authoritatively decide what allocator is in use. As a result it resorts
back to the standard APIs (e.g. <code>malloc</code> and <code>free</code>) for acquiring and releasing
memory.</p>
<h1>Switching Allocators</h1>
<p>Although the compiler's default choices may work most of the time, it's often
necessary to tweak certain aspects. Overriding the compiler's decision about
which allocator is in use is done simply by linking to the desired allocator:</p>
<pre><code class="language-rust,no_run">#![feature(alloc_system)]

extern crate alloc_system;

fn main() {
    let a = Box::new(4); // allocates from the system allocator
    println!(&quot;{}&quot;, a);
}
</code></pre>
<p>In this example the binary generated will not link to jemalloc by default but
instead use the system allocator. Conversely to generate a dynamic library which
uses jemalloc by default one would write:</p>
<pre><code class="language-rust,ignore">#![feature(alloc_jemalloc)]
#![crate_type = &quot;dylib&quot;]

extern crate alloc_jemalloc;

pub fn foo() {
    let a = Box::new(4); // allocates from jemalloc
    println!(&quot;{}&quot;, a);
}
# fn main() {}
</code></pre>
<h1>Writing a custom allocator</h1>
<p>Sometimes even the choices of jemalloc vs the system allocator aren't enough and
an entirely new custom allocator is required. In this you'll write your own
crate which implements the allocator API (e.g. the same as <code>alloc_system</code> or
<code>alloc_jemalloc</code>). As an example, let's take a look at a simplified and
annotated version of <code>alloc_system</code></p>
<pre><code class="language-rust,no_run"># // only needed for rustdoc --test down below
# #![feature(lang_items)]
// The compiler needs to be instructed that this crate is an allocator in order
// to realize that when this is linked in another allocator like jemalloc should
// not be linked in
#![feature(allocator)]
#![allocator]

// Allocators are not allowed to depend on the standard library which in turn
// requires an allocator in order to avoid circular dependencies. This crate,
// however, can use all of libcore.
#![no_std]

// Let's give a unique name to our custom allocator
#![crate_name = &quot;my_allocator&quot;]
#![crate_type = &quot;rlib&quot;]

// Our system allocator will use the in-tree libc crate for FFI bindings. Note
// that currently the external (crates.io) libc cannot be used because it links
// to the standard library (e.g. `#![no_std]` isn't stable yet), so that's why
// this specifically requires the in-tree version.
#![feature(libc)]
extern crate libc;

// Listed below are the five allocation functions currently required by custom
// allocators. Their signatures and symbol names are not currently typechecked
// by the compiler, but this is a future extension and are required to match
// what is found below.
//
// Note that the standard `malloc` and `realloc` functions do not provide a way
// to communicate alignment so this implementation would need to be improved
// with respect to alignment in that aspect.

#[no_mangle]
pub extern fn __rust_allocate(size: usize, _align: usize) -&gt; *mut u8 {
    unsafe { libc::malloc(size as libc::size_t) as *mut u8 }
}

#[no_mangle]
pub extern fn __rust_deallocate(ptr: *mut u8, _old_size: usize, _align: usize) {
    unsafe { libc::free(ptr as *mut libc::c_void) }
}

#[no_mangle]
pub extern fn __rust_reallocate(ptr: *mut u8, _old_size: usize, size: usize,
                                _align: usize) -&gt; *mut u8 {
    unsafe {
        libc::realloc(ptr as *mut libc::c_void, size as libc::size_t) as *mut u8
    }
}

#[no_mangle]
pub extern fn __rust_reallocate_inplace(_ptr: *mut u8, old_size: usize,
                                        _size: usize, _align: usize) -&gt; usize {
    old_size // this api is not supported by libc
}

#[no_mangle]
pub extern fn __rust_usable_size(size: usize, _align: usize) -&gt; usize {
    size
}

# // only needed to get rustdoc to test this
# fn main() {}
# #[lang = &quot;panic_fmt&quot;] fn panic_fmt() {}
# #[lang = &quot;eh_personality&quot;] fn eh_personality() {}
# #[lang = &quot;eh_unwind_resume&quot;] extern fn eh_unwind_resume() {}
# #[no_mangle] pub extern fn rust_eh_register_frames () {}
# #[no_mangle] pub extern fn rust_eh_unregister_frames () {}
</code></pre>
<p>After we compile this crate, it can be used as follows:</p>
<pre><code class="language-rust,ignore">extern crate my_allocator;

fn main() {
    let a = Box::new(8); // allocates memory via our custom allocator crate
    println!(&quot;{}&quot;, a);
}
</code></pre>
<h1>Custom allocator limitations</h1>
<p>There are a few restrictions when working with custom allocators which may cause
compiler errors:</p>
<ul>
<li>
<p>Any one artifact may only be linked to at most one allocator. Binaries,
dylibs, and staticlibs must link to exactly one allocator, and if none have
been explicitly chosen the compiler will choose one. On the other hand rlibs
do not need to link to an allocator (but still can).</p>
</li>
<li>
<p>A consumer of an allocator is tagged with <code>#![needs_allocator]</code> (e.g. the
<code>liballoc</code> crate currently) and an <code>#[allocator]</code> crate cannot transitively
depend on a crate which needs an allocator (e.g. circular dependencies are not
allowed). This basically means that allocators must restrict themselves to
libcore currently.</p>
</li>
</ul>
<blockquote>
<p><em>commit 6ba9520</em></p>
</blockquote>
<h1>詞彙表</h1>
<p>並非每位 Rustacean 都有系統程式設計或電腦科學的背景，所以我們加上了一些可能不易理解的名詞解釋。</p>
<h2>抽象語法樹 (Abstract Syntax Tree)</h2>
<p>當編譯器編譯程式時，它會做很多不同的事。
其中之一就是轉換你的程式文字內容變成 &quot;抽象語法樹&quot;，或稱為 &quot;AST&quot;。
這個樹展現了你的程式結構。
例如， <code>2 + 3</code> 會轉換成這樣的樹：</p>
<pre><code class="language-text">  +
 / \
2   3
</code></pre>
<p>而 <code>2 + (3 * 4)</code> 則看起來像這樣：</p>
<pre><code class="language-text">  +
 / \
2   *
   / \
  3   4
</code></pre>
<h2>元數 (Arity)</h2>
<p>元數是指函式或操作所需要的參數數量。</p>
<pre><code class="language-rust">let x = (2, 3);
let y = (4, 6);
let z = (8, 2, 6);
</code></pre>
<p>在範例中，<code>x</code> 和 <code>y</code> 的元數是 2。
<code>z</code> 的元數是 3。</p>
<h2>界線 (Bounds)</h2>
<p>界線是型別或 <a href="traits.html">trait</a> 的限制。
例如，如果界線在函式的參數，那麼傳遞給函式的參數型別必須遵守這樣的限制。</p>
<h2>動態大小型別 (DST - Dynamically Sized Type)</h2>
<p>靜態大小或 alignment 未知的型別。（<a href="https://doc.rust-lang.org/nomicon/exotic-sizes.html#dynamically-sized-types-dsts">更多資訊</a>）</p>
<h2>表達式 (Expression)</h2>
<p>程式語言中，表達式是一組數值、常數、變數、運算子、及函式的組合，可以估出一個數值。
例如 <code>2 + (3 * 4)</code> 是一個回傳數值 14 的表達式。
值得注意的是，表達式可以有副作用。
例如，一個包含表達式的函式可能會執行一些動作，而不只是單純的回傳值。</p>
<h2>表達式導向語言 (Expression-Oriented Language)</h2>
<p>早期的程式語言中，<a href="glossary.html#expression">表達式</a> and <a href="glossary.html#statement">陳述式</a> 是兩種不同的語法類型：表達式有數值，而陳述式做事。
然而，之後的語言模糊了界線，允許表達是做事，而陳述式有數值。
在表達式導向語言中，（幾乎）所以陳述式都是表達式，且回傳值。
因此，這些表達陳述式自身可以組成更大的表達式。</p>
<h2>陳述式 (Statement)</h2>
<p>在程式語言中，陳述式是程式語言中最小的獨立元素，用來命令電腦執行動作。</p>
<blockquote>
<p>譯註：關於表達式及陳述式，可參考維基百科的 <a href="https://en.wikipedia.org/wiki/Expression_(computer_science)">Expression</a> 及 <a href="https://en.wikipedia.org/wiki/Statement_(computer_science)">Statement</a> 條目。</p>
</blockquote>
<blockquote>
<p><em>commit 024aa9a</em></p>
</blockquote>
<p>% Syntax Index</p>
<h2>Keywords</h2>
<ul>
<li><code>as</code>: primitive casting, or disambiguating the specific trait containing an item.  See [Casting Between Types (<code>as</code>)], [Universal Function Call Syntax (Angle-bracket Form)], [Associated Types].</li>
<li><code>break</code>: break out of loop.  See [Loops (Ending Iteration Early)].</li>
<li><code>const</code>: constant items and constant raw pointers.  See [<code>const</code> and <code>static</code>], [Raw Pointers].</li>
<li><code>continue</code>: continue to next loop iteration.  See [Loops (Ending Iteration Early)].</li>
<li><code>crate</code>: external crate linkage.  See [Crates and Modules (Importing External Crates)].</li>
<li><code>else</code>: fallback for <code>if</code> and <code>if let</code> constructs.  See [<code>if</code>], [<code>if let</code>].</li>
<li><code>enum</code>: defining enumeration.  See [Enums].</li>
<li><code>extern</code>: external crate, function, and variable linkage.  See [Crates and Modules (Importing External Crates)], [Foreign Function Interface].</li>
<li><code>false</code>: boolean false literal.  See [Primitive Types (Booleans)].</li>
<li><code>fn</code>: function definition and function pointer types.  See [Functions].</li>
<li><code>for</code>: iterator loop, part of trait <code>impl</code> syntax, and higher-ranked lifetime syntax.  See [Loops (<code>for</code>)], [Method Syntax].</li>
<li><code>if</code>: conditional branching.  See [<code>if</code>], [<code>if let</code>].</li>
<li><code>impl</code>: inherent and trait implementation blocks.  See [Method Syntax].</li>
<li><code>in</code>: part of <code>for</code> loop syntax.  See [Loops (<code>for</code>)].</li>
<li><code>let</code>: variable binding.  See [Variable Bindings].</li>
<li><code>loop</code>: unconditional, infinite loop.  See [Loops (<code>loop</code>)].</li>
<li><code>match</code>: pattern matching.  See [Match].</li>
<li><code>mod</code>: module declaration.  See [Crates and Modules (Defining Modules)].</li>
<li><code>move</code>: part of closure syntax.  See [Closures (<code>move</code> closures)].</li>
<li><code>mut</code>: denotes mutability in pointer types and pattern bindings.  See [Mutability].</li>
<li><code>pub</code>: denotes public visibility in <code>struct</code> fields, <code>impl</code> blocks, and modules.  See [Crates and Modules (Exporting a Public Interface)].</li>
<li><code>ref</code>: by-reference binding.  See [Patterns (<code>ref</code> and <code>ref mut</code>)].</li>
<li><code>return</code>: return from function.  See [Functions (Early Returns)].</li>
<li><code>Self</code>: implementor type alias.  See [Traits].</li>
<li><code>self</code>: method subject.  See [Method Syntax (Method Calls)].</li>
<li><code>static</code>: global variable.  See <a href="const-and-static.html#static"><code>const</code> and <code>static</code> (<code>static</code>)</a>.</li>
<li><code>struct</code>: structure definition.  See [Structs].</li>
<li><code>trait</code>: trait definition.  See [Traits].</li>
<li><code>true</code>: boolean true literal.  See [Primitive Types (Booleans)].</li>
<li><code>type</code>: type alias, and associated type definition.  See [<code>type</code> Aliases], [Associated Types].</li>
<li><code>unsafe</code>: denotes unsafe code, functions, traits, and implementations.  See [Unsafe].</li>
<li><code>use</code>: import symbols into scope.  See [Crates and Modules (Importing Modules with <code>use</code>)].</li>
<li><code>where</code>: type constraint clauses.  See [Traits (<code>where</code> clause)].</li>
<li><code>while</code>: conditional loop.  See [Loops (<code>while</code>)].</li>
</ul>
<h2>Operators and Symbols</h2>
<ul>
<li><code>!</code> (<code>ident!(…)</code>, <code>ident!{…}</code>, <code>ident![…]</code>): denotes macro expansion.  See [Macros].</li>
<li><code>!</code> (<code>!expr</code>): bitwise or logical complement.  Overloadable (<code>Not</code>).</li>
<li><code>!=</code> (<code>var != expr</code>): nonequality comparison.  Overloadable (<code>PartialEq</code>).</li>
<li><code>%</code> (<code>expr % expr</code>): arithmetic remainder.  Overloadable (<code>Rem</code>).</li>
<li><code>%=</code> (<code>var %= expr</code>): arithmetic remainder &amp; assignment.</li>
<li><code>&amp;</code> (<code>expr &amp; expr</code>): bitwise and.  Overloadable (<code>BitAnd</code>).</li>
<li><code>&amp;</code> (<code>&amp;expr</code>): borrow.  See [References and Borrowing].</li>
<li><code>&amp;</code> (<code>&amp;type</code>, <code>&amp;mut type</code>, <code>&amp;'a type</code>, <code>&amp;'a mut type</code>): borrowed pointer type.  See [References and Borrowing].</li>
<li><code>&amp;=</code> (<code>var &amp;= expr</code>): bitwise and &amp; assignment.</li>
<li><code>&amp;&amp;</code> (<code>expr &amp;&amp; expr</code>): logical and.</li>
<li><code>*</code> (<code>expr * expr</code>): arithmetic multiplication.  Overloadable (<code>Mul</code>).</li>
<li><code>*</code> (<code>*expr</code>): dereference.</li>
<li><code>*</code> (<code>*const type</code>, <code>*mut type</code>): raw pointer.  See [Raw Pointers].</li>
<li><code>*=</code> (<code>var *= expr</code>): arithmetic multiplication &amp; assignment.</li>
<li><code>+</code> (<code>expr + expr</code>): arithmetic addition.  Overloadable (<code>Add</code>).</li>
<li><code>+</code> (<code>trait + trait</code>, <code>'a + trait</code>): compound type constraint.  See [Traits (Multiple Trait Bounds)].</li>
<li><code>+=</code> (<code>var += expr</code>): arithmetic addition &amp; assignment.</li>
<li><code>,</code>: argument and element separator.  See [Attributes], [Functions], [Structs], [Generics], [Match], [Closures], [Crates and Modules (Importing Modules with <code>use</code>)].</li>
<li><code>-</code> (<code>expr - expr</code>): arithmetic subtraction.  Overloadable (<code>Sub</code>).</li>
<li><code>-</code> (<code>- expr</code>): arithmetic negation.  Overloadable (<code>Neg</code>).</li>
<li><code>-=</code> (<code>var -= expr</code>): arithmetic subtraction &amp; assignment.</li>
<li><code>-&gt;</code> (<code>fn(…) -&gt; type</code>, <code>|…| -&gt; type</code>): function and closure return type.  See [Functions], [Closures].</li>
<li><code>-&gt; !</code> (<code>fn(…) -&gt; !</code>, <code>|…| -&gt; !</code>): diverging function or closure. See [Diverging Functions].</li>
<li><code>.</code> (<code>expr.ident</code>): member access.  See [Structs], [Method Syntax].</li>
<li><code>..</code> (<code>..</code>, <code>expr..</code>, <code>..expr</code>, <code>expr..expr</code>): right-exclusive range literal.</li>
<li><code>..</code> (<code>..expr</code>): struct literal update syntax.  See [Structs (Update syntax)].</li>
<li><code>..</code> (<code>variant(x, ..)</code>, <code>struct_type { x, .. }</code>): &quot;and the rest&quot; pattern binding.  See [Patterns (Ignoring bindings)].</li>
<li><code>...</code> (<code>expr ... expr</code>): inclusive range pattern.  See [Patterns (Ranges)].</li>
<li><code>/</code> (<code>expr / expr</code>): arithmetic division.  Overloadable (<code>Div</code>).</li>
<li><code>/=</code> (<code>var /= expr</code>): arithmetic division &amp; assignment.</li>
<li><code>:</code> (<code>pat: type</code>, <code>ident: type</code>): constraints.  See [Variable Bindings], [Functions], [Structs], [Traits].</li>
<li><code>:</code> (<code>ident: expr</code>): struct field initializer.  See [Structs].</li>
<li><code>:</code> (<code>'a: loop {…}</code>): loop label.  See [Loops (Loops Labels)].</li>
<li><code>;</code>: statement and item terminator.</li>
<li><code>;</code> (<code>[…; len]</code>): part of fixed-size array syntax.  See [Primitive Types (Arrays)].</li>
<li><code>&lt;&lt;</code> (<code>expr &lt;&lt; expr</code>): left-shift.  Overloadable (<code>Shl</code>).</li>
<li><code>&lt;&lt;=</code> (<code>var &lt;&lt;= expr</code>): left-shift &amp; assignment.</li>
<li><code>&lt;</code> (<code>expr &lt; expr</code>): less-than comparison.  Overloadable (<code>PartialOrd</code>).</li>
<li><code>&lt;=</code> (<code>var &lt;= expr</code>): less-than or equal-to comparison.  Overloadable (<code>PartialOrd</code>).</li>
<li><code>=</code> (<code>var = expr</code>, <code>ident = type</code>): assignment/equivalence.  See [Variable Bindings], [<code>type</code> Aliases], generic parameter defaults.</li>
<li><code>==</code> (<code>var == expr</code>): equality comparison.  Overloadable (<code>PartialEq</code>).</li>
<li><code>=&gt;</code> (<code>pat =&gt; expr</code>): part of match arm syntax.  See [Match].</li>
<li><code>&gt;</code> (<code>expr &gt; expr</code>): greater-than comparison.  Overloadable (<code>PartialOrd</code>).</li>
<li><code>&gt;=</code> (<code>var &gt;= expr</code>): greater-than or equal-to comparison.  Overloadable (<code>PartialOrd</code>).</li>
<li><code>&gt;&gt;</code> (<code>expr &gt;&gt; expr</code>): right-shift.  Overloadable (<code>Shr</code>).</li>
<li><code>&gt;&gt;=</code> (<code>var &gt;&gt;= expr</code>): right-shift &amp; assignment.</li>
<li><code>@</code> (<code>ident @ pat</code>): pattern binding.  See [Patterns (Bindings)].</li>
<li><code>^</code> (<code>expr ^ expr</code>): bitwise exclusive or.  Overloadable (<code>BitXor</code>).</li>
<li><code>^=</code> (<code>var ^= expr</code>): bitwise exclusive or &amp; assignment.</li>
<li><code>|</code> (<code>expr | expr</code>): bitwise or.  Overloadable (<code>BitOr</code>).</li>
<li><code>|</code> (<code>pat | pat</code>): pattern alternatives.  See [Patterns (Multiple patterns)].</li>
<li><code>|</code> (<code>|…| expr</code>): closures.  See [Closures].</li>
<li><code>|=</code> (<code>var |= expr</code>): bitwise or &amp; assignment.</li>
<li><code>||</code> (<code>expr || expr</code>): logical or.</li>
<li><code>_</code>: &quot;ignored&quot; pattern binding.  See [Patterns (Ignoring bindings)].</li>
</ul>
<h2>Other Syntax</h2>
<!-- Various bits of standalone stuff. -->
<ul>
<li><code>'ident</code>: named lifetime or loop label.  See [Lifetimes], [Loops (Loops Labels)].</li>
<li><code>…u8</code>, <code>…i32</code>, <code>…f64</code>, <code>…usize</code>, …: numeric literal of specific type.</li>
<li><code>&quot;…&quot;</code>: string literal.  See [Strings].</li>
<li><code>r&quot;…&quot;</code>, <code>r#&quot;…&quot;#</code>, <code>r##&quot;…&quot;##</code>, …: raw string literal, escape characters are not processed. See [Reference (Raw String Literals)].</li>
<li><code>b&quot;…&quot;</code>: byte string literal, constructs a <code>[u8]</code> instead of a string. See [Reference (Byte String Literals)].</li>
<li><code>br&quot;…&quot;</code>, <code>br#&quot;…&quot;#</code>, <code>br##&quot;…&quot;##</code>, …: raw byte string literal, combination of raw and byte string literal. See [Reference (Raw Byte String Literals)].</li>
<li><code>'…'</code>: character literal.  See [Primitive Types (<code>char</code>)].</li>
<li><code>b'…'</code>: ASCII byte literal.</li>
<li><code>|…| expr</code>: closure.  See [Closures].</li>
</ul>
<!-- Path-related syntax -->
<ul>
<li><code>ident::ident</code>: path.  See [Crates and Modules (Defining Modules)].</li>
<li><code>::path</code>: path relative to the crate root (<em>i.e.</em> an explicitly absolute path).  See [Crates and Modules (Re-exporting with <code>pub use</code>)].</li>
<li><code>self::path</code>: path relative to the current module (<em>i.e.</em> an explicitly relative path).  See [Crates and Modules (Re-exporting with <code>pub use</code>)].</li>
<li><code>super::path</code>: path relative to the parent of the current module.  See [Crates and Modules (Re-exporting with <code>pub use</code>)].</li>
<li><code>type::ident</code>, <code>&lt;type as trait&gt;::ident</code>: associated constants, functions, and types.  See [Associated Types].</li>
<li><code>&lt;type&gt;::…</code>: associated item for a type which cannot be directly named (<em>e.g.</em> <code>&lt;&amp;T&gt;::…</code>, <code>&lt;[T]&gt;::…</code>, <em>etc.</em>).  See [Associated Types].</li>
<li><code>trait::method(…)</code>: disambiguating a method call by naming the trait which defines it. See [Universal Function Call Syntax].</li>
<li><code>type::method(…)</code>: disambiguating a method call by naming the type for which it's defined. See [Universal Function Call Syntax].</li>
<li><code>&lt;type as trait&gt;::method(…)</code>: disambiguating a method call by naming the trait <em>and</em> type. See [Universal Function Call Syntax (Angle-bracket Form)].</li>
</ul>
<!-- Generics -->
<ul>
<li><code>path&lt;…&gt;</code> (<em>e.g.</em> <code>Vec&lt;u8&gt;</code>): specifies parameters to generic type <em>in a type</em>.  See [Generics].</li>
<li><code>path::&lt;…&gt;</code>, <code>method::&lt;…&gt;</code> (<em>e.g.</em> <code>&quot;42&quot;.parse::&lt;i32&gt;()</code>): specifies parameters to generic type, function, or method <em>in an expression</em>.</li>
<li><code>fn ident&lt;…&gt; …</code>: define generic function.  See [Generics].</li>
<li><code>struct ident&lt;…&gt; …</code>: define generic structure.  See [Generics].</li>
<li><code>enum ident&lt;…&gt; …</code>: define generic enumeration.  See [Generics].</li>
<li><code>impl&lt;…&gt; …</code>: define generic implementation.</li>
<li><code>for&lt;…&gt; type</code>: higher-ranked lifetime bounds.</li>
<li><code>type&lt;ident=type&gt;</code> (<em>e.g.</em> <code>Iterator&lt;Item=T&gt;</code>): a generic type where one or more associated types have specific assignments.  See [Associated Types].</li>
</ul>
<!-- Constraints -->
<ul>
<li><code>T: U</code>: generic parameter <code>T</code> constrained to types that implement <code>U</code>.  See [Traits].</li>
<li><code>T: 'a</code>: generic type <code>T</code> must outlive lifetime <code>'a</code>. When we say that a type 'outlives' the lifetime, we mean that it cannot transitively contain any references with lifetimes shorter than <code>'a</code>.</li>
<li><code>T : 'static</code>: The generic type <code>T</code> contains no borrowed references other than <code>'static</code> ones.</li>
<li><code>'b: 'a</code>: generic lifetime <code>'b</code> must outlive lifetime <code>'a</code>.</li>
<li><code>T: ?Sized</code>: allow generic type parameter to be a dynamically-sized type.  See [Unsized Types (<code>?Sized</code>)].</li>
<li><code>'a + trait</code>, <code>trait + trait</code>: compound type constraint.  See [Traits (Multiple Trait Bounds)].</li>
</ul>
<!-- Macros and attributes -->
<ul>
<li><code>#[meta]</code>: outer attribute.  See [Attributes].</li>
<li><code>#![meta]</code>: inner attribute.  See [Attributes].</li>
<li><code>$ident</code>: macro substitution.  See [Macros].</li>
<li><code>$ident:kind</code>: macro capture.  See [Macros].</li>
<li><code>$(…)…</code>: macro repetition.  See [Macros].</li>
</ul>
<!-- Comments -->
<ul>
<li><code>//</code>: line comment.  See [Comments].</li>
<li><code>//!</code>: inner line doc comment.  See [Comments].</li>
<li><code>///</code>: outer line doc comment.  See [Comments].</li>
<li><code>/*…*/</code>: block comment.  See [Comments].</li>
<li><code>/*!…*/</code>: inner block doc comment.  See [Comments].</li>
<li><code>/**…*/</code>: outer block doc comment.  See [Comments].</li>
</ul>
<!-- Various things involving parens and tuples -->
<ul>
<li><code>()</code>: empty tuple (<em>a.k.a.</em> unit), both literal and type.</li>
<li><code>(expr)</code>: parenthesized expression.</li>
<li><code>(expr,)</code>: single-element tuple expression.  See [Primitive Types (Tuples)].</li>
<li><code>(type,)</code>: single-element tuple type.  See [Primitive Types (Tuples)].</li>
<li><code>(expr, …)</code>: tuple expression.  See [Primitive Types (Tuples)].</li>
<li><code>(type, …)</code>: tuple type.  See [Primitive Types (Tuples)].</li>
<li><code>expr(expr, …)</code>: function call expression.  Also used to initialize tuple <code>struct</code>s and tuple <code>enum</code> variants.  See [Functions].</li>
<li><code>ident!(…)</code>, <code>ident!{…}</code>, <code>ident![…]</code>: macro invocation.  See [Macros].</li>
<li><code>expr.0</code>, <code>expr.1</code>, …: tuple indexing.  See [Primitive Types (Tuple Indexing)].</li>
</ul>
<!-- Bracey things -->
<ul>
<li><code>{…}</code>: block expression.</li>
<li><code>Type {…}</code>: <code>struct</code> literal.  See [Structs].</li>
</ul>
<!-- Brackety things -->
<ul>
<li><code>[…]</code>: array literal.  See [Primitive Types (Arrays)].</li>
<li><code>[expr; len]</code>: array literal containing <code>len</code> copies of <code>expr</code>.  See [Primitive Types (Arrays)].</li>
<li><code>[type; len]</code>: array type containing <code>len</code> instances of <code>type</code>.  See [Primitive Types (Arrays)].</li>
<li><code>expr[expr]</code>: collection indexing.  Overloadable (<code>Index</code>, <code>IndexMut</code>).</li>
<li><code>expr[..]</code>, <code>expr[a..]</code>, <code>expr[..b]</code>, <code>expr[a..b]</code>: collection indexing pretending to be collection slicing, using <code>Range</code>, <code>RangeFrom</code>, <code>RangeTo</code>, <code>RangeFull</code> as the &quot;index&quot;.</li>
</ul>
<p>[<code>const</code> and <code>static</code>]: const-and-static.html
[<code>if let</code>]: if-let.html
[<code>if</code>]: if.html
[<code>type</code> Aliases]: type-aliases.html
[Associated Types]: associated-types.html
[Attributes]: attributes.html
[Casting Between Types (<code>as</code>)]: casting-between-types.html#as
[Closures (<code>move</code> closures)]: closures.html#move-closures
[Closures]: closures.html
[Comments]: comments.html
[Crates and Modules (Defining Modules)]: crates-and-modules.html#defining-modules
[Crates and Modules (Exporting a Public Interface)]: crates-and-modules.html#exporting-a-public-interface
[Crates and Modules (Importing External Crates)]: crates-and-modules.html#importing-external-crates
[Crates and Modules (Importing Modules with <code>use</code>)]: crates-and-modules.html#importing-modules-with-use
[Crates and Modules (Re-exporting with <code>pub use</code>)]: crates-and-modules.html#re-exporting-with-pub-use
[Diverging Functions]: functions.html#diverging-functions
[Enums]: enums.html
[Foreign Function Interface]: ffi.html
[Functions (Early Returns)]: functions.html#early-returns
[Functions]: functions.html
[Generics]: generics.html
[Lifetimes]: lifetimes.html
[Loops (<code>for</code>)]: loops.html#for
[Loops (<code>loop</code>)]: loops.html#loop
[Loops (<code>while</code>)]: loops.html#while
[Loops (Ending Iteration Early)]: loops.html#ending-iteration-early
[Loops (Loops Labels)]: loops.html#loop-labels
[Macros]: macros.html
[Match]: match.html
[Method Syntax (Method Calls)]: method-syntax.html#method-calls
[Method Syntax]: method-syntax.html
[Mutability]: mutability.html
[Operators and Overloading]: operators-and-overloading.html
[Patterns (<code>ref</code> and <code>ref mut</code>)]: patterns.html#ref-and-ref-mut
[Patterns (Bindings)]: patterns.html#bindings
[Patterns (Ignoring bindings)]: patterns.html#ignoring-bindings
[Patterns (Multiple patterns)]: patterns.html#multiple-patterns
[Patterns (Ranges)]: patterns.html#ranges
[Primitive Types (<code>char</code>)]: primitive-types.html#char
[Primitive Types (Arrays)]: primitive-types.html#arrays
[Primitive Types (Booleans)]: primitive-types.html#booleans
[Primitive Types (Tuple Indexing)]: primitive-types.html#tuple-indexing
[Primitive Types (Tuples)]: primitive-types.html#tuples
[Raw Pointers]: raw-pointers.html
[Reference (Byte String Literals)]: ../reference.html#byte-string-literals
[Reference (Raw Byte String Literals)]: ../reference.html#raw-byte-string-literals
[Reference (Raw String Literals)]: ../reference.html#raw-string-literals
[References and Borrowing]: references-and-borrowing.html
[Strings]: strings.html
[Structs (Update syntax)]: structs.html#update-syntax
[Structs]: structs.html
[Traits (<code>where</code> clause)]: traits.html#where-clause
[Traits (Multiple Trait Bounds)]: traits.html#multiple-trait-bounds
[Traits]: traits.html
[Universal Function Call Syntax]: ufcs.html
[Universal Function Call Syntax (Angle-bracket Form)]: ufcs.html#angle-bracket-form
[Unsafe]: unsafe.html
[Unsized Types (<code>?Sized</code>)]: unsized-types.html#sized
[Variable Bindings]: variable-bindings.html</p>
<blockquote>
<p><em>commit d7c57e1</em></p>
</blockquote>
<h1>參考文獻</h1>
<p>這是有關於 Rust 的相關資料列表。
包含了某些時期影響了 Rust 設計的的早期研究，像是跟 Rust 有關的出版物。</p>
<blockquote>
<p>譯註：以下出版物名稱與註解皆保留原文。</p>
</blockquote>
<h2>型別系統</h2>
<ul>
<li><a href="http://209.68.42.137/ucsd-pages/Courses/cse227.w03/handouts/cyclone-regions.pdf">Region based memory management in Cyclone</a></li>
<li><a href="http://www.cs.umd.edu/projects/PL/cyclone/scp.pdf">Safe manual memory management in Cyclone</a></li>
<li><a href="http://www.ps.uni-sb.de/courses/typen-ws99/class.ps.gz">Typeclasses: making ad-hoc polymorphism less ad hoc</a></li>
<li><a href="https://www.cs.utah.edu/plt/publications/jfp12-draft-fcdf.pdf">Macros that work together</a></li>
<li><a href="http://scg.unibe.ch/archive/papers/Scha03aTraits.pdf">Traits: composable units of behavior</a></li>
<li><a href="http://www.cs.uwm.edu/faculty/boyland/papers/unique-preprint.ps">Alias burying</a> - We tried something similar and abandoned it.</li>
<li><a href="http://www.cs.uu.nl/research/techreps/UU-CS-2002-048.html">External uniqueness is unique enough</a></li>
<li><a href="https://research.microsoft.com/pubs/170528/msr-tr-2012-79.pdf">Uniqueness and Reference Immutability for Safe Parallelism</a></li>
<li><a href="http://www.cs.ucla.edu/%7Epalsberg/tba/papers/tofte-talpin-iandc97.pdf">Region Based Memory Management</a></li>
</ul>
<h2>並行 (Concurrency)</h2>
<ul>
<li><a href="https://research.microsoft.com/pubs/69431/osr2007_rethinkingsoftwarestack.pdf">Singularity: rethinking the software stack</a></li>
<li><a href="https://research.microsoft.com/pubs/67482/singsharp.pdf">Language support for fast and reliable message passing in singularity OS</a></li>
<li><a href="http://supertech.csail.mit.edu/papers/steal.pdf">Scheduling multithreaded computations by work stealing</a></li>
<li><a href="http://www.eecis.udel.edu/%7Ecavazos/cisc879-spring2008/papers/arora98thread.pdf">Thread scheduling for multiprogramming multiprocessors</a></li>
<li><a href="http://www.aladdin.cs.cmu.edu/papers/pdfs/y2000/locality_spaa00.pdf">The data locality of work stealing</a></li>
<li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.170.1097&amp;rep=rep1&amp;type=pdf">Dynamic circular work stealing deque</a> - The Chase/Lev deque</li>
<li><a href="http://www.cs.rice.edu/%7Eyguo/pubs/PID824943.pdf">Work-first and help-first scheduling policies for async-finish task parallelism</a> - More general than fully-strict work stealing</li>
<li><a href="http://www.coopsoft.com/ar/CalamityArticle.html">A Java fork/join calamity</a> - critique of Java's fork/join library, particularly its application of work stealing to non-strict computation</li>
<li><a href="http://www.stanford.edu/%7Eouster/cgi-bin/papers/coscheduling.pdf">Scheduling techniques for concurrent systems</a></li>
<li><a href="http://www.blagodurov.net/files/a8-blagodurov.pdf">Contention aware scheduling</a></li>
<li><a href="http://www.cse.ohio-state.edu/hpcs/WWW/HTML/publications/papers/TR-12-1.pdf">Balanced work stealing for time-sharing multicores</a></li>
<li><a href="http://dl.acm.org/citation.cfm?id=1953616&amp;dl=ACM&amp;coll=DL&amp;CFID=524387192&amp;CFTOKEN=44362705">Three layer cake for shared-memory programming</a></li>
<li><a href="http://www.cs.bgu.ac.il/%7Ehendlerd/papers/p280-hendler.pdf">Non-blocking steal-half work queues</a></li>
<li><a href="http://www.mpi-sws.org/%7Eturon/reagents.pdf">Reagents: expressing and composing fine-grained concurrency</a></li>
<li><a href="https://www.cs.rochester.edu/u/scott/papers/1991_TOCS_synch.pdf">Algorithms for scalable synchronization of shared-memory multiprocessors</a></li>
<li><a href="https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-579.pdf">Epoch-based reclamation</a>.</li>
</ul>
<h2>其他</h2>
<ul>
<li><a href="https://www.usenix.org/legacy/events/hotos03/tech/full_papers/candea/candea.pdf">Crash-only software</a></li>
<li><a href="http://people.cs.umass.edu/%7Eemery/pubs/berger-pldi2001.pdf">Composing High-Performance Memory Allocators</a></li>
<li><a href="http://people.cs.umass.edu/%7Eemery/pubs/berger-oopsla2002.pdf">Reconsidering Custom Memory Allocation</a></li>
</ul>
<h2>Rust <em>相關</em> 論文</h2>
<ul>
<li><a href="http://www.cs.indiana.edu/%7Eeholk/papers/hips2013.pdf">GPU Programming in Rust: Implementing High Level Abstractions in a
Systems Level
Language</a>. Early GPU work by Eric Holk.</li>
<li><a href="https://www.usenix.org/conference/hotpar12/parallel-closures-new-twist-old-idea">Parallel closures: a new twist on an old
idea</a>
<ul>
<li>not exactly about Rust, but by nmatsakis</li>
</ul>
</li>
<li><a href="ftp://ftp.cs.washington.edu/tr/2015/03/UW-CSE-15-03-02.pdf">Patina: A Formalization of the Rust Programming
Language</a>. Early
formalization of a subset of the type system, by Eric Reed.</li>
<li><a href="http://arxiv.org/abs/1505.07383">Experience Report: Developing the Servo Web Browser Engine using
Rust</a>. By Lars Bergstrom.</li>
<li><a href="https://michaelsproul.github.io/rust_radix_paper/rust-radix-sproul.pdf">Implementing a Generic Radix Trie in
Rust</a>. Undergrad
paper by Michael Sproul.</li>
<li><a href="http://scialex.github.io/reenix.pdf">Reenix: Implementing a Unix-Like Operating System in
Rust</a>. Undergrad paper by Alex
Light.</li>
<li>[Evaluation of performance and productivity metrics of potential
programming languages in the HPC environment]
(http://octarineparrot.com/assets/mrfloya-thesis-ba.pdf).
Bachelor's thesis by Florian Wilkens. Compares C, Go and Rust.</li>
<li><a href="http://spw15.langsec.org/papers/couprie-nom.pdf">Nom, a byte oriented, streaming, zero copy, parser combinators library
in Rust</a>. By
Geoffroy Couprie, research for VLC.</li>
<li><a href="http://compilers.cs.uni-saarland.de/papers/lkh15_cgo.pdf">Graph-Based Higher-Order Intermediate
Representation</a>. An
experimental IR implemented in Impala, a Rust-like language.</li>
<li><a href="http://compilers.cs.uni-saarland.de/papers/ppl14_web.pdf">Code Refinement of Stencil
Codes</a>. Another
paper using Impala.</li>
<li><a href="http://publications.lib.chalmers.se/records/fulltext/219016/219016.pdf">Parallelization in Rust with fork-join and
friends</a>. Linus
Farnstrand's master's thesis.</li>
<li><a href="http://munksgaard.me/papers/laumann-munksgaard-larsen.pdf">Session Types for
Rust</a>. Philip
Munksgaard's master's thesis. Research for Servo.</li>
<li><a href="http://amitlevy.com/papers/tock-plos2015.pdf">Ownership is Theft: Experiences Building an Embedded OS in Rust - Amit Levy, et. al.</a></li>
<li><a href="https://raw.githubusercontent.com/Gankro/thesis/master/thesis.pdf">You can't spell trust without Rust</a>. Alexis Beingessner's master's thesis.</li>
</ul>
<blockquote>
<p><em>commit c158fd9</em></p>
</blockquote>
<h1>中英對照表</h1>
<h2>對照表</h2>
<table><thead><tr><td>English 英文           </td><td> Traditional Chinese 正體中文  </td><td> Note 備註</td></tr></thead>
<tr><td>Abstract Syntax Tree   </td><td> 抽象語法樹                    </td><td> 參考：<a href="https://zh.wikipedia.org/zh-tw/%E6%8A%BD%E8%B1%A1%E8%AA%9E%E6%B3%95%E6%A8%B9">維基百科</a></td></tr>
<tr><td>ahead-of-time compiled </td><td> 事先編譯                      </td></tr>
<tr><td>annotations            </td><td> 註釋                          </td></tr>
<tr><td>arity                  </td><td> 元數                          </td><td> 所需運算元的數量。參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%85%83%E6%95%B0">維基百科</a></td></tr>
<tr><td>array                  </td><td> 陣列                          </td><td> 參考：<a href="https://zh.wikipedia.org/zh-tw/%E6%95%B0%E7%BB%84">維基百科</a></td></tr>
<tr><td>assignment             </td><td> 賦值                          </td></tr>
<tr><td>best-practice          </td><td> 最佳做法                      </td></tr>
<tr><td>bit                    </td><td> 位元                          </td><td> 參考：<a href="https://zh.wikipedia.org/zh-tw/%E4%BD%8D%E5%85%83">維基百科</a></td></tr>
<tr><td>block                  </td><td> 區塊                          </td></tr>
<tr><td>boolean                </td><td> 布林                          </td><td> 參考：<a href="https://zh.wikipedia.org/wiki/%E5%B8%83%E7%88%BE_(%E6%95%B8%E6%93%9A%E9%A1%9E%E5%9E%8B)">維基百科</a></td></tr>
<tr><td>bounds-check           </td><td> 邊界檢查                      </td><td> 參考：<a href="https://zh.wikipedia.org/zh-tw/%E8%BE%B9%E7%95%8C%E6%A3%80%E6%9F%A5">維基百科</a></td></tr>
<tr><td>borrowing              </td><td> 借用                          </td></tr>
<tr><td>bug                    </td><td> 程式錯誤                      </td></tr>
<tr><td>byte                   </td><td> 位元組                        </td><td> 參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%AD%97%E8%8A%82">維基百科</a></td></tr>
<tr><td>collection             </td><td> 集合                          </td><td> 參考：<a href="https://zh.wikipedia.org/zh-tw/%E9%9B%86%E5%90%88_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">維基百科</a></td></tr>
<tr><td>concurrency            </td><td> 並行                          </td><td> 參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%B9%B6%E5%8F%91%E8%AE%A1%E7%AE%97">維基百科</a></td></tr>
<tr><td>conditional            </td><td> 條件運算                      </td><td> 參考：<a href="https://zh.wikipedia.org/zh-tw/%E6%A2%9D%E4%BB%B6%E9%81%8B%E7%AE%97%E5%BC%8F">維基百科</a></td></tr>
<tr><td>configuration          </td><td> 配置                          </td></tr>
<tr><td>constant               </td><td> 常數                          </td><td> 參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%B8%B8%E6%95%B0">維基百科</a></td></tr>
<tr><td>crash                  </td><td> 當機                          </td></tr>
<tr><td>dangling pointer       </td><td> 迷途指標                      </td><td> 參考：<a href="https://zh.wikipedia.org/zh-tw/%E8%BF%B7%E9%80%94%E6%8C%87%E9%92%88">維基百科</a></td></tr>
<tr><td>data race              </td><td> 資料競爭                      </td></tr>
<tr><td>declaration statements </td><td> 宣告陳述式                    </td></tr>
<tr><td>deque                  </td><td> 雙向佇列                      </td><td> Double-ended queue</td></tr>
<tr><td>diverging functions    </td><td> 發散函式                      </td><td> 不回傳值的函式</td></tr>
<tr><td>enumerate              </td><td> 枚舉                          </td><td> 參考：<a href="https://zh.wikipedia.org/zh-tw/%E6%9E%9A%E4%B8%BE">維基百科</a></td></tr>
<tr><td>executable             </td><td> 執行檔                        </td></tr>
<tr><td>expression             </td><td> 表達式                        </td></tr>
<tr><td>expression-oriented    </td><td> 表達式導向                    </td></tr>
<tr><td>expression statements  </td><td> 表達陳述式                    </td></tr>
<tr><td>extensions             </td><td> 擴充功能                      </td></tr>
<tr><td>handle                 </td><td> 控制代碼                      </td><td> 參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%8F%A5%E6%9F%84">維基百科</a>、<a href="https://msdn.microsoft.com/zh-tw/library/yk97tc08.aspx">MSDN</a></td></tr>
<tr><td>heap                   </td><td> 堆積                          </td><td> 參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%A0%86_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)">維基百科</a></td></tr>
<tr><td>fault                  </td><td> 錯誤                          </td></tr>
<tr><td>formalization          </td><td> 正規化                        </td></tr>
<tr><td>function               </td><td> 函式                          </td><td> 參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%AD%90%E7%A8%8B%E5%BA%8F">維基百科</a></td></tr>
<tr><td>generics               </td><td> 泛型                          </td><td> 參考：<a href="https://zh.wikipedia.org/zh-tw/%E6%B3%9B%E5%9E%8B">維基百科</a></td></tr>
<tr><td>iterative              </td><td> 疊代                          </td><td> 參考：<a href="https://zh.wikipedia.org/zh-tw/%E8%BF%AD%E4%BB%A3">維基百科</a></td></tr>
<tr><td>iterator               </td><td> 疊代器                        </td><td> 參考：<a href="https://zh.wikipedia.org/zh-tw/%E8%BF%AD%E4%BB%A3%E5%99%A8">維基百科</a></td></tr>
<tr><td>immutable              </td><td> 不可變                        </td><td> 參考：<a href="https://zh.wikipedia.org/zh-tw/%E4%B8%8D%E5%8F%AF%E8%AE%8A%E7%89%A9%E4%BB%B6">維基百科</a></td></tr>
<tr><td>library                </td><td> 函式庫                        </td><td> 參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%87%BD%E5%BC%8F%E5%BA%AB">維基百科</a></td></tr>
<tr><td>lifetimes              </td><td> 生命週期                      </td></tr>
<tr><td>loop                   </td><td> 迴圈、循環                    </td><td> 參考：<a href="https://zh.wikipedia.org/zh-tw/%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B#.E8.BF.B4.E5.9C.88">維基百科</a></td></tr>
<tr><td>macro                  </td><td> 巨集                          </td><td> 參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%B7%A8%E9%9B%86">維基百科</a></td></tr>
<tr><td>main function          </td><td> 主函式                        </td><td> 參考：<a href="https://zh.wikipedia.org/zh-tw/%E4%B8%BB%E5%87%BD%E5%BC%8F">維基百科</a></td></tr>
<tr><td>method                 </td><td> 方法                          </td><td> 參考：<a href="https://zh.wikipedia.org/zh-tw/%E6%96%B9%E6%B3%95_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8)">維基百科</a></td></tr>
<tr><td>module                 </td><td> 模組                          </td><td> 參考：<a href="https://zh.wikipedia.org/zh-tw/%E6%A8%A1%E7%B5%84_(%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88)">維基百科</a></td></tr>
<tr><td>mutable                </td><td> 可變                          </td><td> 參考：<a href="https://zh.wikipedia.org/zh-tw/%E4%B8%8D%E5%8F%AF%E8%AE%8A%E7%89%A9%E4%BB%B6">維基百科</a></td></tr>
<tr><td>mutability             </td><td> 可變性                        </td></tr>
<tr><td>mutation               </td><td> 可變數                        </td></tr>
<tr><td>operators              </td><td> 運算子                        </td><td> 參考：<a href="https://zh.wikipedia.org/zh-tw/C%E5%92%8CC%2B%2B%E9%81%8B%E7%AE%97%E5%AD%90">維基百科</a></td></tr>
<tr><td>ownership              </td><td> 所有權                        </td></tr>
<tr><td>package                </td><td> 套件                          </td><td> 參考：<a href="https://zh.wikipedia.org/zh-tw/%E8%BD%AF%E4%BB%B6%E5%8C%85">維基百科</a></td></tr>
<tr><td>pattern                </td><td> 模式                          </td><td> 參考：<a href="https://zh.wikipedia.org/zh-tw/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1%E7%AE%97%E6%9C%BA)">維基百科</a></td></tr>
<tr><td>plugins                </td><td> 外掛                          </td></tr>
<tr><td>pointer                </td><td> 指標                          </td><td> 參考：<a href="https://zh.wikipedia.org/zh-tw/%E6%8C%87%E6%A8%99_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8)">維基百科</a></td></tr>
<tr><td>primitive type         </td><td> 基本型別                      </td><td> 參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%8E%9F%E5%A7%8B%E5%9E%8B%E5%88%A5">維基百科</a></td></tr>
<tr><td>reference              </td><td> 參照、參考                    </td><td> 參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%8F%83%E7%85%A7">維基百科</a></td></tr>
<tr><td>scope                  </td><td> 有效範圍                      </td></tr>
<tr><td>semantics              </td><td> 語意                          </td></tr>
<tr><td>segment                </td><td> 區段                          </td><td> 參考：<a href="https://zh.wikipedia.org/zh-tw/%E8%A8%98%E6%86%B6%E9%AB%94%E5%88%86%E6%AE%B5">維基百科</a></td></tr>
<tr><td>segmentation fault     </td><td> 記憶體區段錯誤                </td><td> 參考：<a href="https://zh.wikipedia.org/zh-tw/%E8%A8%98%E6%86%B6%E9%AB%94%E5%8D%80%E6%AE%B5%E9%8C%AF%E8%AA%A4">維基百科</a></td></tr>
<tr><td>shadowing              </td><td> 遮蔽                          </td></tr>
<tr><td>signed integer         </td><td> 帶號整數                      </td><td> 參考：<a href="https://zh.wikipedia.org/zh-tw/%E6%95%B4%E6%95%B0_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">維基百科</a></td></tr>
<tr><td>stack                  </td><td> 堆疊                          </td><td> 參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%A0%86%E6%A0%88">維基百科</a></td></tr>
<tr><td>statements             </td><td> 陳述式                        </td></tr>
<tr><td>string                 </td><td> 字串                          </td><td> 參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%AD%97%E7%AC%A6%E4%B8%B2">維基百科</a></td></tr>
<tr><td>string interpolation   </td><td> 字串插值                      </td><td> 參考：<a href="https://msdn.microsoft.com/zh-tw/library/dn961160.aspx">MSDN</a></td></tr>
<tr><td>struct                 </td><td> 結構體                        </td><td> 參考：<a href="https://zh.wikipedia.org/zh-tw/C%2B%2B%E7%B1%BB">維基百科</a>、<a href="https://zh.wikipedia.org/zh-tw/%E7%BB%93%E6%9E%84%E4%BD%93_(C%E8%AF%AD%E8%A8%80)">維基百科</a></td></tr>
<tr><td>subscript              </td><td> 下標                          </td><td> 指的是 <code>a[1]</code> 中的 <code>[1]</code></td></tr>
<tr><td>symbols                </td><td> 符號                          </td></tr>
<tr><td>syntax                 </td><td> 語法                          </td></tr>
<tr><td>thread                 </td><td> 執行緒                        </td><td> 參考：<a href="https://zh.wikipedia.org/zh-tw/%E7%BA%BF%E7%A8%8B">維基百科</a></td></tr>
<tr><td>tuple                  </td><td> 多元組                        </td><td> 參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%A4%9A%E5%85%83%E7%BB%84">維基百科</a></td></tr>
<tr><td>two’s complement       </td><td> 二補數                        </td><td> 參考：<a href="https://zh.wikipedia.org/zh-tw/%E4%BA%8C%E8%A3%9C%E6%95%B8">維基百科</a></td></tr>
<tr><td>type                   </td><td> 型別                          </td><td> 參考：<a href="https://zh.wikipedia.org/zh-tw/%E8%B3%87%E6%96%99%E9%A1%9E%E5%9E%8B">維基百科</a></td></tr>
<tr><td>type inference         </td><td> 型別推斷                      </td><td> 參考：<a href="https://zh.wikipedia.org/zh-tw/%E7%B1%BB%E5%9E%8B%E6%8E%A8%E8%AE%BA">維基百科</a></td></tr>
<tr><td>unsigned integer       </td><td> 非帶號整數                    </td><td> 參考：<a href="https://zh.wikipedia.org/zh-tw/%E6%95%B4%E6%95%B0_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">維基百科</a></td></tr>
<tr><td>values                 </td><td> 值、數值                      </td></tr>
<tr><td>variables              </td><td> 變數                          </td></tr>
<tr><td>vector                 </td><td> 向量                          </td></tr>
<tr><td>view                   </td><td> 視圖                          </td><td> 參考：<a href="https://zh.wikipedia.org/zh-tw/%E8%A7%86%E5%9B%BE">維基百科</a></td></tr>
<tr><td>zero-cost abstractions </td><td> 無成本抽象化                  </td></tr>
</table>
<h2>不確定</h2>
<table><thead><tr><td>English 英文           </td><td> Traditional Chinese 正體中文  </td><td> Note 備註</td></tr></thead>
<tr><td>alignment              </td><td>                               </td></tr>
<tr><td>backtrace              </td><td>                               </td></tr>
<tr><td>bootstrap              </td><td>                               </td></tr>
<tr><td>build                  </td><td>                               </td><td> 名詞，例：create a &quot;build&quot;</td></tr>
<tr><td>commit                 </td><td>                               </td><td> git commit</td></tr>
<tr><td>crates                 </td><td>                               </td></tr>
<tr><td>dependencies           </td><td>                               </td></tr>
<tr><td>destructuring let      </td><td>                               </td><td> 用於存取 tuple</td></tr>
<tr><td>fully-strict           </td><td>                               </td></tr>
<tr><td>hash                   </td><td>                               </td></tr>
<tr><td>linker                 </td><td>                               </td></tr>
<tr><td>linking                </td><td>                               </td></tr>
<tr><td>master                 </td><td>                               </td><td> git branch</td></tr>
<tr><td>mata                   </td><td>                               </td></tr>
<tr><td>metaprogramming        </td><td>                               </td></tr>
<tr><td>non-strict             </td><td>                               </td></tr>
<tr><td>patches                </td><td>                               </td></tr>
<tr><td>profiles               </td><td>                               </td></tr>
<tr><td>repository             </td><td>                               </td></tr>
<tr><td>root                   </td><td>                               </td></tr>
<tr><td>shell                  </td><td>                               </td></tr>
<tr><td>slices                 </td><td>                               </td><td> 其他資料結構的參考</td></tr>
<tr><td>tabs                   </td><td>                               </td></tr>
<tr><td>target triple          </td><td>                               </td></tr>
<tr><td>trait                  </td><td>                               </td></tr>
<tr><td>work stealing          </td><td>                               </td></tr>
</table>
<blockquote>
<p>TODO：持續整理中⋯</p>
</blockquote>
<h1>翻譯貢獻名單</h1>
<p><em>依照慣例，以暱稱英文字母排序</em></p>
<ul>
<li><a href="https://github.com/askeing">Askeing Yen</a></li>
</ul>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
