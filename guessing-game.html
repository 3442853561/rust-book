<!DOCTYPE HTML>
<html lang="zh-Hant">
    <head>
        <meta charset="UTF-8">
        <title>Rust 程式語言 正體中文版</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The Rust Programming Language">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

		<style>
            @import url(http://fonts.googleapis.com/earlyaccess/cwtexhei.css);
        </style>
        <link rel="stylesheet" href="book.css">
        <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body>
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="README.html"><strong>1.</strong> 簡介</a></li><li><a href="getting-started.html"><strong>2.</strong> 準備</a></li><li><a href="guessing-game.html" class="active"><strong>3.</strong> 教學: 猜數字遊戲</a></li><li><a href="syntax-and-semantics.html"><strong>4.</strong> 語法及語意</a></li><li><ul class="section"><li><a href="variable-bindings.html"><strong>4.1.</strong> 變數綁定</a></li><li><a href="functions.html"><strong>4.2.</strong> 函式</a></li><li><a href="primitive-types.html"><strong>4.3.</strong> 基本型別</a></li><li><a href="comments.html"><strong>4.4.</strong> 註解</a></li><li><a href="if.html"><strong>4.5.</strong> if</a></li><li><a href="loops.html"><strong>4.6.</strong> 迴圈</a></li><li><a href="ownership.html"><strong>4.7.</strong> 所有權</a></li><li><a href="references-and-borrowing.html"><strong>4.8.</strong> 參照與借用</a></li><li><a href="lifetimes.html"><strong>4.9.</strong> 生命週期</a></li><li><a href="mutability.html"><strong>4.10.</strong> 可變性</a></li><li><a href="structs.html"><strong>4.11.</strong> 結構體</a></li><li><a href="enums.html"><strong>4.12.</strong> 枚舉</a></li><li><a href="match.html"><strong>4.13.</strong> Match</a></li><li><a href="patterns.html"><strong>4.14.</strong> 模式</a></li><li><a href="method-syntax.html"><strong>4.15.</strong> Method Syntax</a></li><li><a href="vectors.html"><strong>4.16.</strong> Vectors</a></li><li><a href="strings.html"><strong>4.17.</strong> 字串</a></li><li><a href="generics.html"><strong>4.18.</strong> Generics</a></li><li><a href="traits.html"><strong>4.19.</strong> Traits</a></li><li><a href="drop.html"><strong>4.20.</strong> Drop</a></li><li><a href="if-let.html"><strong>4.21.</strong> if let</a></li><li><a href="trait-objects.html"><strong>4.22.</strong> Trait Objects</a></li><li><a href="closures.html"><strong>4.23.</strong> Closures</a></li><li><a href="ufcs.html"><strong>4.24.</strong> Universal Function Call Syntax</a></li><li><a href="crates-and-modules.html"><strong>4.25.</strong> Crates and Modules</a></li><li><a href="const-and-static.html"><strong>4.26.</strong> <code>const</code> and <code>static</code></a></li><li><a href="attributes.html"><strong>4.27.</strong> Attributes</a></li><li><a href="type-aliases.html"><strong>4.28.</strong> <code>type</code> aliases</a></li><li><a href="casting-between-types.html"><strong>4.29.</strong> Casting between types</a></li><li><a href="associated-types.html"><strong>4.30.</strong> Associated Types</a></li><li><a href="unsized-types.html"><strong>4.31.</strong> Unsized Types</a></li><li><a href="operators-and-overloading.html"><strong>4.32.</strong> Operators and Overloading</a></li><li><a href="deref-coercions.html"><strong>4.33.</strong> Deref coercions</a></li><li><a href="macros.html"><strong>4.34.</strong> Macros</a></li><li><a href="raw-pointers.html"><strong>4.35.</strong> Raw Pointers</a></li><li><a href="unsafe.html"><strong>4.36.</strong> <code>unsafe</code></a></li></ul></li><li><a href="effective-rust.html"><strong>5.</strong> Effective Rust</a></li><li><ul class="section"><li><a href="the-stack-and-the-heap.html"><strong>5.1.</strong> The Stack and the Heap</a></li><li><a href="testing.html"><strong>5.2.</strong> Testing</a></li><li><a href="conditional-compilation.html"><strong>5.3.</strong> Conditional Compilation</a></li><li><a href="documentation.html"><strong>5.4.</strong> Documentation</a></li><li><a href="iterators.html"><strong>5.5.</strong> Iterators</a></li><li><a href="concurrency.html"><strong>5.6.</strong> Concurrency</a></li><li><a href="error-handling.html"><strong>5.7.</strong> Error Handling</a></li><li><a href="choosing-your-guarantees.html"><strong>5.8.</strong> Choosing your Guarantees</a></li><li><a href="ffi.html"><strong>5.9.</strong> FFI</a></li><li><a href="borrow-and-asref.html"><strong>5.10.</strong> Borrow and AsRef</a></li><li><a href="release-channels.html"><strong>5.11.</strong> Release Channels</a></li><li><a href="using-rust-without-the-standard-library.html"><strong>5.12.</strong> Using Rust without the standard library</a></li></ul></li><li><a href="nightly-rust.html"><strong>6.</strong> Nightly Rust</a></li><li><ul class="section"><li><a href="compiler-plugins.html"><strong>6.1.</strong> Compiler Plugins</a></li><li><a href="inline-assembly.html"><strong>6.2.</strong> Inline Assembly</a></li><li><a href="no-stdlib.html"><strong>6.3.</strong> No stdlib</a></li><li><a href="intrinsics.html"><strong>6.4.</strong> Intrinsics</a></li><li><a href="lang-items.html"><strong>6.5.</strong> Lang items</a></li><li><a href="advanced-linking.html"><strong>6.6.</strong> Advanced linking</a></li><li><a href="benchmark-tests.html"><strong>6.7.</strong> Benchmark Tests</a></li><li><a href="box-syntax-and-patterns.html"><strong>6.8.</strong> Box Syntax and Patterns</a></li><li><a href="slice-patterns.html"><strong>6.9.</strong> Slice Patterns</a></li><li><a href="associated-constants.html"><strong>6.10.</strong> Associated Constants</a></li><li><a href="custom-allocators.html"><strong>6.11.</strong> Custom Allocators</a></li></ul></li><li><a href="glossary.html"><strong>7.</strong> 詞彙表</a></li><li><a href="syntax-index.html"><strong>8.</strong> 語法索引</a></li><li><a href="bibliography.html"><strong>9.</strong> 參考文獻</a></li><li><a href="MappingTable.html"><strong>10.</strong> 中英文字彙對照表</a></li><li><a href="CONTRIBUTORS.html"><strong>11.</strong> 翻譯貢獻名單</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">Rust 程式語言 正體中文版</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <h1>猜數字遊戲</h1>
<p>讓我們開始學習 Rust 吧！
作為我們的第一個專案，我們會實作一個經典的新手程式問題：猜數字 (guessing game)。
它的規則是這樣：我們的程式會產生一個 1 到 100 間的亂數。
然後提示我們輸入數字猜猜看。
當我們輸入之後，它會告訴我們太大還是太小。
當我們猜對了，它會恭喜我們。
聽起來不錯吧？</p>
<p>接下來，我們將會學到一些 Rust 的東西。
下一章 &quot;語法及語意&quot; 將會更深入探究每一部份。</p>
<h2>準備</h2>
<p>讓我們準備一個新專案。
進到你的專案目錄。
還記得我們如何替 <code>hello_world</code> 建立目錄結構和 <code>Cargo.toml</code> 嗎？
Cargo 有個能幫我們做好這些事情的指令。
讓我們試試看：</p>
<pre><code class="language-bash">$ cd ~/projects
$ cargo new guessing_game --bin
$ cd guessing_game
</code></pre>
<p>我們傳遞專案的名字給 <code>cargo new</code>，接著是 <code>--bin</code> 的參數，因為我們要建立執行檔而不是函式庫。</p>
<p>看看產生的 <code>Cargo.toml</code>：</p>
<pre><code class="language-toml">[package]

name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
</code></pre>
<p>Cargo 會從你的環境設定中取得這些資訊。
如果它不正確，就直接修改吧。</p>
<p>最後，Cargo 幫我們產生了一個 &quot;Hello, world!&quot;。
看看 <code>src/main.rs</code> 檔案：</p>
<pre><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre>
<p>讓我們試著編譯：</p>
<pre><code class="language-{bash}">$ cargo build
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
</code></pre>
<p>太棒了！
再次打開你的 <code>src/main.rs</code>。
我們將開始在這個檔案寫入所有的程式碼。</p>
<p>在繼續之前，讓我告訴你另一個 Cargo 的指令 <code>run</code>。
<code>cargo run</code> 有點類似 <code>cargo build</code>，但是他同時會執行產生的執行檔。
試試看：</p>
<pre><code class="language-bash">$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/debug/guessing_game`
Hello, world!
</code></pre>
<p>很好！
當我們需要快速地重複執行專案時，<code>run</code> 指令會很方便。
我們的遊戲就是一個專案，我們需要在每個開發循環 (iteration) 做快速的測試後，才會進入下一個開發循環。</p>
<h2>處理猜測</h2>
<p>讓我們開始吧！
我們所要做的第一件事情是讓玩家可以輸入他的猜測值。
把以下內容放入你的 <code>src/main.rs</code>：</p>
<pre><code class="language-rust,no_run">use std::io;

fn main() {
    println!(&quot;Guess the number!&quot;);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    println!(&quot;You guessed: {}&quot;, guess);
}
</code></pre>
<p>東西有點多！
讓我們一個一個來。</p>
<pre><code class="language-rust,ignore">use std::io;
</code></pre>
<p>我們需要取得使用者的輸入，然後印出結果作為輸出。
因此，我們需要標準函式庫中的 <code>io</code> 函式庫。
Rust 預設只會替所有程式 import 極少的東西，叫 <a href="https://doc.rust-lang.org/std/prelude/index.html">prelude</a>。
如果有東西不在其中，你就必須直接 <code>use</code> 它。
這邊還有第二種 &quot;prelude&quot;，叫做 <a href="https://doc.rust-lang.org/std/io/prelude/index.html">io prelude</a>，它提供類似的功能：import 它，然後它幫你 import 一些有用且跟 <code>io</code> 有關的東西。</p>
<pre><code class="language-rust,ignore">fn main() {
</code></pre>
<p>如你之前所看過的，<code>main()</code> 函式是程式的進入點。
<code>fn</code> 語法宣告一個新函式，<code>()</code> 指名了此處沒有傳入的參數，而 <code>{</code> 後面開始是函式的內容。
因為沒有提到回傳型別，所以這裡的回傳會是 <code>()</code>，一個空的<a href="primitive-types.html#%E5%A4%9A%E5%85%83%E7%B5%84%20(Tuples)">多元組</a> (tuple)。</p>
<pre><code class="language-rust,ignore">    println!(&quot;Guess the number!&quot;);

    println!(&quot;Please input your guess.&quot;);
</code></pre>
<p>我們之前學到 <code>println!()</code> 是個將<a href="strings.html">字串</a>印到螢幕的<a href="macros.html">巨集</a>。</p>
<pre><code class="language-rust,ignore">    let mut guess = String::new();
</code></pre>
<p>現在遇到有趣的東西了！
這一行有不少東西。
第一個，請注意有一個 <a href="variable-bindings.html">let 陳述式</a>，它被用來建立 &quot;變數綁定&quot;。
它的形式是：</p>
<pre><code class="language-rust,ignore">let foo = bar;
</code></pre>
<p>這將會建立一個叫做 <code>foo</code> 的新綁定，然後把它綁定在 <code>bar</code> 的值上。
在許多語言中，這叫做 &quot;變數&quot; (variable)，但 Rust 的變數綁定還暗藏玄機。</p>
<p>舉例來說，它預設是<a href="mutability.html">不可變的</a> (immutable)。
這也是為何我們的範例使用 <code>mut</code>：它使綁定變成可變的 (mutable)，而不再是不可變的。
<code>let</code> 不會從左邊取得賦值 (assignment) 的名字，實際上他使用 &quot;<a href="patterns.html">模式</a>&quot; (pattern)。
我們在後面會使用模式。
對於我們的簡單情況，它已經夠用了：</p>
<pre><code class="language-rust">let foo = 5; // immutable.
let mut bar = 5; // mutable
</code></pre>
<p>噢，還有 <code>//</code> 會開始一段註解，一直到行末。
Rust 會忽略所有<a href="comments.html">註解</a> (comment) 內的東西。</p>
<p>所以現在我們知道 <code>let mut guess</code> 會宣告一個名為 <code>guess</code> 的可變變數綁定，但我們仍必須看看 <code>=</code> 另一邊所綁定的東西：<code>String::new()</code>。</p>
<p><code>String</code> 是一個字串型別，由標準函式庫提供。
一個<a href="https://doc.rust-lang.org/std/string/struct.String.html">字串</a>是一個以 UTF-8 編碼的可變長度的文字。</p>
<p>而 <code>::new()</code> 語法使用 <code>::</code> 是因為它是一個特定型別的 &quot;關聯函式&quot; (associated function)。
也就是說，它被關聯到 <code>String</code> 本身，而非特定的某個 <code>String</code> 的實體 (instance)。
一些語言稱之為 &quot;靜態方法&quot; (static method)。</p>
<p>此函式被稱為 <code>new()</code>，因為它建立一個新的、空的 <code>String</code>。
你可以在其他許多型別找到 <code>new()</code> 函式，因為它是建立某一些型別新值的通用名稱。</p>
<p>讓我們繼續下去：</p>
<pre><code class="language-rust,ignore">    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);
</code></pre>
<p>稍微有點多了！
一步一步來。
第一行有兩個部分。
第一部分是：</p>
<pre><code class="language-rust,ignore">io::stdin()
</code></pre>
<p>還記得在程式的第一行我們是怎麼 <code>use</code> 那個 <code>std::io</code> 的嗎？
我們現在正在呼叫它的關聯函式。
如果我們沒有 <code>use std::io</code> 的話，我們就必須把這行改成 <code>std::io::stdin()</code>。</p>
<p>這個特殊的函式會回傳一個終端機標準輸入的控制代碼 (handle)。
更具體的內容，可以參考 <a href="https://doc.rust-lang.org/std/io/struct.Stdin.html">std::io::Stdin</a>。</p>
<p>下一部份會使用這個控制代碼 (handle) 來取得使用者的輸入：</p>
<pre><code class="language-rust,ignore">.read_line(&amp;mut guess)
</code></pre>
<p>此處，我們呼叫控制代碼 (handle) 的 <a href="https://doc.rust-lang.org/std/io/struct.Stdin.html#method.read_line">read_line()</a> 方法。
<a href="method-syntax.html">方法</a> (method) 跟關聯函式很類似，但只能在特定型別的實體 (instance) 中取用，而不是從型別本身取用。
我們也會傳遞一個參數給 <code>read_line()</code>：<code>&amp;mut guess</code>。</p>
<p>還記得前面我們如何綁定 <code>guess</code> 嗎？
我們有提到它是可變的。
然而，<code>read_line</code> 不接受把 <code>String</code> 當作參數：它只接受 <code>&amp;mut String</code>。
Rust 有一個叫做<a href="references-and-borrowing.html">參照</a> (references) 的功能，它允許你將多個參照指向同一塊資料，這樣可以降低複製的動作。
參照是個複雜的功能，Rust 的主要賣點就是能安全、簡單的使用參照。
現在我們不需要知道太多細節。
我們只需知道參照與 <code>let</code> 綁定類似，它預設是不可變的。
因此，我們必須寫成 <code>&amp;mut guess</code> 而不是 <code>&amp;guess</code>。</p>
<p>為何 <code>read_line()</code> 需要字串的可變參照？
因為它的工作是從標準輸入取得使用者的輸入，然後放進字串中。
所以它將字串當作參數，用來存放輸入值，所以它必須是可變的。</p>
<p>但這行程式碼還沒結束。
雖然它只有一行，但它只是程式碼邏輯的第一部份。</p>
<pre><code class="language-rust,ignore">        .expect(&quot;Failed to read line&quot;);
</code></pre>
<p>當我們使用 <code>.foo()</code> 語法呼叫方法時，你能以空白或是開新的一行當開頭。
這可以幫助你把太長的一行程式碼切斷。
我們當然 <em>可以</em> 這樣做：</p>
<pre><code class="language-rust,ignore">    io::stdin().read_line(&amp;mut guess).expect(&quot;failed to read line&quot;);
</code></pre>
<p>但是這樣很難閱讀。
所以我們把它根據兩個方法的呼叫來切成兩行。
我們前面已經提過 <code>read_line()</code> 了，但 <code>expect()</code> 呢？
恩，我們說過 <code>read_line()</code> 會把使用者的輸入放入 <code>&amp;mut String</code> 參數中。
而它會回傳一個值：在此處是一個 <a href="https://doc.rust-lang.org/std/io/type.Result.html">io::Result</a>。
Rust 的標準函式庫中有許多叫做 <code>Result</code> 的型別：一般的 <a href="https://doc.rust-lang.org/std/result/enum.Result.html">Result</a> 與子函式庫的特別版本，像 <code>io::Result</code>。</p>
<p>這種 <code>Result</code> 型別的目的是把錯誤處理訊息編碼。
<code>Result</code> 型別的值與其他任何型別一樣，有定義它自己的方法。
此處的 <code>io::Result</code> 有 <a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.expect">expect() 方法</a>，可以用來取得呼叫它的方法的結果值，如果呼叫它的結果不成功，就會 <a href="error-handling.html">panic!</a> 並帶著你傳給它的訊息。
這樣的 <code>panic!</code> 會讓你的程式當機，並顯示出傳給它的訊息。</p>
<p>如果我們去掉這個方法的呼叫，我們的程式仍可以編譯成功，但是我們會看到警告訊息：</p>
<pre><code class="language-bash">$ cargo build
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
src/main.rs:10:5: 10:39 warning: unused result which must be used,
#[warn(unused_must_use)] on by default
src/main.rs:10     io::stdin().read_line(&amp;mut guess);
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</code></pre>
<p>Rust 會警告我們沒有使用 <code>Result</code> 的值。
這個警告來自 <code>io::Result</code> 的特殊註釋 (annotation)。
Rust 會試圖告訴你你沒有處理可能的錯誤。
處理錯誤的正確方式，應該是要撰寫錯誤處理的程式碼。
幸運的是，如果我們只想在有問題時就當機，我們可以直接使用這兩個方法。
而如果我們想要從錯誤中恢復正常，我們就必須做一些額外的事，我們留在之後的專案再說。</p>
<p>這個範例現在只剩下一行：</p>
<pre><code class="language-rust,ignore">    println!(&quot;You guessed: {}&quot;, guess);
}
</code></pre>
<p>這行印出我們所存的輸入值。
<code>{}</code> 是個 placeholder，因此我們傳遞 <code>guess</code> 作為參數。
如果我們有多個 <code>{}</code>，我們就需要傳遞多個參數：</p>
<pre><code class="language-rust">let x = 5;
let y = 10;

println!(&quot;x and y: {} and {}&quot;, x, y);
</code></pre>
<p>簡單吧。</p>
<p>總之，這就像是個程式導覽。
我們可以用 <code>cargo run</code> 執行我們的專案：</p>
<pre><code class="language-bash">$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
</code></pre>
<p>好吧！我們的第一部份完成了：我們可以從鍵盤取得輸入值，然後印出來。</p>
<h2>產生祕密數字</h2>
<p>接著，我們需要產生一個祕密數字。
Rust 的標準函式庫還沒有包含亂數功能。
但是 Rust 團隊提供了 <a href="https://crates.io/crates/rand">rand crate</a>。
這個 &quot;crate&quot; 是一包 Rust 程式碼。
我們會建置可以執行的 &quot;binary crate&quot;。
而 <code>rand</code> 是個 &quot;library crate&quot;，包含了可以被其他程式使用的程式碼。</p>
<p>使用外部的 crates 是 Cargo 的亮點。
在我們使用 <code>rand</code> 撰寫程式碼前，我們要修改 <code>Cargo.toml</code>。
打開它，然後加入以下幾行：</p>
<pre><code class="language-toml">[dependencies]

rand=&quot;0.3.0&quot;
</code></pre>
<p><code>Cargo.toml</code> 的 <code>[dependencies]</code> 一節與 <code>[package]</code> 類似：它之後的所有東西，直到下一節的開始，都是它的一部份。
Cargo 透過 dependencies 來瞭解你所需的外部 crates 及版本。
在這個例子中，我們特別指定版本 <code>0.3.0</code>，所以 Cargo 知道任何發行版都必須要跟這個版本相容。
Cargo 能瞭解 <a href="http://semver.org">Semantic Versioning</a> 的版本編碼方式，這是撰寫版本號碼的一種標準。
上面的版號實際上可以寫成 <code>^0.3.0</code>，代表 &quot;所有跟 0.3.0 相容的版本&quot;。
如果我們想要確實的使用 <code>0.3.0</code>，我們可以寫成 <code>rand=&quot;=0.3.0&quot;</code>（請注意兩個等號）。
而當我們想要使用最新版，我們可以使用 <code>*</code>。
我們也可以使用一個範圍內的版本。
<a href="http://doc.crates.io/crates-io.html">Cargo 的說明文件</a> 有更多細節。</p>
<p>現在，不修改任何程式碼，讓我們來建置專案：</p>
<pre><code class="language-bash">$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading rand v0.3.8
 Downloading libc v0.1.6
   Compiling libc v0.1.6
   Compiling rand v0.3.8
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
</code></pre>
<p>（當然，你可能會看到不同版本。）</p>
<p>出現很多新的輸出資訊！
現在我們有了外部的 dependency，Cargo 會從註冊表取得最新版，這個註冊表是 <a href="https://crates.io">Crates.io</a> 的複本。
Crates.io 是 Rust 生態系中，讓人發表他們的 Rust 開放原始碼專案給其他人使用的地方。</p>
<p>更新了註冊表之後，Cargo 會檢查我們的 <code>[dependencies]</code> 然後下載任何我們還沒有的東西。
在這邊的例子中，雖然說我們只想要相依 <code>rand</code>，但我們仍需取得 <code>libc</code> 的複本。
這是因為 <code>rand</code> 相依於 <code>libc</code> 才能運作。
下載它們之後，Cargo 會編譯他們，然後編譯我們的專案。</p>
<p>如果我們再次執行 <code>cargo build</code>，我們將會看到不同的輸出結果：</p>
<pre><code class="language-bash">$ cargo build
</code></pre>
<p>沒錯，沒有輸出！
Cargo 知道我們的專案已經建置好了，而且所有的 dependencies 也建置好了，所以他沒有任何理由再做一遍。
因為沒事情做，它就簡單地結束了。
如果我們再次開啟 <code>src/main.rs</code>，做一些簡單的修改，然後存檔再試一次，我們只會看到一行：</p>
<pre><code class="language-bash">$ cargo build
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
</code></pre>
<p>所以，我們告訴 Cargo 想要任何 <code>rand</code> 的 <code>0.3.x</code> 版，所以它抓了當下的最新版 <code>v0.3.8</code>。
但如果下週，一個帶有重要問題修正的 <code>v0.3.9</code> 版出現之後會發生什麼事情？
雖然取得問題的修正很重要，但如果 <code>0.3.9</code> 包含有會弄壞我們程式碼的 regression 呢？</p>
<p>這個問題的答案是專案中的 <code>Cargo.lock</code> 檔。
當你第一次建置專案時，Cargo 會檢查所有符合你的條件的版本，然後寫入 <code>Cargo.lock</code> 檔。
未來當你再次建置你的專案時，Cargo 會視 <code>Cargo.lock</code> 檔案是否已經存在，然後使用裡面的特定版本，而非再次重新尋找版本。
這讓你有一個可以重複建置的環境。
也就是說，我們會停在 <code>0.3.8</code> 直到我們確定要升級，這也對任何我們與之分享程式碼的人有效，感謝 lock 檔。</p>
<p>當我們 <em>真的</em> 想要用 <code>0.3.9</code> 時怎麼辦？
Cargo 有另一個指令 <code>update</code>，代表著 &quot;忽略 lock 檔，尋找所有符合指定條件的最新版。如果運行成功，把這些版本寫入 lock 檔&quot;。
但是，預設 Cargo 只會尋找大於 <code>0.3.0</code> 及小於 <code>0.4.0</code> 的版本。
如果我們想要換到 <code>0.4.x</code>，我們必須直接更新 <code>Cargo.toml</code>。
當我們這樣做時，下一次 <code>cargo build</code> Cargo 將會更新索引並重新評估 <code>rand</code> 的需求。</p>
<p>關於 <a href="http://doc.crates.io">Cargo</a> 和其<a href="http://doc.crates.io/crates-io.html">生態系</a>還有很多可以說，但是現在，這就是我們所需知道的全部了。
Cargo 讓重新使用函式庫變得很簡單，讓 Rustaceans 易於寫出由許多子套件 (sub-packages) 組成的小專案。</p>
<p>接著讓我們真正的 <em>用用看</em> <code>rand</code> 吧。
這是我們的下一步：</p>
<pre><code class="language-rust,ignore">extern crate rand;

use std::io;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;The secret number is: {}&quot;, secret_number);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;failed to read line&quot;);

    println!(&quot;You guessed: {}&quot;, guess);
}
</code></pre>
<p>第一步是修改第一行。
現在改成 <code>extern crate rand</code> 了。
因為在 <code>[dependencies]</code> 中我們宣告了 <code>rand</code>，我們可以使用 <code>extern crate</code> 讓 Rust 知道我們要使用它。
這也等同於 <code>use rand;</code>，所以我們可以透過 <code>rand::</code> 前綴詞來使用任何 <code>rand</code> crate 內的東西。</p>
<p>接著，我們加入另一行 <code>use</code>：<code>use rand::Rng</code>。
我們即將使用一個方法 (method)，這個方法需要 <code>Rng</code> 在有效範圍 (scope) 中才能運作。
基本的概念是：方法被定義在某些被稱為 &quot;traits&quot; 的東西上，trait 必須要在有效範圍中，方法才能運作。
更多細節可以閱讀 <a href="traits.html">traits</a> 一節。</p>
<p>我們還加入了另外兩行在中間：</p>
<pre><code class="language-rust,ignore">    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;The secret number is: {}&quot;, secret_number);
</code></pre>
<p>我們使用 <code>rand::thread_rng()</code> 函式取得隨機數字產生器的複本，這個複本位於我們正在執行的特定<a href="concurrency.html">執行緒</a> (thread) 之上。
因為我們前面已經 <code>use rand::Rng</code>，所以 <code>gen_rang()</code> 方法可以使用。
這個方法需要兩個參數，然後會產生一個在兩個參數之間的數字。
結果包含了下限，但不包含上限，所以我們需要傳遞 <code>1</code> 和 <code>101</code> 去取得 1 到 100 範圍內的數字。</p>
<p>第二行會印出祕密數字。
當我們正在開發程式時這很有用，讓我們可以簡單的測試一下。
不過我們在最後會刪掉它。
沒什麼遊戲會在一開始就印出答案的！</p>
<p>試著執行我們的新程式幾次：</p>
<pre><code class="language-bash">$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4
$ cargo run
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
</code></pre>
<p>太棒了！
接著：就要開始比較我們的猜測值和祕密數字。</p>
<h2>比較猜測值</h2>
<p>現在，我們拿到了使用者的輸入值，讓我們來比較猜測值和祕密數字。
以下是我們的下一步，雖然這還沒真的編譯過：</p>
<pre><code class="language-rust,ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;The secret number is: {}&quot;, secret_number);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;failed to read line&quot;);

    println!(&quot;You guessed: {}&quot;, guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less    =&gt; println!(&quot;Too small!&quot;),
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
        Ordering::Equal   =&gt; println!(&quot;You win!&quot;),
    }
}
</code></pre>
<p>這裡有些新東西。
首先是另一個 <code>use</code>。
我們用了稱為 <code>std::cmp::Ordering</code> 的型別到有效範圍中。
然後底下有五行程式碼用到它：</p>
<pre><code class="language-rust,ignore">match guess.cmp(&amp;secret_number) {
    Ordering::Less    =&gt; println!(&quot;Too small!&quot;),
    Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
    Ordering::Equal   =&gt; println!(&quot;You win!&quot;),
}
</code></pre>
<p><code>cmp()</code> 方法可以被任何能用來比較的東西呼叫，且它會要求傳入你想比較的東西的參照。
它回傳我們前面 <code>use</code> 的 <code>Ordering</code> 型別。
我們使用 <a href="match.html">match</a> 陳述去判定它實際上是哪種 <code>Ordering</code>。
<code>Ordering</code> 是個 <a href="enums.html">enum</a>，是枚舉 (enumeration) 的簡寫，枚舉看起來會有點像這樣：</p>
<pre><code class="language-rust">enum Foo {
    Bar,
    Baz,
}
</code></pre>
<p>這裡定義了任何一個 <code>Foo</code>，要不是 <code>Foo::Bar</code>，就會是 <code>Foo::Baz</code>。
我們使用 <code>::</code> 來表示特定 <code>enum</code> 變體的命名空間 (namespace)。</p>
<p><a href="https://doc.rust-lang.org/std/cmp/enum.Ordering.html">Ordering</a> <code>enum</code> 有三個可能的變體：<code>Less</code>、<code>Equal</code>、及 <code>Greater</code>。
<code>match</code> 陳述式取得型別的值，讓你能為每個可能的值建立一條執行的分支。
因為 <code>Ordering</code> 有三種型別，我們就會有三個分支：</p>
<pre><code class="language-rust,ignore">match guess.cmp(&amp;secret_number) {
    Ordering::Less    =&gt; println!(&quot;Too small!&quot;),
    Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
    Ordering::Equal   =&gt; println!(&quot;You win!&quot;),
}
</code></pre>
<p>如果它是 <code>Less</code>，我們印出 <code>Too small!</code>，如果是 <code>Greater</code> 則印出 <code>Too big!</code>，如果是 <code>Equal</code> 就印出 <code>You win!</code>。
<code>match</code> 非常有用，而且在 Rust 中常會用到。</p>
<p>雖然我確實提到過我們還不能編譯成功。
讓我們還是試試看：</p>
<pre><code class="language-bash">$ cargo build
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
src/main.rs:28:21: 28:35 error: mismatched types:
 expected `&amp;collections::string::String`,
    found `&amp;_`
(expected struct `collections::string::String`,
    found integral variable) [E0308]
src/main.rs:28     match guess.cmp(&amp;secret_number) {
                                   ^~~~~~~~~~~~~~
error: aborting due to previous error
Could not compile `guessing_game`.
</code></pre>
<p>噢！這裡有個大問題。
它的核心問題是我們有 &quot;無法匹配的型別&quot; (mismatched types)。
Rust 有個強大的靜態型別系統 (static type system)。
但是，它也有型別推斷 (type inference) 系統。
當我們寫到 <code>let guess = String::new()</code> 時，Rust 會推斷 <code>guess</code> 應該是 <code>String</code>，因此不需要我們特別寫出型別。
而我們的 <code>secret_number</code> 則有多種可能的型別，它們都可以存入 1 到 100 的值，有：32 位元整數 <code>i32</code>、非帶號 (unsigned) 32 位元整數 <code>u32</code>、64 位元整數 <code>i64</code> 或其他等等。
目前這些都不重要，所以 Rust 預設為 <code>i32</code>。
然而，Rust 不知道怎麼去比對 <code>guess</code> 與 <code>secret_number</code>。
它們必須是相同型別。
最終，為了可以比較，我們想要把輸入的 <code>String</code> 轉換為一個真正的數字型別。
我們可以用額外的兩行做到。
以下是我們的新程式：</p>
<pre><code class="language-rust,ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;The secret number is: {}&quot;, secret_number);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;failed to read line&quot;);

    let guess: u32 = guess.trim().parse()
        .expect(&quot;Please type a number!&quot;);

    println!(&quot;You guessed: {}&quot;, guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less    =&gt; println!(&quot;Too small!&quot;),
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
        Ordering::Equal   =&gt; println!(&quot;You win!&quot;),
    }
}
</code></pre>
<p>新加的兩行：</p>
<pre><code class="language-rust,ignore">    let guess: u32 = guess.trim().parse()
        .expect(&quot;Please type a number!&quot;);
</code></pre>
<p>等等，我想我們已經有 <code>guess</code> 了吧？
沒錯，但 Rust 允許我們用新的 <code>guess</code> 去 &quot;遮蔽&quot; (shadow) 前一個。
一開始 <code>guess</code> 是 <code>String</code>，但我們希望能轉換為 <code>u32</code>，在類似這樣的情況下我們會很常用到。
遮蔽讓我們可以重複利用 <code>guess</code> 的命名，而不是強迫我們想出兩個獨特的命名，像是 <code>guess_str</code> 和 <code>guess</code>，或其他的名稱。</p>
<p>我們把 <code>guess</code> 綁定在我們前面所寫的表達式上：</p>
<pre><code class="language-rust,ignore">guess.trim().parse()
</code></pre>
<p>這邊的 <code>guess</code> 參考到存著輸入值的舊 <code>guess</code>。
而 <code>String</code> 中的 <code>trim()</code> 方法則會去除任何字串開頭結尾的空白。
這很重要，因為我們必須按下 &quot;Return&quot; 按鍵去符合 <code>read_line()</code> 的輸入條件。
也就是說如果我們輸入 <code>5</code> 然後按下 Return，那 <code>guess</code> 就會是：<code>5\n</code>。
<code>\n</code> 代表 &quot;新的一行&quot; (newline)、enter 鍵。
<code>trim()</code> 會去除這些東西，只留下我們要的字串 <code>5</code>。
而<a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse">字串的 parse() 方法</a>則會把字串分析為數字。
因為它可以被分析為很多種數字型別，我們必須給 Rust 我們確切想要的數字型別的提示。
因次我們給它 <code>let guess: u32</code>。
<code>guess</code> 後面的分號（<code>:</code>）告訴 Rust 我們要註釋它的型別。
<code>u32</code> 是沒有帶正負號的 32 位元整數。
Rust 有<a href="primitive-types.html#%E6%95%B8%E5%AD%97%E5%9E%8B%E5%88%A5">許多內建的數字型別</a>，我們選了 <code>u32</code>。
對於不大的正整數來說，它是個好選擇。</p>
<p>跟 <code>read_line()</code> 一樣，我們呼叫 <code>parse()</code> 時可能會發生錯誤。
如果我們的字串包含了 <code>A👍%</code> 怎麼辦？
我們可無法把它轉換為數字。
與之前替 <code>read_line()</code> 所做的事一樣，我們可以使用 <code>expect()</code> 方法，讓它出錯時當機。</p>
<p>讓我們試試我們的程式！</p>
<pre><code class="language-bash">$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
</code></pre>
<p>不錯！
你可以看到我在猜測值前面加入空白，它仍可以認出我猜的是 76。
多執行程式幾次，然後驗證看看，猜正確的數字，並猜一個比較小的數字。</p>
<p>現在我們的遊戲大致上能運作了，但是我們只能猜一次。
讓我們加入迴圈 (loops) 來修改它。</p>
<h2>迴圈</h2>
<p>關鍵字 <code>loop</code> 會給我們一個無限迴圈。
讓我們加上它：</p>
<pre><code class="language-rust,ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;The secret number is: {}&quot;, secret_number);

    loop {
        println!(&quot;Please input your guess.&quot;);

        let mut guess = String::new();

        io::stdin().read_line(&amp;mut guess)
            .expect(&quot;failed to read line&quot;);

        let guess: u32 = guess.trim().parse()
            .expect(&quot;Please type a number!&quot;);

        println!(&quot;You guessed: {}&quot;, guess);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less    =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal   =&gt; println!(&quot;You win!&quot;),
        }
    }
}
</code></pre>
<p>然後試試看。
等等，我們不是加了個無限迴圈嗎？
沒錯，還記得我們討論過的 <code>parse()</code> 嗎？
如果我們輸入一個不是數字的答案，我們就會 <code>panic!</code> 然後結束。
看著：</p>
<pre><code class="language-bash">$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit
thread '&lt;main&gt;' panicked at 'Please type a number!'
</code></pre>
<p>哈！
跟任何其他不是數字的輸入一樣，<code>quit</code> 真的退出了。
好吧，這至少是個還可以的做法。
接著，讓我們改成能在贏了的時候真的好好退出：</p>
<pre><code class="language-rust,ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;The secret number is: {}&quot;, secret_number);

    loop {
        println!(&quot;Please input your guess.&quot;);

        let mut guess = String::new();

        io::stdin().read_line(&amp;mut guess)
            .expect(&quot;failed to read line&quot;);

        let guess: u32 = guess.trim().parse()
            .expect(&quot;Please type a number!&quot;);

        println!(&quot;You guessed: {}&quot;, guess);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less    =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal   =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p>透過在 <code>You win!</code> 之後加入 <code>break</code>，我們可以在贏了之後離開迴圈。
因為它同時是 <code>main()</code> 的最後一部份，所以離開迴圈也代表著退出程式。
我們剩下最後一點需要修改：當輸入一個不是數字的輸入，我們不想退出程式，我們要忽略它。
我們可以像以下這樣做：</p>
<pre><code class="language-rust,ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;The secret number is: {}&quot;, secret_number);

    loop {
        println!(&quot;Please input your guess.&quot;);

        let mut guess = String::new();

        io::stdin().read_line(&amp;mut guess)
            .expect(&quot;failed to read line&quot;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;You guessed: {}&quot;, guess);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less    =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal   =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p>這是我們所修改的部分：</p>
<pre><code class="language-rust,ignore">let guess: u32 = match guess.trim().parse() {
    Ok(num) =&gt; num,
    Err(_) =&gt; continue,
};
</code></pre>
<p>把 <code>expect()</code> 改為 <code>match</code> 陳述的方式，大致上就是如何把 &quot;錯誤時當機&quot; 改為 &quot;實際處理錯誤&quot; 的方法。
<code>parse()</code> 回傳的 <code>Result</code> 是個跟 <code>Ordering</code> 類似的 <code>enum</code>，但是這裡的變體跟資料有關：<code>Ok</code> 代表成功，<code>Err</code> 則是錯誤。
它們個別包含更多的資訊：成功的分析出整數，或是一個錯誤型別。
在本例中，當我們 <code>match</code> 到 <code>Ok(num)</code> 時，會把 <code>Ok</code> 內的值設給 <code>num</code> 這個名稱，然後在右邊直接回傳它。
在 <code>Err</code> 的情況，我們不在意發生了什麼錯誤，所以我們使用 <code>_</code> 沒有取名。
這樣會忽略錯誤，接著 <code>continue</code> 讓我們可以繼續 <code>loop</code> 的下一次疊代 (iteration)。</p>
<p>現在應該弄好了！
讓我們試試看：</p>
<pre><code class="language-bash">$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
</code></pre>
<p>太棒了！
剩下最後一個小修改，我們就完成了猜數字遊戲。
你能猜到是什麼嗎？
沒錯，我們不希望印出祕密數字。
在測試時這樣很好，但是它會毀掉遊戲。
這是最終的程式碼：</p>
<pre><code class="language-rust,ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    loop {
        println!(&quot;Please input your guess.&quot;);

        let mut guess = String::new();

        io::stdin().read_line(&amp;mut guess)
            .expect(&quot;failed to read line&quot;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;You guessed: {}&quot;, guess);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less    =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal   =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<h2>完成！</h2>
<p>此時此刻，你成功的建置了猜謎遊戲！
恭喜你！</p>
<p>這第一個專案告訴你不少東西：<code>let</code>、<code>match</code>、方法 (methods)、關聯函式 (associated functions)、使用外部的 crates、等等。
我們的下個專案會告訴你更多東西。</p>
<blockquote>
<p>譯註：實作 <code>dining-philosophers</code> 專案的章節已經被移除了，所以後續會接到語法的部分。</p>
</blockquote>
<blockquote>
<p><em>commit edd5f33</em></p>
</blockquote>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="getting-started.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="syntax-and-semantics.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="getting-started.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="syntax-and-semantics.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
