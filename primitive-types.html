<!DOCTYPE HTML>
<html lang="zh-Hant">
    <head>
        <meta charset="UTF-8">
        <title>Rust 程式語言 正體中文版</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The Rust Programming Language">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

		<style>
            @import url(http://fonts.googleapis.com/earlyaccess/cwtexhei.css);
        </style>
        <link rel="stylesheet" href="book.css">
        <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body>
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="README.html"><strong>1.</strong> 簡介</a></li><li><a href="getting-started.html"><strong>2.</strong> 準備</a></li><li><a href="guessing-game.html"><strong>3.</strong> 教學: 猜數字遊戲</a></li><li><a href="syntax-and-semantics.html"><strong>4.</strong> 語法及語意</a></li><li><ul class="section"><li><a href="variable-bindings.html"><strong>4.1.</strong> 變數綁定</a></li><li><a href="functions.html"><strong>4.2.</strong> 函式</a></li><li><a href="primitive-types.html" class="active"><strong>4.3.</strong> 基本型別</a></li><li><a href="comments.html"><strong>4.4.</strong> 註解</a></li><li><a href="if.html"><strong>4.5.</strong> if</a></li><li><a href="loops.html"><strong>4.6.</strong> 迴圈</a></li><li><a href="ownership.html"><strong>4.7.</strong> 所有權</a></li><li><a href="references-and-borrowing.html"><strong>4.8.</strong> 參照與借用</a></li><li><a href="lifetimes.html"><strong>4.9.</strong> 生命週期</a></li><li><a href="mutability.html"><strong>4.10.</strong> 可變性</a></li><li><a href="structs.html"><strong>4.11.</strong> 結構體</a></li><li><a href="enums.html"><strong>4.12.</strong> 枚舉</a></li><li><a href="match.html"><strong>4.13.</strong> Match</a></li><li><a href="patterns.html"><strong>4.14.</strong> 模式</a></li><li><a href="method-syntax.html"><strong>4.15.</strong> Method Syntax</a></li><li><a href="vectors.html"><strong>4.16.</strong> Vectors</a></li><li><a href="strings.html"><strong>4.17.</strong> Strings</a></li><li><a href="generics.html"><strong>4.18.</strong> Generics</a></li><li><a href="traits.html"><strong>4.19.</strong> Traits</a></li><li><a href="drop.html"><strong>4.20.</strong> Drop</a></li><li><a href="if-let.html"><strong>4.21.</strong> if let</a></li><li><a href="trait-objects.html"><strong>4.22.</strong> Trait Objects</a></li><li><a href="closures.html"><strong>4.23.</strong> Closures</a></li><li><a href="ufcs.html"><strong>4.24.</strong> Universal Function Call Syntax</a></li><li><a href="crates-and-modules.html"><strong>4.25.</strong> Crates and Modules</a></li><li><a href="const-and-static.html"><strong>4.26.</strong> <code>const</code> and <code>static</code></a></li><li><a href="attributes.html"><strong>4.27.</strong> Attributes</a></li><li><a href="type-aliases.html"><strong>4.28.</strong> <code>type</code> aliases</a></li><li><a href="casting-between-types.html"><strong>4.29.</strong> Casting between types</a></li><li><a href="associated-types.html"><strong>4.30.</strong> Associated Types</a></li><li><a href="unsized-types.html"><strong>4.31.</strong> Unsized Types</a></li><li><a href="operators-and-overloading.html"><strong>4.32.</strong> Operators and Overloading</a></li><li><a href="deref-coercions.html"><strong>4.33.</strong> Deref coercions</a></li><li><a href="macros.html"><strong>4.34.</strong> Macros</a></li><li><a href="raw-pointers.html"><strong>4.35.</strong> Raw Pointers</a></li><li><a href="unsafe.html"><strong>4.36.</strong> <code>unsafe</code></a></li></ul></li><li><a href="effective-rust.html"><strong>5.</strong> Effective Rust</a></li><li><ul class="section"><li><a href="the-stack-and-the-heap.html"><strong>5.1.</strong> The Stack and the Heap</a></li><li><a href="testing.html"><strong>5.2.</strong> Testing</a></li><li><a href="conditional-compilation.html"><strong>5.3.</strong> Conditional Compilation</a></li><li><a href="documentation.html"><strong>5.4.</strong> Documentation</a></li><li><a href="iterators.html"><strong>5.5.</strong> Iterators</a></li><li><a href="concurrency.html"><strong>5.6.</strong> Concurrency</a></li><li><a href="error-handling.html"><strong>5.7.</strong> Error Handling</a></li><li><a href="choosing-your-guarantees.html"><strong>5.8.</strong> Choosing your Guarantees</a></li><li><a href="ffi.html"><strong>5.9.</strong> FFI</a></li><li><a href="borrow-and-asref.html"><strong>5.10.</strong> Borrow and AsRef</a></li><li><a href="release-channels.html"><strong>5.11.</strong> Release Channels</a></li><li><a href="using-rust-without-the-standard-library.html"><strong>5.12.</strong> Using Rust without the standard library</a></li></ul></li><li><a href="nightly-rust.html"><strong>6.</strong> Nightly Rust</a></li><li><ul class="section"><li><a href="compiler-plugins.html"><strong>6.1.</strong> Compiler Plugins</a></li><li><a href="inline-assembly.html"><strong>6.2.</strong> Inline Assembly</a></li><li><a href="no-stdlib.html"><strong>6.3.</strong> No stdlib</a></li><li><a href="intrinsics.html"><strong>6.4.</strong> Intrinsics</a></li><li><a href="lang-items.html"><strong>6.5.</strong> Lang items</a></li><li><a href="advanced-linking.html"><strong>6.6.</strong> Advanced linking</a></li><li><a href="benchmark-tests.html"><strong>6.7.</strong> Benchmark Tests</a></li><li><a href="box-syntax-and-patterns.html"><strong>6.8.</strong> Box Syntax and Patterns</a></li><li><a href="slice-patterns.html"><strong>6.9.</strong> Slice Patterns</a></li><li><a href="associated-constants.html"><strong>6.10.</strong> Associated Constants</a></li><li><a href="custom-allocators.html"><strong>6.11.</strong> Custom Allocators</a></li></ul></li><li><a href="glossary.html"><strong>7.</strong> 詞彙表</a></li><li><a href="syntax-index.html"><strong>8.</strong> 語法索引</a></li><li><a href="bibliography.html"><strong>9.</strong> 參考文獻</a></li><li><a href="MappingTable.html"><strong>10.</strong> 中英文字彙對照表</a></li><li><a href="CONTRIBUTORS.html"><strong>11.</strong> 翻譯貢獻名單</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">Rust 程式語言 正體中文版</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <h1>基本型別</h1>
<p>Rust 語言有許多被認為是 &quot;基本&quot; (primitive) 的型別。
這代表他們是內建在語言內的。
Rust 的標準函式庫也提供了許多基於這些基本型別的有用型別，它們也是基本型別。</p>
<h2>布林 (Booleans)</h2>
<p>Rust 內建布林型別，叫做 <code>bool</code>。
他有兩種值，<code>true</code> 和 <code>false</code>：</p>
<pre><code class="language-rust">let x = true;

let y: bool = false;
</code></pre>
<p>布林通常用在 <a href="if.html">if 條件運算式</a>。</p>
<p>你可以在<a href="https://doc.rust-lang.org/std/primitive.bool.html">標準函式庫文件</a>中找到更多關於 <code>bool</code> 的文件。</p>
<h2><code>char</code></h2>
<p><code>char</code> 型別代表一個 Unicode 值。
你可以以單引號（<code>'</code>）建立 <code>char</code>：</p>
<pre><code class="language-rust">let x = 'x';
let two_hearts = '💕';
</code></pre>
<p>不像其他語言，這代表 Rust 的 <code>char</code> 並非一個位元組，而是四個。</p>
<p>你可以在<a href="https://doc.rust-lang.org/std/primitive.char.html">標準函式庫文件</a>中找到更多關於 <code>char</code> 的文件。</p>
<h2>數字型別</h2>
<p>Rust 有許多數字型別，分為一些不同類型：帶號 (signed) 和非帶號 (unsigned)，固定長度和可變長度，浮點數和整數。</p>
<p>這些型別包含兩部分：類型和大小。
例如，<code>u16</code> 是一個 16 位元大小的非帶號型別。
更多位元能讓你有更大的數字。</p>
<p>如果數字在字面上沒有其他東西可以推測他的型別，它會使用預設型別：</p>
<pre><code class="language-rust">let x = 42; // x has type i32

let y = 1.0; // y has type f64
</code></pre>
<p>這裡有一份不同數字型別的清單，以及它們在標準函式庫中的文件連結：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/primitive.i8.html">i8</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.i16.html">i16</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.i32.html">i32</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.i64.html">i64</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.u8.html">u8</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.u16.html">u16</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.u32.html">u32</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.u64.html">u64</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.isize.html">isize</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.usize.html">usize</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.f32.html">f32</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.f64.html">f64</a></li>
</ul>
<p>讓我們依照分類走一輪吧：</p>
<h3>帶號 (Signed) 及非帶號 (Unsigned)</h3>
<p>整數型別有兩種變形：帶號跟非帶號。
要了解差異之處，讓我們試想有一個 4 位元大小的數字。
如果是帶號整數，4 位元可以讓你儲存 <code>-8</code> 到 <code>+7</code> 的數字。
代號數字使用 &quot;二補數表示法&quot; (two's complement)。
一個非帶號的 4 位元數字因為不需要儲存負號，所以可以儲存 <code>0</code> 到 <code>+15</code> 的數字。</p>
<p>非帶號型別使用 <code>u</code> 作為分類，而帶號型別使用 <code>i</code>。
<code>i</code> 代表 &quot;integer&quot;。
所以 <code>u8</code> 代表一個 8 位元的非代號數字，而 <code>i8</code> 代表 8 位元的帶號數字。</p>
<h3>固定大小型別</h3>
<p>固定大小型別的表現方式有一些特定數量的位元。
有效的位元大小有 <code>8</code>、<code>16</code>、<code>32</code>、<code>64</code>。
所以 <code>u32</code> 是一個非帶號的 32 位元整數，而 <code>i64</code> 是一個帶號的 64 位元整數。</p>
<h3>可變大小型別</h3>
<p>Rust 也有提供一些大小依賴於底層機器的指標大小的型別。
這些型別的分類是 &quot;size&quot;，且分為帶號跟非帶號。
他分為兩類：<code>isize</code> 和 <code>usize</code>。</p>
<h3>浮點數型別</h3>
<p>Rust 也有兩種浮點數：<code>f32</code> 與 <code>f64</code>。
他們對應到 IEEE-754 的單精準度和雙精準度浮點數。</p>
<h2>陣列 (Arrays)</h2>
<p>跟很多程式語言一樣，Rust 有用來表現一組事物的清單型別。
最基本的就是 <em>陣列</em> (array)，一個固定大小、有相同型別的元素清單。
陣列預設是不可變的 (immutable)。</p>
<pre><code class="language-rust">let a = [1, 2, 3]; // a: [i32; 3]
let mut m = [1, 2, 3]; // m: [i32; 3]
</code></pre>
<p>陣列的型別是 <code>[T; N]</code>。
我們將在<a href="generics.html">泛型的章節</a>提到 <code>T</code> 標記。
<code>N</code> 是一個編譯期的常數，代表陣列的長度。</p>
<p>有一個可以初始化陣列中所有元素為同一個值的簡寫。
在以下範例，所有 <code>a</code> 中的元素將被初始化為 <code>0</code>：</p>
<pre><code class="language-rust">let a = [0; 20]; // a: [i32; 20]
</code></pre>
<p>你可以透過 <code>a.len()</code> 取得 <code>a</code> 陣列中元素的個數：</p>
<pre><code class="language-rust">let a = [1, 2, 3];

println!(&quot;a has {} elements&quot;, a.len());
</code></pre>
<p>你也可以使用 <em>下標</em> (subscript) 的標記方式存取陣列中特定元素：</p>
<blockquote>
<p>譯註：此處的 <em>下標</em> 應指 <code>[n]</code> 這個標記方式。</p>
</blockquote>
<pre><code class="language-rust">let names = [&quot;Graydon&quot;, &quot;Brian&quot;, &quot;Niko&quot;]; // names: [&amp;str; 3]

println!(&quot;The second name is: {}&quot;, names[1]);
</code></pre>
<p>與其他大多數程式語言一樣，下標從零開始，所以第一個元素名稱是 <code>names[0]</code>，第二個名稱是 <code>names[1]</code>。
上述範例會印出 <code>The second name is: Brian</code>。
如果你嘗試使用超出陣列的下標，你會得到錯誤訊息：陣列存取會在執行期做邊界檢查。
在其他系統程式語言中，這種不當存取是許多程式錯誤 (bug) 的根源。</p>
<p>你可以在<a href="https://doc.rust-lang.org/std/primitive.array.html">標準函式庫文件</a>中找到更多關於 <code>array</code> 的文件。</p>
<h2>Slices</h2>
<p>一個 &quot;slice&quot; 是一個其他資料結構的參照（或 &quot;視圖&quot;）。
它允許安全、有效的存取陣列的一部份而不用複製陣列。
例如，你可能只想要參考讀到記憶體中的檔案中的某一行。
本質上，一個 &quot;slice&quot; 不是直接建立的，而要從一個已經存在的變數綁定中建立。
Slices 會定義長度，它可以是可變 (mutable) 或不可變 (immutable)。</p>
<p>從內部來看，slices 像是一個指向資料開頭的指標，和它的長度。</p>
<h3>Slicing 語法</h3>
<p>你可以使用 <code>&amp;</code> 和 <code>[]</code> 的組合去從許多資料結構建立 slice。
<code>&amp;</code> 說明了 slices 跟<a href="references-and-borrowing.html">參照</a>很類似，我們會在本節的後面說到細節。
<code>[]</code> 帶有範圍的資訊，讓你定義 slice 的長度。</p>
<pre><code class="language-rust">let a = [0, 1, 2, 3, 4];
let complete = &amp;a[..]; // A slice containing all of the elements in a
let middle = &amp;a[1..4]; // A slice of a: only the elements 1, 2, and 3
</code></pre>
<p>Slices 的型別是 <code>&amp;[T]</code>。
我們將會在<a href="generics.html">泛型</a>談到 <code>T</code>。</p>
<p>你可以在<a href="https://doc.rust-lang.org/std/primitive.slice.html">標準函式庫文件</a>中找到更多關於 slices 的文件。</p>
<h2><code>str</code></h2>
<p>Rust 的 <code>str</code> 型別是最基本的字串型別。
跟<a href="unsized-types.html">動態大小型別</a>，它本身不是很有用，但當它放在參照之後就很有用了，像是 <code>$str</code>。
當我們談到<a href="strings.html">字串</a>和<a href="references-and-borrowing.html">參照</a>的時候再來細說。</p>
<p>你可以在<a href="https://doc.rust-lang.org/std/primitive.str.html">標準函式庫文件</a>中找到更多關於 <code>str</code> 的文件。</p>
<h2>多元組 (Tuples)</h2>
<p>一個多元組 (tuple) 是一組固定大小的有序 (ordered) 清單。
就像：</p>
<pre><code class="language-rust">let x = (1, &quot;hello&quot;);
</code></pre>
<p>這是長度為 2 的多元組，由括弧和逗號組成。
以下是同樣的程式碼，但是多了型別註釋：</p>
<pre><code class="language-rust">let x: (i32, &amp;str) = (1, &quot;hello&quot;);
</code></pre>
<p>如你所見，多元組的型別與多元組很像，只是各個位置是型別名稱而不是數值。
心細的讀者會注意到多元組是異質的 (heterogeneous)：我們在一個多元組中同時有 <code>i32</code> 與 <code>&amp;str</code>。
在系統程式語言中，字串會比其他語言複雜一點。
現在，把 <code>&amp;str</code> 當作 <em>字串 slice</em>，我們很快就會說到。</p>
<p>當兩個多元組有相同的型別和<a href="glossary.html#%E5%85%83%E6%95%B8%20(Arity)">元數</a> (arity) 時，你可以把一個多元組賦值給另一個。
相同長度的多元組有著相同的元數。</p>
<pre><code class="language-rust">let mut x = (1, 2); // x: (i32, i32)
let y = (2, 3); // y: (i32, i32)

x = y;
</code></pre>
<p>你可以透過 <em>destructuring let</em> 存取多元組的欄位。
以下是範例：</p>
<pre><code class="language-rust">let (x, y, z) = (1, 2, 3);

println!(&quot;x is {}&quot;, x);
</code></pre>
<p>還記得<a href="variable-bindings.html">之前</a>當我提到 <code>let</code> 陳述式的左邊遠比賦值綁定還強大嗎？
這就是了。
我們可以放一個模式 (pattern) 在 <code>let</code> 的左邊，然後如果它跟右邊相符，我們就可以一次賦值多個綁定。
在這情形下，<code>let</code> &quot;解構&quot; 或 &quot;拆開&quot; 了多元組，然後賦值到三個綁定上。</p>
<p>這樣的模式非常強大，我們將會在後面一直看到。</p>
<p>在括號中只有一個值時，在值後面加上逗號，可以消歧義確定它是一個單元素的多元組：</p>
<pre><code class="language-rust">(0,); // single-element tuple
(0); // zero in parentheses
</code></pre>
<h3>多元組索引 (Tuple Indexing)</h3>
<p>你也可以用索引語法去存取多元組的欄位：</p>
<pre><code class="language-rust">let tuple = (1, 2, 3);

let x = tuple.0;
let y = tuple.1;
let z = tuple.2;

println!(&quot;x is {}&quot;, x);
</code></pre>
<p>就像陣列的索引，它從零開始，但是不像陣列所以，它使用 <code>.</code> 而不是 <code>[]</code>。</p>
<p>你可以在<a href="https://doc.rust-lang.org/std/primitive.tuple.html">標準函式庫文件</a>中找到更多關於多元組的文件。</p>
<h2>函式</h2>
<p>函式也有型別！
它們像這樣：</p>
<pre><code class="language-rust">fn foo(x: i32) -&gt; i32 { x }

let x: fn(i32) -&gt; i32 = foo;
</code></pre>
<p>在這個例子中，<code>x</code> 是 &quot;函式指標&quot; 指向一個有 <code>i32</code> 參數並回傳 <code>i32</code> 的函式。</p>
<blockquote>
<p><em>commit 228afd7</em></p>
</blockquote>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="functions.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="comments.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="functions.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="comments.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
