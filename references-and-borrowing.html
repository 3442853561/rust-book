<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Rust 程式語言 正體中文版</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The Rust Programming Language">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body>
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="README.html"><strong>1.</strong> 簡介</a></li><li><a href="getting-started.html"><strong>2.</strong> 準備</a></li><li><a href="guessing-game.html"><strong>3.</strong> 教學: 猜謎遊戲</a></li><li><a href="syntax-and-semantics.html"><strong>4.</strong> 語法及語意</a></li><li><ul class="section"><li><a href="variable-bindings.html"><strong>4.1.</strong> 變數綁定</a></li><li><a href="functions.html"><strong>4.2.</strong> 函式</a></li><li><a href="primitive-types.html"><strong>4.3.</strong> 基本型別</a></li><li><a href="comments.html"><strong>4.4.</strong> 註解</a></li><li><a href="if.html"><strong>4.5.</strong> if</a></li><li><a href="loops.html"><strong>4.6.</strong> 迴圈</a></li><li><a href="ownership.html"><strong>4.7.</strong> 所有權</a></li><li><a href="references-and-borrowing.html" class="active"><strong>4.8.</strong> 參照與借用</a></li><li><a href="lifetimes.html"><strong>4.9.</strong> 生命週期</a></li><li><a href="mutability.html"><strong>4.10.</strong> Mutability</a></li><li><a href="structs.html"><strong>4.11.</strong> Structs</a></li><li><a href="enums.html"><strong>4.12.</strong> Enums</a></li><li><a href="match.html"><strong>4.13.</strong> Match</a></li><li><a href="patterns.html"><strong>4.14.</strong> Patterns</a></li><li><a href="method-syntax.html"><strong>4.15.</strong> Method Syntax</a></li><li><a href="vectors.html"><strong>4.16.</strong> Vectors</a></li><li><a href="strings.html"><strong>4.17.</strong> Strings</a></li><li><a href="generics.html"><strong>4.18.</strong> Generics</a></li><li><a href="traits.html"><strong>4.19.</strong> Traits</a></li><li><a href="drop.html"><strong>4.20.</strong> Drop</a></li><li><a href="if-let.html"><strong>4.21.</strong> if let</a></li><li><a href="trait-objects.html"><strong>4.22.</strong> Trait Objects</a></li><li><a href="closures.html"><strong>4.23.</strong> Closures</a></li><li><a href="ufcs.html"><strong>4.24.</strong> Universal Function Call Syntax</a></li><li><a href="crates-and-modules.html"><strong>4.25.</strong> Crates and Modules</a></li><li><a href="const-and-static.html"><strong>4.26.</strong> <code>const</code> and <code>static</code></a></li><li><a href="attributes.html"><strong>4.27.</strong> Attributes</a></li><li><a href="type-aliases.html"><strong>4.28.</strong> <code>type</code> aliases</a></li><li><a href="casting-between-types.html"><strong>4.29.</strong> Casting between types</a></li><li><a href="associated-types.html"><strong>4.30.</strong> Associated Types</a></li><li><a href="unsized-types.html"><strong>4.31.</strong> Unsized Types</a></li><li><a href="operators-and-overloading.html"><strong>4.32.</strong> Operators and Overloading</a></li><li><a href="deref-coercions.html"><strong>4.33.</strong> Deref coercions</a></li><li><a href="macros.html"><strong>4.34.</strong> Macros</a></li><li><a href="raw-pointers.html"><strong>4.35.</strong> Raw Pointers</a></li><li><a href="unsafe.html"><strong>4.36.</strong> <code>unsafe</code></a></li></ul></li><li><a href="effective-rust.html"><strong>5.</strong> Effective Rust</a></li><li><ul class="section"><li><a href="the-stack-and-the-heap.html"><strong>5.1.</strong> The Stack and the Heap</a></li><li><a href="testing.html"><strong>5.2.</strong> Testing</a></li><li><a href="conditional-compilation.html"><strong>5.3.</strong> Conditional Compilation</a></li><li><a href="documentation.html"><strong>5.4.</strong> Documentation</a></li><li><a href="iterators.html"><strong>5.5.</strong> Iterators</a></li><li><a href="concurrency.html"><strong>5.6.</strong> Concurrency</a></li><li><a href="error-handling.html"><strong>5.7.</strong> Error Handling</a></li><li><a href="choosing-your-guarantees.html"><strong>5.8.</strong> Choosing your Guarantees</a></li><li><a href="ffi.html"><strong>5.9.</strong> FFI</a></li><li><a href="borrow-and-asref.html"><strong>5.10.</strong> Borrow and AsRef</a></li><li><a href="release-channels.html"><strong>5.11.</strong> Release Channels</a></li><li><a href="using-rust-without-the-standard-library.html"><strong>5.12.</strong> Using Rust without the standard library</a></li></ul></li><li><a href="nightly-rust.html"><strong>6.</strong> Nightly Rust</a></li><li><ul class="section"><li><a href="compiler-plugins.html"><strong>6.1.</strong> Compiler Plugins</a></li><li><a href="inline-assembly.html"><strong>6.2.</strong> Inline Assembly</a></li><li><a href="no-stdlib.html"><strong>6.3.</strong> No stdlib</a></li><li><a href="intrinsics.html"><strong>6.4.</strong> Intrinsics</a></li><li><a href="lang-items.html"><strong>6.5.</strong> Lang items</a></li><li><a href="advanced-linking.html"><strong>6.6.</strong> Advanced linking</a></li><li><a href="benchmark-tests.html"><strong>6.7.</strong> Benchmark Tests</a></li><li><a href="box-syntax-and-patterns.html"><strong>6.8.</strong> Box Syntax and Patterns</a></li><li><a href="slice-patterns.html"><strong>6.9.</strong> Slice Patterns</a></li><li><a href="associated-constants.html"><strong>6.10.</strong> Associated Constants</a></li><li><a href="custom-allocators.html"><strong>6.11.</strong> Custom Allocators</a></li></ul></li><li><a href="glossary.html"><strong>7.</strong> 詞彙表</a></li><li><a href="syntax-index.html"><strong>8.</strong> 語法索引</a></li><li><a href="bibliography.html"><strong>9.</strong> 參考文獻</a></li><li><a href="MappingTable.html"><strong>10.</strong> 中英文字彙對照表</a></li><li><a href="CONTRIBUTORS.html"><strong>11.</strong> 翻譯貢獻名單</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">Rust 程式語言 正體中文版</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <h1>參照與借用</h1>
<p>本指南是當前 Rust 的三個所有權系統之一。
這是 Rust 最獨特且引人注目的功能之一，作為 Rust 的開發者應該對此要有相當的了解。
所有權是 Rust 用來達成其最大的目標，記憶體安全，的方法。
它有一些不同的概念，各自有各自的章節：</p>
<ul>
<li><a href="ownership.html">所有權</a> (ownership)，關鍵的概念</li>
<li>借用 (borrowing)，你正在閱讀的章節</li>
<li><a href="lifetimes.html">生命週期</a> (lifetime)，借用的進階概念</li>
</ul>
<p>這三章依序相關。
你需要了解全部三章來完整了解所有權系統。</p>
<h2>Meta</h2>
<p>在我們開始細述前，有兩個所有權系統的重點。</p>
<p>Rust 注重安全和速度。
它透過許多 &quot;零成本抽象化&quot; 的方式去實現目標，也就是 Rust 將盡可能縮小抽象化成本去達成目標。
所有權系統是零成本抽象化的一個最佳範例。
我們在本指南中談到的所有分析，都是在 <em>編譯期完成的</em>。
這些功能不需要花費你任何執行期的成本。</p>
<p>然而，這套系統仍有某些成本：學習曲線。
許多 Rust 的新使用者會經歷我們所說的 &quot;與借用檢查器 (borrow checker) 戰鬥&quot; 的經驗，也就是 Rust 編譯器無法編譯一個作者認為合理的程式。
在程式設計師內心的所有權運作模型與實際上 Rust 實作不相符的時候，這會常常發生。
一開始你可能也會經歷類似的事情。
然而有個好消息：許多有經驗的 Rust 開發者回報，當他們適應所有權系統的規則一陣子之後，他們跟借用檢查器的戰鬥就越來越少了。</p>
<p>記住這些之後，讓我們開始學習借用。</p>
<h2>借用 (Borrowing)</h2>
<p>在<a href="ownership.html">所有權</a>一節的最後，我們提到一個看起來頗糟的函式：</p>
<pre><code class="language-rust">fn foo(v1: Vec&lt;i32&gt;, v2: Vec&lt;i32&gt;) -&gt; (Vec&lt;i32&gt;, Vec&lt;i32&gt;, i32) {
    // do stuff with v1 and v2

    // hand back ownership, and the result of our function
    (v1, v2, 42)
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];

let (v1, v2, answer) = foo(v1, v2);
</code></pre>
<p>這不符合 Rust 的語言習慣，因為它沒有利用到借用的優點。
以下是第一步：</p>
<pre><code class="language-rust">fn foo(v1: &amp;Vec&lt;i32&gt;, v2: &amp;Vec&lt;i32&gt;) -&gt; i32 {
    // do stuff with v1 and v2

    // return the answer
    42
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];

let answer = foo(&amp;v1, &amp;v2);

// we can use v1 and v2 here!
</code></pre>
<p>與其把 <code>Vec&lt;i32&gt;</code> 作為我們的參數，不如使用參照 (reference)：<code>&amp;Vec&lt;i32&gt;</code>。
而且不要直接傳遞 <code>v1</code> 與 <code>v2</code>，我們傳遞 <code>&amp;v1</code> 與 <code>&amp;v2</code>。
我們把 <code>&amp;T</code> 型別稱為 &quot;參照&quot; (reference)，它借用了所有權，而非掌握所有權。
一個借用東西的綁定不會在離開有效範圍時釋放資源。
這代表在呼叫 <code>foo()</code> 完之後，我們仍可以再度使用我們原始的綁定。</p>
<p>跟綁定一樣，參照是不可變的 (immutable)。
這意味著在 <code>foo()</code> 內，向量完全不能更改：</p>
<pre><code class="language-rust,ignore">fn foo(v: &amp;Vec&lt;i32&gt;) {
     v.push(5);
}

let v = vec![];

foo(&amp;v);
</code></pre>
<p>出現以下錯誤：</p>
<pre><code class="language-text">error: cannot borrow immutable borrowed content `*v` as mutable
v.push(5);
^
</code></pre>
<p>因為放入一個值會改變向量，所以我們不允許這樣做。</p>
<h2>&amp;mut 參照</h2>
<p>還有第二類的參照：<code>&amp;mut T</code>。
一個 &quot;可變的參照&quot; 允許你改變你所借用的資源。
例如：</p>
<pre><code class="language-rust">let mut x = 5;
{
    let y = &amp;mut x;
    *y += 1;
}
println!(&quot;{}&quot;, x);
</code></pre>
<p>這將會印出 <code>6</code>。
我們將 <code>y</code> 作為一個指到 <code>x</code> 的可變參照，然後對 <code>y</code> 指向的東西加一。
你將注意到 <code>x</code> 也必須被標註為 <code>mut</code>。
如果不是的話，我們將無法建立一個可變得借用到一個不可變的值。</p>
<blockquote>
<p>譯註：如果 <code>x</code> 不是 <code>mut</code>，會得到 <code>error: cannot borrow immutable local variable</code>x<code>as mutable</code> 錯誤訊息。</p>
</blockquote>
<p>你同時也會發現我們在 <code>y</code> 前面加上星號（<code>*</code>）成為 <code>*y</code>，這是因為 <code>y</code> 是一個 <code>&amp;mut</code> 參照，
你需要使用它們去存取參照的內容。</p>
<p>此外，<code>&amp;mut</code> 參照如同一般的參照。它們兩者和它們的互動方式 <em>有著</em> 巨大的區別。
你可以說以上的範例有點不可靠，因為我們需要額外的 <code>{</code> 和 <code>}</code> 定義有效區域。
如果移除它們，我們會得到錯誤訊息：</p>
<pre><code class="language-text">error: cannot borrow `x` as immutable because it is also borrowed as mutable
    println!(&quot;{}&quot;, x);
                   ^
note: previous borrow of `x` occurs here; the mutable borrow prevents
subsequent moves, borrows, or modification of `x` until the borrow ends
        let y = &amp;mut x;
                     ^
note: previous borrow ends here
fn main() {

}
^
</code></pre>
<p>事實證明如此，所以以下是一些規則。</p>
<h2>規則</h2>
<p>以下是 Rust 中關於借用 (borrowing) 的規則：</p>
<p>首先，任何借用的有效範圍都必須比擁有者的有效範圍還要小。
其次，你可以使用以下兩種借用，但是不能同時使用兩者：</p>
<ul>
<li>一到多個對資源的參照（<code>&amp;T</code>）</li>
<li>唯一一個可變參照（<code>&amp;mut T</code>）</li>
</ul>
<p>你可能有注意到有點類似、但不完全相同於資料競爭的定義：</p>
<blockquote>
<p>當兩個或多個指標同時存取相同的記憶體，其中至少有一個正在寫入，且操作沒有同步時，會出現 &quot;資料競爭&quot; (date race)。</p>
</blockquote>
<p>使用參照時，你可以想要多少參照就用多少參照，因為它們沒有人在寫入。
然而，一次只能擁有一個 <code>&amp;mut</code>，這才不會產生資料競爭。
這就是 Rust 如何在編譯期預防資料競爭：當我們違反規則時，會得到錯誤訊息。</p>
<p>記住這些之後，讓我們再次想想我們的範例。</p>
<h3>對有效範圍的深思 (Thinking in scopes)</h3>
<p>以下是程式碼：</p>
<pre><code class="language-rust,ignore">let mut x = 5;
let y = &amp;mut x;

*y += 1;

println!(&quot;{}&quot;, x);
</code></pre>
<p>這段程式碼會有這些錯誤訊息：</p>
<pre><code class="language-text">error: cannot borrow `x` as immutable because it is also borrowed as mutable
    println!(&quot;{}&quot;, x);
                   ^
</code></pre>
<blockquote>
<p>譯註：此處 <code>println!()</code> 試圖借用 <code>x</code>。</p>
</blockquote>
<p>這是因為我們違反了規則：我們有了一個指向 <code>x</code> 的 <code>&amp;mut T</code>，所以我們不允許建立任何其他 <code>&amp;T</code>。
要在兩者間做出選擇。
錯誤中的註解提示我們該如何思考這個問題：</p>
<pre><code class="language-text">note: previous borrow ends here
fn main() {

}
^
</code></pre>
<p>換句話說，可變借用 (mutable borrow) 在我們的範例中一直存在。
所以我們希望可變借用能在我們呼叫 <code>println!</code> 並建立不可變借用 <em>之前</em> 能結束掉。
在 Rust 中，借用綁定在借用有效的範圍中。
我們的有效範圍看起來會像這樣：</p>
<pre><code class="language-rust,ignore">let mut x = 5;

let y = &amp;mut x;    // -+ &amp;mut borrow of x starts here
                   //  |
*y += 1;           //  |
                   //  |
println!(&quot;{}&quot;, x); // -+ - try to borrow x here
                   // -+ &amp;mut borrow of x ends here
</code></pre>
<p>這些有效範圍有衝突：我們不能在 <code>y</code> 仍在有效範圍時建立 <code>&amp;x</code>。</p>
<p>而當我們增加大括號之後：</p>
<pre><code class="language-rust">let mut x = 5;

{
    let y = &amp;mut x; // -+ &amp;mut borrow starts here
    *y += 1;        //  |
}                   // -+ ... and ends here

println!(&quot;{}&quot;, x);  // &lt;- try to borrow x here
</code></pre>
<p>這樣就沒有問題了。
我們的可變借用會在我們建立不可變借用前離開有效範圍。
有效範圍是個看清借用持續多久的關鍵。</p>
<h3>借用所預防的問題 (Issues borrowing prevents)</h3>
<p>為何我們需要這些限制規則？
好吧，如同我們所說的，這些規則避免資料競爭。
資料競爭會引發哪些問題？
以下是一些例子。</p>
<h4>疊代器失效</h4>
<p>一個例子是 &quot;疊代器失效&quot; (Iterator invalidation)，當你試圖改變一個正在疊代的集合 (collection) 時會發生。
Rust 的借用檢查器會預防這件事發生：</p>
<pre><code class="language-rust">let mut v = vec![1, 2, 3];

for i in &amp;v {
    println!(&quot;{}&quot;, i);
}
</code></pre>
<p>這會印出一到三。
當我們疊代這個向量時，我們只會用到元素的參照。
而且 <code>v</code> 是一個不可變的借用，所以我們在疊代時不能更改它：</p>
<pre><code class="language-rust,ignore">let mut v = vec![1, 2, 3];

for i in &amp;v {
    println!(&quot;{}&quot;, i);
    v.push(34);
}
</code></pre>
<p>以下是錯誤訊息：</p>
<pre><code class="language-text">error: cannot borrow `v` as mutable because it is also borrowed as immutable
    v.push(34);
    ^
note: previous borrow of `v` occurs here; the immutable borrow prevents
subsequent moves or mutable borrows of `v` until the borrow ends
for i in &amp;v {
          ^
note: previous borrow ends here
for i in &amp;v {
    println!(“{}”, i);
    v.push(34);
}
^
</code></pre>
<p>我們不能修改 <code>v</code>，因為它已經借用給迴圈了。</p>
<h4>在釋放之後使用 (use after free)</h4>
<p>參照不能存活得比所參考的資源還久。
Rust 會檢查你的參照的有效範圍來確保符合這個條件。</p>
<p>如果 Rust 沒有檢查這個屬性，我們可能會意外地用到一個無效的參照。
例如：</p>
<pre><code class="language-rust,ignore">let y: &amp;i32;
{
    let x = 5;
    y = &amp;x;
}

println!(&quot;{}&quot;, y);
</code></pre>
<p>會得到以下錯誤：</p>
<pre><code class="language-text">error: `x` does not live long enough
    y = &amp;x;
         ^
note: reference must be valid for the block suffix following statement 0 at
2:16...
let y: &amp;i32;
{
    let x = 5;
    y = &amp;x;
}

note: ...but borrowed value is only valid for the block suffix following
statement 0 at 4:18
    let x = 5;
    y = &amp;x;
}
</code></pre>
<p>換句話說，<code>y</code> 只在 <code>x</code> 存在的有效範圍內有效。
當 <code>x</code> 消失，它就成為無效的參照。
這個錯誤訊息說，這個借用 &quot;存在得不夠久&quot; 就是因為它在應該存在的時候已經失效了。</p>
<p>當一個參照在它所參考的變數 <em>之前</em> 宣告，也會發生一樣的問題。
這是因為資源在同樣的有效範圍內，它們被釋放的順序是跟它們宣告順序相反：</p>
<blockquote>
<p>譯註：也就是 <code>宣告 y; 宣告 x;</code> 的話，離開有效範圍時會 <code>釋放 x; 釋放 y</code>。所以 <code>y</code> 比 <code>x</code> 存活的久。</p>
</blockquote>
<pre><code class="language-rust,ignore">let y: &amp;i32;
let x = 5;
y = &amp;x;

println!(&quot;{}&quot;, y);
</code></pre>
<p>得到以下錯誤訊息：</p>
<pre><code class="language-text">error: `x` does not live long enough
y = &amp;x;
     ^
note: reference must be valid for the block suffix following statement 0 at
2:16...
    let y: &amp;i32;
    let x = 5;
    y = &amp;x;

    println!(&quot;{}&quot;, y);
}

note: ...but borrowed value is only valid for the block suffix following
statement 1 at 3:14
    let x = 5;
    y = &amp;x;

    println!(&quot;{}&quot;, y);
}
</code></pre>
<p>在以上範例，<code>y</code> 在 <code>x</code> 之前宣告，代表 <code>y</code> 存活的比 <code>x</code> 還長，這不被允許。</p>
<blockquote>
<p><em>commit 6ba9520</em></p>
</blockquote>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="ownership.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="lifetimes.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="ownership.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="lifetimes.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
