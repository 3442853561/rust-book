<!DOCTYPE HTML>
<html lang="zh-Hant">
    <head>
        <meta charset="UTF-8">
        <title>Rust 程式語言 正體中文版</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The Rust Programming Language">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

		<style>
            @import url(http://fonts.googleapis.com/earlyaccess/cwtexhei.css);
        </style>
        <link rel="stylesheet" href="book.css">
        <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body>
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="README.html"><strong>1.</strong> 簡介</a></li><li><a href="getting-started.html"><strong>2.</strong> 準備</a></li><li><a href="guessing-game.html"><strong>3.</strong> 教學: 猜數字遊戲</a></li><li><a href="syntax-and-semantics.html"><strong>4.</strong> 語法及語意</a></li><li><ul class="section"><li><a href="variable-bindings.html"><strong>4.1.</strong> 變數綁定</a></li><li><a href="functions.html"><strong>4.2.</strong> 函式</a></li><li><a href="primitive-types.html"><strong>4.3.</strong> 基本型別</a></li><li><a href="comments.html"><strong>4.4.</strong> 註解</a></li><li><a href="if.html"><strong>4.5.</strong> if</a></li><li><a href="loops.html"><strong>4.6.</strong> 迴圈</a></li><li><a href="ownership.html"><strong>4.7.</strong> 所有權</a></li><li><a href="references-and-borrowing.html"><strong>4.8.</strong> 參照與借用</a></li><li><a href="lifetimes.html"><strong>4.9.</strong> 生命週期</a></li><li><a href="mutability.html"><strong>4.10.</strong> 可變性</a></li><li><a href="structs.html"><strong>4.11.</strong> 結構體</a></li><li><a href="enums.html"><strong>4.12.</strong> 枚舉</a></li><li><a href="match.html"><strong>4.13.</strong> Match</a></li><li><a href="patterns.html" class="active"><strong>4.14.</strong> 模式</a></li><li><a href="method-syntax.html"><strong>4.15.</strong> Method Syntax</a></li><li><a href="vectors.html"><strong>4.16.</strong> 向量</a></li><li><a href="strings.html"><strong>4.17.</strong> 字串</a></li><li><a href="generics.html"><strong>4.18.</strong> 泛型</a></li><li><a href="traits.html"><strong>4.19.</strong> Traits</a></li><li><a href="drop.html"><strong>4.20.</strong> Drop</a></li><li><a href="if-let.html"><strong>4.21.</strong> if let</a></li><li><a href="trait-objects.html"><strong>4.22.</strong> Trait Objects</a></li><li><a href="closures.html"><strong>4.23.</strong> Closures</a></li><li><a href="ufcs.html"><strong>4.24.</strong> Universal Function Call Syntax</a></li><li><a href="crates-and-modules.html"><strong>4.25.</strong> Crates and Modules</a></li><li><a href="const-and-static.html"><strong>4.26.</strong> <code>const</code> and <code>static</code></a></li><li><a href="attributes.html"><strong>4.27.</strong> Attributes</a></li><li><a href="type-aliases.html"><strong>4.28.</strong> <code>type</code> aliases</a></li><li><a href="casting-between-types.html"><strong>4.29.</strong> Casting between types</a></li><li><a href="associated-types.html"><strong>4.30.</strong> Associated Types</a></li><li><a href="unsized-types.html"><strong>4.31.</strong> Unsized Types</a></li><li><a href="operators-and-overloading.html"><strong>4.32.</strong> Operators and Overloading</a></li><li><a href="deref-coercions.html"><strong>4.33.</strong> Deref coercions</a></li><li><a href="macros.html"><strong>4.34.</strong> Macros</a></li><li><a href="raw-pointers.html"><strong>4.35.</strong> Raw Pointers</a></li><li><a href="unsafe.html"><strong>4.36.</strong> <code>unsafe</code></a></li></ul></li><li><a href="effective-rust.html"><strong>5.</strong> Effective Rust</a></li><li><ul class="section"><li><a href="the-stack-and-the-heap.html"><strong>5.1.</strong> The Stack and the Heap</a></li><li><a href="testing.html"><strong>5.2.</strong> Testing</a></li><li><a href="conditional-compilation.html"><strong>5.3.</strong> Conditional Compilation</a></li><li><a href="documentation.html"><strong>5.4.</strong> Documentation</a></li><li><a href="iterators.html"><strong>5.5.</strong> Iterators</a></li><li><a href="concurrency.html"><strong>5.6.</strong> Concurrency</a></li><li><a href="error-handling.html"><strong>5.7.</strong> Error Handling</a></li><li><a href="choosing-your-guarantees.html"><strong>5.8.</strong> Choosing your Guarantees</a></li><li><a href="ffi.html"><strong>5.9.</strong> FFI</a></li><li><a href="borrow-and-asref.html"><strong>5.10.</strong> Borrow and AsRef</a></li><li><a href="release-channels.html"><strong>5.11.</strong> Release Channels</a></li><li><a href="using-rust-without-the-standard-library.html"><strong>5.12.</strong> Using Rust without the standard library</a></li></ul></li><li><a href="nightly-rust.html"><strong>6.</strong> Nightly Rust</a></li><li><ul class="section"><li><a href="compiler-plugins.html"><strong>6.1.</strong> Compiler Plugins</a></li><li><a href="inline-assembly.html"><strong>6.2.</strong> Inline Assembly</a></li><li><a href="no-stdlib.html"><strong>6.3.</strong> No stdlib</a></li><li><a href="intrinsics.html"><strong>6.4.</strong> Intrinsics</a></li><li><a href="lang-items.html"><strong>6.5.</strong> Lang items</a></li><li><a href="advanced-linking.html"><strong>6.6.</strong> Advanced linking</a></li><li><a href="benchmark-tests.html"><strong>6.7.</strong> Benchmark Tests</a></li><li><a href="box-syntax-and-patterns.html"><strong>6.8.</strong> Box Syntax and Patterns</a></li><li><a href="slice-patterns.html"><strong>6.9.</strong> Slice Patterns</a></li><li><a href="associated-constants.html"><strong>6.10.</strong> Associated Constants</a></li><li><a href="custom-allocators.html"><strong>6.11.</strong> Custom Allocators</a></li></ul></li><li><a href="glossary.html"><strong>7.</strong> 詞彙表</a></li><li><a href="syntax-index.html"><strong>8.</strong> 語法索引</a></li><li><a href="bibliography.html"><strong>9.</strong> 參考文獻</a></li><li><a href="MappingTable.html"><strong>10.</strong> 中英文字彙對照表</a></li><li><a href="CONTRIBUTORS.html"><strong>11.</strong> 翻譯貢獻名單</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">Rust 程式語言 正體中文版</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <h1>模式</h1>
<p>模式 (pattern) 在 Rust 中很常見。
我們在<a href="variable-bindings.html">變數綁定</a>、<a href="match.html">match 陳述式</a>、及其他地方都會用到。
讓我們開始快速地了解模式可以做到些什麼！</p>
<p>快速複習一下：你可以直接配對變數，而 <code>_</code> 將會配對到 &quot;任何&quot; 沒列出來的其他情況：</p>
<pre><code class="language-rust">let x = 1;

match x {
    1 =&gt; println!(&quot;one&quot;),
    2 =&gt; println!(&quot;two&quot;),
    3 =&gt; println!(&quot;three&quot;),
    _ =&gt; println!(&quot;anything&quot;),
}
</code></pre>
<p>這會印出 <code>one</code>。</p>
<p>模式有個陷阱：它會產生遮蔽 (shadowing)，與其他會產生新的綁定的任何東西一樣。
舉例來說：</p>
<pre><code class="language-rust">let x = 1;
let c = 'c';

match c {
    x =&gt; println!(&quot;x: {} c: {}&quot;, x, c),
}

println!(&quot;x: {}&quot;, x)
</code></pre>
<p>這會印出：</p>
<pre><code class="language-text">x: c c: c
x: 1
</code></pre>
<p>換句話說，<code>x =&gt;</code> 符合模式，而且產生了新的名為 <code>x</code> 的綁定。
新綁定的有效範圍在該 match 的執行分支中，且它的值被賦予為 <code>c</code>。
請注意，在 match 有效範圍之外的 <code>x</code> 的值不會影響到範圍內的 <code>x</code>。
因為我們本來已經有了 <code>x</code> 綁定，而新的 <code>x</code> 遮蔽了它。</p>
<h2>多重模式 (Multiple patterns)</h2>
<p>你可以使用 <code>|</code> 來配對多重模式：</p>
<pre><code class="language-rust">let x = 1;

match x {
    1 | 2 =&gt; println!(&quot;one or two&quot;),
    3 =&gt; println!(&quot;three&quot;),
    _ =&gt; println!(&quot;anything&quot;),
}
</code></pre>
<p>這會印出 <code>one or two</code>。</p>
<h2>解構 (Destructuring)</h2>
<p>如果你有個複合的資料型別，像是<a href="structs.html">結構體</a> (struct)，你可以在模式中解構它：</p>
<pre><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

match origin {
    Point { x, y } =&gt; println!(&quot;({},{})&quot;, x, y),
}
</code></pre>
<p>我們可以使用 <code>:</code> 給予值新的不同命名。</p>
<pre><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

match origin {
    Point { x: x1, y: y1 } =&gt; println!(&quot;({},{})&quot;, x1, y1),
}
</code></pre>
<p>如果我們只在意某些值，我們不需要給它所有名稱：</p>
<pre><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

match origin {
    Point { x, .. } =&gt; println!(&quot;x is {}&quot;, x),
}
</code></pre>
<p>這會印出 <code>x is 0</code>。</p>
<p>你可以對任何成員進行這樣的配對，而不僅限於第一個：</p>
<pre><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

match origin {
    Point { y, .. } =&gt; println!(&quot;y is {}&quot;, y),
}
</code></pre>
<p>這會印出 <code>y is 0</code>。</p>
<p>這種 &quot;解構&quot; 行為在任何複合資料型別上都可以運作，像<a href="primitive-types.html#%E5%A4%9A%E5%85%83%E7%B5%84%20(Tuples)">多元組</a> (tuple) 或<a href="enums.html">枚舉</a> (enum) 都可以。</p>
<h2>忽略綁定</h2>
<p>你可以在模式中使用 <code>_</code> 忽略型別跟值。
舉例來說，這是一個 <code>Result&lt;T, E&gt;</code> 的 <code>match</code> 例子：</p>
<pre><code class="language-rust"># let some_value: Result&lt;i32, &amp;'static str&gt; = Err(&quot;There was an error&quot;);
match some_value {
    Ok(value) =&gt; println!(&quot;got a value: {}&quot;, value),
    Err(_) =&gt; println!(&quot;an error occurred&quot;),
}
</code></pre>
<p>在第一個執行分支中，我們把 <code>OK</code> 內的值綁定到 <code>value</code> 上。
但是在 <code>Err</code> 分支，我們使用 <code>_</code> 來忽略特定的錯誤，印出通用的錯誤訊息。</p>
<p><code>_</code> 在任何建立綁定的模式中都有效。
這在大型結構體中要忽略某些部份時也非常有用：</p>
<pre><code class="language-rust">fn coordinate() -&gt; (i32, i32, i32) {
    // generate and return some sort of triple tuple
# (1, 2, 3)
}

let (x, _, z) = coordinate();
</code></pre>
<p>在這邊，我們把多元組中的第一個跟最後一個元素綁定到 <code>x</code> 跟 <code>z</code>，但是忽略了中間的元素。</p>
<p>值得注意的是，<code>_</code> 並不會綁定變數，這代表值不會移動所有權：</p>
<blockquote>
<p>譯註：但如果給了變數名稱，沒有實作 Copy 的元素就會把所有權移到該變數上，因此使用原來的綁定時會出現 <code>error: use of moved value</code> 錯誤。
在以下例子中，<code>tuple.0</code> 因為是 <code>u32</code> 有實作 Copy trait，所以仍可以使用，只有 <code>tuple.1</code> 是 <code>String</code>，因為給了命名，所以所有權被轉移了（也就是移動了值）。</p>
</blockquote>
<pre><code class="language-rust">let tuple: (u32, String) = (5, String::from(&quot;five&quot;));

// Here, tuple is moved, because the String moved:
let (x, _s) = tuple;

// The next line would give &quot;error: use of partially moved value: `tuple`&quot;
// println!(&quot;Tuple is: {:?}&quot;, tuple);

// However,

let tuple = (5, String::from(&quot;five&quot;));

// Here, tuple is _not_ moved, as the String was never moved, and u32 is Copy:
let (x, _) = tuple;

// That means this works:
println!(&quot;Tuple is: {:?}&quot;, tuple);
</code></pre>
<p>這也代表任何暫時的變數會在陳述式結束之後被丟棄：</p>
<pre><code class="language-rust">// Here, the String created will be dropped immediately, as it’s not bound:

let _ = String::from(&quot;  hello  &quot;).trim();
</code></pre>
<p>你也可以在模式中使用 <code>..</code> 去忽略多個值：</p>
<pre><code class="language-rust">enum OptionalTuple {
    Value(i32, i32, i32),
    Missing,
}

let x = OptionalTuple::Value(5, -2, 3);

match x {
    OptionalTuple::Value(..) =&gt; println!(&quot;Got a tuple!&quot;),
    OptionalTuple::Missing =&gt; println!(&quot;No such luck.&quot;),
}
</code></pre>
<p>這會印出 <code>Got a tuple!</code>。</p>
<h2>ref 與 ref mut</h2>
<p>如果你想要獲得一個<a href="references-and-borrowing.html">參照</a> (reference)，可以使用 <code>ref</code> 關鍵字：</p>
<pre><code class="language-rust">let x = 5;

match x {
    ref r =&gt; println!(&quot;Got a reference to {}&quot;, r),
}
</code></pre>
<p>這會印出 <code>Got a reference to 5</code>。</p>
<p>這邊 <code>match</code> 中的 <code>r</code> 是一個 <code>&amp;i32</code> 型別。
換句話說，<code>ref</code> 關鍵字 <em>建立</em> 了一個可在模式當中使用的參照。
如果你需要一個可變的 (mutable) 參照，可以使用 <code>ref mut</code>：</p>
<pre><code class="language-rust">let mut x = 5;

match x {
    ref mut mr =&gt; println!(&quot;Got a mutable reference to {}&quot;, mr),
}
</code></pre>
<h2>範圍</h2>
<p>你可以用 <code>...</code> 配對一個範圍的值：</p>
<pre><code class="language-rust">let x = 1;

match x {
    1 ... 5 =&gt; println!(&quot;one through five&quot;),
    _ =&gt; println!(&quot;anything&quot;),
}
</code></pre>
<p>這會印出 <code>one through five</code>。</p>
<p>範圍通常用在整數和 <code>char</code> 上：</p>
<pre><code class="language-rust">let x = '💅';

match x {
    'a' ... 'j' =&gt; println!(&quot;early letter&quot;),
    'k' ... 'z' =&gt; println!(&quot;late letter&quot;),
    _ =&gt; println!(&quot;something else&quot;),
}
</code></pre>
<p>這會印出 <code>something else</code>。</p>
<h2>綁定</h2>
<p>你可以使用 <code>@</code> 把值綁定在命名上：</p>
<pre><code class="language-rust">let x = 1;

match x {
    e @ 1 ... 5 =&gt; println!(&quot;got a range element {}&quot;, e),
    _ =&gt; println!(&quot;anything&quot;),
}
</code></pre>
<p>這會印出 <code>got a range element 1</code>。
當你想對資料結構中的部分進行複雜的配對時，這十分有用：</p>
<pre><code class="language-rust">#[derive(Debug)]
struct Person {
    name: Option&lt;String&gt;,
}

let name = &quot;Steve&quot;.to_string();
let x: Option&lt;Person&gt; = Some(Person { name: Some(name) });
match x {
    Some(Person { name: ref a @ Some(_), .. }) =&gt; println!(&quot;{:?}&quot;, a),
    _ =&gt; {}
}
</code></pre>
<p>這會印出 <code>Some(&quot;Steve&quot;)</code>：因為我們把內部的 <code>name</code> 綁定到 <code>a</code> 了。</p>
<p>如果你將 <code>@</code> 與 <code>|</code> 一起使用，你需要確保在模式的每一部份都有綁定命名：</p>
<pre><code class="language-rust">let x = 5;

match x {
    e @ 1 ... 5 | e @ 8 ... 10 =&gt; println!(&quot;got a range element {}&quot;, e),
    _ =&gt; println!(&quot;anything&quot;),
}
</code></pre>
<h2>守衛 (Guards)</h2>
<p>你可以使用 <code>if</code> 來產生 &quot;配對守衛&quot; (match guards)：</p>
<pre><code class="language-rust">enum OptionalInt {
    Value(i32),
    Missing,
}

let x = OptionalInt::Value(5);

match x {
    OptionalInt::Value(i) if i &gt; 5 =&gt; println!(&quot;Got an int bigger than five!&quot;),
    OptionalInt::Value(..) =&gt; println!(&quot;Got an int!&quot;),
    OptionalInt::Missing =&gt; println!(&quot;No such luck.&quot;),
}
</code></pre>
<p>這會印出 <code>Got an int!</code>。</p>
<p>如果你在多重模式中使用 <code>if</code>，那 <code>if</code> 將會套用在多重模式的所有模式上：</p>
<pre><code class="language-rust">let x = 4;
let y = false;

match x {
    4 | 5 if y =&gt; println!(&quot;yes&quot;),
    _ =&gt; println!(&quot;no&quot;),
}
</code></pre>
<p>這會印出 <code>no</code>，因為 <code>if</code> 套用在整個 <code>4 | 5</code> 之上，而不只是 <code>5</code>。
換句話說，<code>if</code> 行為的優先權就像是：</p>
<pre><code class="language-text">(4 | 5) if y =&gt; ...
</code></pre>
<p>而不是：</p>
<pre><code class="language-text">4 | (5 if y) =&gt; ...
</code></pre>
<h2>混合與配對 (Mix and Match)</h2>
<p>恩！有非常多種方法可以進行配對，而且它們可以根據你想做的事情而組合使用：</p>
<pre><code class="language-rust,ignore">match x {
    Foo { x: Some(ref name), y: None } =&gt; ...
}
</code></pre>
<p>模式非常強大。
好好善用它們。</p>
<blockquote>
<p><em>commit b49ce1a</em></p>
</blockquote>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="match.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="method-syntax.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="match.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="method-syntax.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
