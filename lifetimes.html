<!DOCTYPE HTML>
<html lang="zh-Hant">
    <head>
        <meta charset="UTF-8">
        <title>Rust 程式語言 正體中文版</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The Rust Programming Language">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

		<style>
            @import url(http://fonts.googleapis.com/earlyaccess/cwtexhei.css);
        </style>
        <link rel="stylesheet" href="book.css">
        <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body>
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="README.html"><strong>1.</strong> 簡介</a></li><li><a href="getting-started.html"><strong>2.</strong> 準備</a></li><li><a href="guessing-game.html"><strong>3.</strong> 教學: 猜數字遊戲</a></li><li><a href="syntax-and-semantics.html"><strong>4.</strong> 語法及語意</a></li><li><ul class="section"><li><a href="variable-bindings.html"><strong>4.1.</strong> 變數綁定</a></li><li><a href="functions.html"><strong>4.2.</strong> 函式</a></li><li><a href="primitive-types.html"><strong>4.3.</strong> 基本型別</a></li><li><a href="comments.html"><strong>4.4.</strong> 註解</a></li><li><a href="if.html"><strong>4.5.</strong> if</a></li><li><a href="loops.html"><strong>4.6.</strong> 迴圈</a></li><li><a href="ownership.html"><strong>4.7.</strong> 所有權</a></li><li><a href="references-and-borrowing.html"><strong>4.8.</strong> 參照與借用</a></li><li><a href="lifetimes.html" class="active"><strong>4.9.</strong> 生命週期</a></li><li><a href="mutability.html"><strong>4.10.</strong> 可變性</a></li><li><a href="structs.html"><strong>4.11.</strong> 結構體</a></li><li><a href="enums.html"><strong>4.12.</strong> 枚舉</a></li><li><a href="match.html"><strong>4.13.</strong> Match</a></li><li><a href="patterns.html"><strong>4.14.</strong> Patterns</a></li><li><a href="method-syntax.html"><strong>4.15.</strong> Method Syntax</a></li><li><a href="vectors.html"><strong>4.16.</strong> Vectors</a></li><li><a href="strings.html"><strong>4.17.</strong> Strings</a></li><li><a href="generics.html"><strong>4.18.</strong> Generics</a></li><li><a href="traits.html"><strong>4.19.</strong> Traits</a></li><li><a href="drop.html"><strong>4.20.</strong> Drop</a></li><li><a href="if-let.html"><strong>4.21.</strong> if let</a></li><li><a href="trait-objects.html"><strong>4.22.</strong> Trait Objects</a></li><li><a href="closures.html"><strong>4.23.</strong> Closures</a></li><li><a href="ufcs.html"><strong>4.24.</strong> Universal Function Call Syntax</a></li><li><a href="crates-and-modules.html"><strong>4.25.</strong> Crates and Modules</a></li><li><a href="const-and-static.html"><strong>4.26.</strong> <code>const</code> and <code>static</code></a></li><li><a href="attributes.html"><strong>4.27.</strong> Attributes</a></li><li><a href="type-aliases.html"><strong>4.28.</strong> <code>type</code> aliases</a></li><li><a href="casting-between-types.html"><strong>4.29.</strong> Casting between types</a></li><li><a href="associated-types.html"><strong>4.30.</strong> Associated Types</a></li><li><a href="unsized-types.html"><strong>4.31.</strong> Unsized Types</a></li><li><a href="operators-and-overloading.html"><strong>4.32.</strong> Operators and Overloading</a></li><li><a href="deref-coercions.html"><strong>4.33.</strong> Deref coercions</a></li><li><a href="macros.html"><strong>4.34.</strong> Macros</a></li><li><a href="raw-pointers.html"><strong>4.35.</strong> Raw Pointers</a></li><li><a href="unsafe.html"><strong>4.36.</strong> <code>unsafe</code></a></li></ul></li><li><a href="effective-rust.html"><strong>5.</strong> Effective Rust</a></li><li><ul class="section"><li><a href="the-stack-and-the-heap.html"><strong>5.1.</strong> The Stack and the Heap</a></li><li><a href="testing.html"><strong>5.2.</strong> Testing</a></li><li><a href="conditional-compilation.html"><strong>5.3.</strong> Conditional Compilation</a></li><li><a href="documentation.html"><strong>5.4.</strong> Documentation</a></li><li><a href="iterators.html"><strong>5.5.</strong> Iterators</a></li><li><a href="concurrency.html"><strong>5.6.</strong> Concurrency</a></li><li><a href="error-handling.html"><strong>5.7.</strong> Error Handling</a></li><li><a href="choosing-your-guarantees.html"><strong>5.8.</strong> Choosing your Guarantees</a></li><li><a href="ffi.html"><strong>5.9.</strong> FFI</a></li><li><a href="borrow-and-asref.html"><strong>5.10.</strong> Borrow and AsRef</a></li><li><a href="release-channels.html"><strong>5.11.</strong> Release Channels</a></li><li><a href="using-rust-without-the-standard-library.html"><strong>5.12.</strong> Using Rust without the standard library</a></li></ul></li><li><a href="nightly-rust.html"><strong>6.</strong> Nightly Rust</a></li><li><ul class="section"><li><a href="compiler-plugins.html"><strong>6.1.</strong> Compiler Plugins</a></li><li><a href="inline-assembly.html"><strong>6.2.</strong> Inline Assembly</a></li><li><a href="no-stdlib.html"><strong>6.3.</strong> No stdlib</a></li><li><a href="intrinsics.html"><strong>6.4.</strong> Intrinsics</a></li><li><a href="lang-items.html"><strong>6.5.</strong> Lang items</a></li><li><a href="advanced-linking.html"><strong>6.6.</strong> Advanced linking</a></li><li><a href="benchmark-tests.html"><strong>6.7.</strong> Benchmark Tests</a></li><li><a href="box-syntax-and-patterns.html"><strong>6.8.</strong> Box Syntax and Patterns</a></li><li><a href="slice-patterns.html"><strong>6.9.</strong> Slice Patterns</a></li><li><a href="associated-constants.html"><strong>6.10.</strong> Associated Constants</a></li><li><a href="custom-allocators.html"><strong>6.11.</strong> Custom Allocators</a></li></ul></li><li><a href="glossary.html"><strong>7.</strong> 詞彙表</a></li><li><a href="syntax-index.html"><strong>8.</strong> 語法索引</a></li><li><a href="bibliography.html"><strong>9.</strong> 參考文獻</a></li><li><a href="MappingTable.html"><strong>10.</strong> 中英文字彙對照表</a></li><li><a href="CONTRIBUTORS.html"><strong>11.</strong> 翻譯貢獻名單</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">Rust 程式語言 正體中文版</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <h1>生命週期</h1>
<p>本指南是當前 Rust 的三個所有權系統之一。
這是 Rust 最獨特且引人注目的功能之一，作為 Rust 的開發者應該對此要有相當的了解。
所有權是 Rust 用來達成其最大的目標，記憶體安全，的方法。
它有一些不同的概念，各自有各自的章節：</p>
<ul>
<li><a href="ownership.html">所有權</a> (ownership)，關鍵的概念</li>
<li><a href="references-and-borrowing.html">借用</a> (borrowing)，及其相關功能 &quot;參照&quot; (references)</li>
<li>生命週期 (lifetimes)，你正在閱讀的章節</li>
</ul>
<p>這三章依序相關。
你需要了解全部三章來完整了解所有權系統。</p>
<h2>Meta</h2>
<p>在我們開始細述前，有兩個所有權系統的重點。</p>
<p>Rust 注重安全和速度。
它透過許多 &quot;零成本抽象化&quot; 的方式去實現目標，也就是 Rust 將盡可能縮小抽象化成本去達成目標。
所有權系統是零成本抽象化的一個最佳範例。
我們在本指南中談到的所有分析，都是在 <em>編譯期完成的</em>。
這些功能不需要花費你任何執行期的成本。</p>
<p>然而，這套系統仍有某些成本：學習曲線。
許多 Rust 的新使用者會經歷我們所說的 &quot;與借用檢查器 (borrow checker) 戰鬥&quot; 的經驗，也就是 Rust 編譯器無法編譯一個作者認為合理的程式。
在程式設計師內心的所有權運作模型與實際上 Rust 實作不相符的時候，這會常常發生。
一開始你可能也會經歷類似的事情。
然而有個好消息：許多有經驗的 Rust 開發者回報，當他們適應所有權系統的規則一陣子之後，他們跟借用檢查器的戰鬥就越來越少了。</p>
<p>記住這些之後，讓我們開始學習生命週期。</p>
<h2>生命週期 (Lifetimes)</h2>
<p>出借一個指向他人擁有的資源的參照是很複雜的。
舉例來說，想像一下以下的操作行為：</p>
<ol>
<li>我獲得一個某種資源的控制代碼 (handle)。</li>
<li>我把指向這個資源的參照借給你。</li>
<li>我決定不再使用這個資源，釋放它，但你仍還有你那邊的參照。</li>
<li>你決定要使用此資源。</li>
</ol>
<p>噢！你的參照指向了一個無效的資源。
如果資源是記憶體時，我們叫它迷途指標 (dangling pointer) 或 &quot;釋放後的使用&quot;。</p>
<p>要修正這個問題，我們必須確保上述第四步不會在第三步之後發生。
Rust 的所有權系統透過一個叫做生命週期 (lifetimes) 的概念達成這點，它會描述參照的有效範圍。</p>
<p>當我們有一個函式透過參數取用了一個參照，我們可以不言明 (implicit) 或言明 (explicit) 參照的生命週期：</p>
<pre><code class="language-rust">// implicit
fn foo(x: &amp;i32) {
}

// explicit
fn bar&lt;'a&gt;(x: &amp;'a i32) {
}
</code></pre>
<p><code>'a</code> 唸作 &quot;生命週期 a&quot;。
技術上，所有參照都有關聯的生命週期，但是編譯器通常讓你可以省略它（參考後述的 <a href="#%E7%94%9F%E5%91%BD%E9%80%B1%E6%9C%9F%E7%9C%81%E7%95%A5%20(Lifetime%20Elision)">&quot;生命週期省略&quot;</a>）。
在我們講到省略之前，先讓我們拆解言明生命週期的範例：</p>
<pre><code class="language-rust,ignore">fn bar&lt;'a&gt;(...)
</code></pre>
<p>我們之前談到了一些<a href="functions.html">函式語法</a>，但我們沒有討論到函式後面的 <code>&lt;&gt;</code>。
一個函式可以在 <code>&lt;&gt;</code> 間放入 &quot;泛型參數&quot; (generic parameters)，生命週期也是其中一種。
我們<a href="generics.html">在之後</a>會討論到其他的泛型，但現在讓我們專注在生命週期方面。</p>
<p>我們使用 <code>&lt;&gt;</code> 去宣告我們的生命週期。
這代表 <code>bar</code> 有一個生命週期 <code>'a</code>。
如果我們有兩個參照參數，那麼將會看起來像：</p>
<pre><code class="language-rust,ignore">fn bar&lt;'a, 'b&gt;(...)
</code></pre>
<p>然後在我們的參數列表中，我們使用我們所命名的生命週期：</p>
<pre><code class="language-rust,ignore">...(x: &amp;'a i32)
</code></pre>
<p>如果我們想要一個 <code>&amp;mut</code> 參照，這樣做：
I</p>
<pre><code class="language-rust,ignore">...(x: &amp;'a mut i32)
</code></pre>
<p>如果你比較 <code>&amp;mut i32</code> 和 <code>&amp;'a mut i32</code> 兩者，除了在 <code>&amp;</code> 和 <code>mut i32</code> 間多出生命週期 <code>'a</code>，你會發現他們是一樣的。
我們把 <code>&amp;mut i32</code> 叫做 &quot;一個 <code>i32</code> 可變參照&quot;，而 <code>&amp;'a mut i32</code> 叫做 &quot;一個生命週期為 <code>'a</code> 的 <code>i32</code> 可變參照&quot;</p>
<h2>在 <code>struct</code> 中</h2>
<p>當處理含有參照的<a href="structs.html">結構體</a> (struct) 食，你也同樣需要言明生命週期：</p>
<pre><code class="language-rust">struct Foo&lt;'a&gt; {
    x: &amp;'a i32,
}

fn main() {
    let y = &amp;5; // this is the same as `let _y = 5; let y = &amp;_y;`
    let f = Foo { x: y };

    println!(&quot;{}&quot;, f.x);
}
</code></pre>
<p>如你所見，<code>struct</code> 也有生命週期。
它的表示方式跟函式很像：</p>
<pre><code class="language-rust">struct Foo&lt;'a&gt; {
# x: &amp;'a i32,
# }
</code></pre>
<p>宣告生命週期，接著：</p>
<pre><code class="language-rust"># struct Foo&lt;'a&gt; {
x: &amp;'a i32,
# }
</code></pre>
<p>使用生命週期。
那為何我們在此處需要生命週期呢？
因為我們必須確保任何參考到 <code>Foo</code> 的參照不能存活的比 <code>Foo</code> 所內含的 <code>i32</code> 參照還久。</p>
<blockquote>
<p>譯註：簡單說，如果 <code>Foo</code> 內的 <code>i32</code> 參照失效後，如果仍有指向 <code>Foo</code> 的參照，取用此參照內的 <code>i32</code> 參照就會出問題。</p>
</blockquote>
<h3><code>impl</code> 區塊</h3>
<p>讓我們替 <code>Foo</code> 實作一個方法：</p>
<pre><code class="language-rust">struct Foo&lt;'a&gt; {
    x: &amp;'a i32,
}

impl&lt;'a&gt; Foo&lt;'a&gt; {
    fn x(&amp;self) -&gt; &amp;'a i32 { self.x }
}

fn main() {
    let y = &amp;5; // this is the same as `let _y = 5; let y = &amp;_y;`
    let f = Foo { x: y };

    println!(&quot;x is: {}&quot;, f.x());
}
</code></pre>
<p>如你所見，我們需要在 <code>impl</code> 那行宣告 <code>Foo</code> 的生命週期。
我們重複了 <code>'a</code> 兩次，跟函式一樣：<code>impl&lt;'a&gt;</code> 定義了生命週期 <code>'a</code>，而 <code>Foo&lt;'a&gt;</code> 則使用它。</p>
<h3>多重生命週期</h3>
<p>如果你有多個參照，你可以重複使用相同的生命週期：</p>
<pre><code class="language-rust">fn x_or_y&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
#    x
# }
</code></pre>
<p>這代表 <code>x</code> 和 <code>y</code> 都存活在同樣的有效範圍內，且回傳值也存活在同樣的有效範圍。
如果你想要讓 <code>x</code> 和 <code>y</code> 有不同的生命週期，你可以使用多個生命週期參數：</p>
<pre><code class="language-rust">fn x_or_y&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;'a str {
#    x
# }
</code></pre>
<p>在此範例中，<code>x</code> 與 <code>y</code> 有不同的有效範圍，但回傳值的生命週期與 <code>x</code> 相同。</p>
<h3>對有效範圍的深思 (Thinking in scopes)</h3>
<p>瞭解生命週期的一個方式是將參照的有效範圍視覺化。
例如：</p>
<pre><code class="language-rust">fn main() {
    let y = &amp;5;     // -+ y goes into scope
                    //  |
    // stuff        //  |
                    //  |
}                   // -+ y goes out of scope
</code></pre>
<p>加入 <code>Foo</code>：</p>
<pre><code class="language-rust">struct Foo&lt;'a&gt; {
    x: &amp;'a i32,
}

fn main() {
    let y = &amp;5;           // -+ y goes into scope
    let f = Foo { x: y }; // -+ f goes into scope
    // stuff              //  |
                          //  |
}                         // -+ f and y go out of scope
</code></pre>
<p><code>f</code> 存活在 <code>y</code> 的有效範圍內，所以一切運作正常。
但如果不是（在有效範圍內）呢？
以下程式碼無法運作：</p>
<pre><code class="language-rust,ignore">struct Foo&lt;'a&gt; {
    x: &amp;'a i32,
}

fn main() {
    let x;                    // -+ x goes into scope
                              //  |
    {                         //  |
        let y = &amp;5;           // ---+ y goes into scope
        let f = Foo { x: y }; // ---+ f goes into scope
        x = &amp;f.x;             //  | | error here
    }                         // ---+ f and y go out of scope
                              //  |
    println!(&quot;{}&quot;, x);        //  |
}                             // -+ x goes out of scope
</code></pre>
<p>唷！如你所見，<code>f</code> 和 <code>y</code> 的有效範圍比 <code>x</code> 的有效範圍小。
但是當我們執行 <code>x = &amp;f.x</code> 時，我們會使 <code>x</code> 參考到已經離開有效範圍的東西。</p>
<p>命名生命週期是給予有效範圍名稱的方式。
賦予東西一個名稱，是開始討論它的第一步。</p>
<h3>'static</h3>
<p>名稱叫做 <code>static</code> 的生命週期是特殊的生命週期。
它代表了某樣東西具有整個程式的生命週期。
大多數 Rust 程式設計師會在處理字串時第一次遇到 <code>'static</code>：</p>
<pre><code class="language-rust">let x: &amp;'static str = &quot;Hello, world.&quot;;
</code></pre>
<p>字串是 <code>&amp;'static str</code> 型別，因為參照一直存活著：他們被放在最後的執行檔內的資料區段。
另一個例子是全域變數：</p>
<pre><code class="language-rust">static FOO: i32 = 5;
let x: &amp;'static i32 = &amp;FOO;
</code></pre>
<p>這會加入一個 <code>i32</code> 到執行檔的資料區段，<code>x</code> 則是指向它的參照。</p>
<h3>生命週期省略 (Lifetime Elision)</h3>
<p>Rust 在函式中支援強大的局部型別推斷 (local type inference)，但在 item signatures 中則被禁止，才能讓它根據簽署去推論其型別。
然而，為了人機工程的理由，第二種受限的推斷方式 &quot;生命週期省略&quot; 被允許用在函式的簽署。
它只根據簽署元件本身推斷，而不基於函式內容，而且只根據三個簡單易記、不易混淆的規則推斷生命週期參數。
這使得撰寫 item signatures 時可以速寫生命週期省略，但不能隱藏它的實際型別，因為局部型別推斷時可能會需要它。</p>
<blockquote>
<p>譯註：<code>item signatures</code> 應是指宣告函式時的輸入參數們，以及回傳值的宣告。</p>
</blockquote>
<p>當我們談到生命週期省略，我們使用 <em>輸入生命週期</em> (input lifetime) 與 <em>輸出生命週期</em> (output lifetime) 的字眼。
<em>輸入生命週期</em> 是指函式的參數的生命週期，而 <em>輸出生命週期</em> 是指函式回傳值的生命週期。
例如，以下函式有一個輸入生命週期：</p>
<pre><code class="language-rust,ignore">fn foo&lt;'a&gt;(bar: &amp;'a str)
</code></pre>
<p>此函式則有一個輸出生命週期：</p>
<pre><code class="language-rust,ignore">fn foo&lt;'a&gt;() -&gt; &amp;'a str
</code></pre>
<p>此一函式兩者皆有：</p>
<pre><code class="language-rust,ignore">fn foo&lt;'a&gt;(bar: &amp;'a str) -&gt; &amp;'a str
</code></pre>
<p>以下是三條規則：</p>
<ul>
<li>每個函式的參數所省略的生命週期都成為個別不同的生命週期參數。</li>
<li>如果恰好只有一個輸入生命週期，無論省略與否，其生命週期會被賦予所有回傳值中所省略的生命週期。</li>
<li>如果有多個輸入生命週期，但其中有 <code>&amp;self</code> 或 <code>&amp;mut self</code>，那 <code>self</code> 的生命週期會被賦予所有省略的生命週期。</li>
</ul>
<p>否則，省略輸入生命週期會出現錯誤訊息。</p>
<h4>範例</h4>
<p>以下有一些省略生命週期的函式範例。
我們把省略的範例與其展開生命週期的樣子，各別放在一起比對。</p>
<pre><code class="language-rust,ignore">fn print(s: &amp;str); // elided
fn print&lt;'a&gt;(s: &amp;'a str); // expanded

fn debug(lvl: u32, s: &amp;str); // elided
fn debug&lt;'a&gt;(lvl: u32, s: &amp;'a str); // expanded

// In the preceding example, `lvl` doesn’t need a lifetime because it’s not a
// reference (`&amp;`). Only things relating to references (such as a `struct`
// which contains a reference) need lifetimes.

fn substr(s: &amp;str, until: u32) -&gt; &amp;str; // elided
fn substr&lt;'a&gt;(s: &amp;'a str, until: u32) -&gt; &amp;'a str; // expanded

fn get_str() -&gt; &amp;str; // ILLEGAL, no inputs

fn frob(s: &amp;str, t: &amp;str) -&gt; &amp;str; // ILLEGAL, two inputs
fn frob&lt;'a, 'b&gt;(s: &amp;'a str, t: &amp;'b str) -&gt; &amp;str; // Expanded: Output lifetime is ambiguous

fn get_mut(&amp;mut self) -&gt; &amp;mut T; // elided
fn get_mut&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a mut T; // expanded

fn args&lt;T: ToCStr&gt;(&amp;mut self, args: &amp;[T]) -&gt; &amp;mut Command; // elided
fn args&lt;'a, 'b, T: ToCStr&gt;(&amp;'a mut self, args: &amp;'b [T]) -&gt; &amp;'a mut Command; // expanded

fn new(buf: &amp;mut [u8]) -&gt; BufWriter; // elided
fn new&lt;'a&gt;(buf: &amp;'a mut [u8]) -&gt; BufWriter&lt;'a&gt;; // expanded
</code></pre>
<blockquote>
<p><em>commit f4fac9b</em></p>
</blockquote>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="references-and-borrowing.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="mutability.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="references-and-borrowing.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="mutability.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
